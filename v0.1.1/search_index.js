var documenterSearchIndex = {"docs":
[{"location":"basis/#Basis-Sets","page":"Basis Sets","title":"Basis Sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The procedure to construct a basis set can be fundamentally broken down into several basic steps: first, choose a set of (tunable) parameters, and build the Gaussian functions around those parameters, then the basis functions around the Gaussian functions, finally the basis set.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The data structure formularized by Quiqbox in each step, namely the level of data complexity, can be summarized in the following table.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"level objective product examples abstract type type instances\n4 basis set Array of basis functions (with reusable integrals) Array, GTBasis Array{<:BasisFunc, 1}...\n3 basis functions single or linear combination of Gaussian functions FloatingGTBasisFunc BasisFunc{:S, 1}, BasisFuncs{:P, 3, 3}...\n2 Gaussian functions (primitive) Gaussian functions AbstractGaussFunc GaussFunc\n1 a pool of parameters center coordinates, function coefficients ParamBox ParamBox{:xpn, Float64}...","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Depending on how much control the user wants to have over each step, Quiqbox provides several methods of related functions to leave the user with the freedom to balance between efficiency and customizability. ","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Below are some examples from the simplest way to relatively more flexible ways to construct a basis set in Quiqbox. Hopefully these use cases can also work as inspirations for more creative ways to manipulate basis sets.","category":"page"},{"location":"basis/#Basis-Set-Construction","page":"Basis Sets","title":"Basis Set Construction","text":"","category":"section"},{"location":"basis/#Constructing-basis-sets-from-existed-basis-sets","page":"Basis Sets","title":"Constructing basis sets from existed basis sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"First, you can create a basis set at one coordinate by input the Vector of its center coordinate and a Tuple of its name and corresponding atom in String.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nbsO = Quiqbox.genBasisFunc([0,0,0], (\"STO-3G\", \"O\"))","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Notice that in the above result there are 2 types of structs in the returned Vector: BasisFunc and BasisFuncs. BasisFunc is the most basic type to hold the data of a basis function; BasisFuncs is very similar except it may hold multiple orbitals with only the spherical harmonics Y_ml being different when the orbital angular momentum l0.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"info: Unit System\nHartree atomic units are the unit system used in Quiqbox.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to postpone the specification of the center, you can replace the 1st argument with missing, and then use function assignCenter! to assign the coordinates later.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsO = genBasisFunc(missing, (\"STO-3G\", \"O\"))\n\nassignCenter!([0,0,0], bsO[1]);\n\nbsO\n\nassignCenter!.(Ref([0,0,0]), bsO[2:end])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you omit the atom in the arguments, H will be set in default. Notice that even there's only 1 single basis function in H's STO-3G basis set, the returned value is still in Array type.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsH_1 = genBasisFunc([-0.5, 0, 0], \"STO-3G\")\n\nbsH_2 = genBasisFunc([ 0.5, 0, 0], \"STO-3G\")","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Finally, you can use Quiqbox's included tool function flatten to merge the three atomic basis set into one molecular basis set:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsH20 = [bsO, bsH_1, bsH_2] |> flatten","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Not simple enough? Here's a more compact way of realizing the above steps if you are familiar with some syntactic sugars in Julia:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"cens = [[0,0,0], [-0.5,0,0], [0.5,0,0]]\n\nbsH20_2 = genBasisFunc.(cens, [(\"STO-3G\", \"O\"), fill(\"STO-3G\", 2)...]) |> flatten","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"In quiqbox, the user can often deal with several multi-layer containers (mainly structs), it might be easy to get lost or uncertain that whether we are creating the objects intended. Quiqbox provides another tool function hasEqual that lets you compare if two objects hold the same data and structure. For example, if we want to see whether bsH20_2 created in the faster way is same (not identical) as bsH20, we can verify it as follows:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"hasEqual(bsH20, bsH20_2)","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If the basis set you want to use doesn't exist in Quiqbox's library, you can use Function genBFuncsFromText to generate the basis set from a Gaussian formatted String:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"genBasisFunc(missing, (\"6-31G\", \"Kr\"))\n\n# Data from https://www.basissetexchange.org\ntxt_Kr_631G = \"\"\" \nKr     0\nS    6   1.00\n      0.1205524000D+06       0.1714050000D-02\n      0.1810225000D+05       0.1313805000D-01\n      0.4124126000D+04       0.6490006000D-01\n      0.1163472000D+04       0.2265185000D+00\n      0.3734612000D+03       0.4764961000D+00\n      0.1280897000D+03       0.3591952000D+00\nSP   6   1.00\n      0.2634681000D+04       0.2225111000D-02       0.3761911000D-02\n      0.6284533000D+03       0.2971122000D-01       0.2977531000D-01\n      0.2047081000D+03       0.1253926000D+00       0.1311878000D+00\n      0.7790827000D+02       0.1947058000D-02       0.3425019000D+00\n      0.3213816000D+02      -0.5987388000D+00       0.4644938000D+00\n      0.1341845000D+02      -0.4958972000D+00       0.2087284000D+00\nSP   6   1.00\n      0.1175107000D+03      -0.6157662000D-02      -0.6922855000D-02\n      0.4152553000D+02       0.5464841000D-01      -0.3069239000D-01\n      0.1765290000D+02       0.2706994000D+00       0.4480260000D-01\n      0.7818313000D+01      -0.1426136000D+00       0.3636775000D+00\n      0.3571775000D+01      -0.7216781000D+00       0.4952412000D+00\n      0.1623750000D+01      -0.3412008000D+00       0.2086340000D+00\nSP   3   1.00\n      0.2374560000D+01       0.3251184000D+00      -0.3009554000D-01\n      0.8691930000D+00      -0.2141533000D+00       0.3598893000D+00\n      0.3474730000D+00      -0.9755083000D+00       0.7103098000D+00\nSP   1   1.00\n      0.1264790000D+00       0.1000000000D+01       0.1000000000D+01\nD    3   1.00\n      0.6853888000D+02       0.7530705000D-01\n      0.1914333000D+02       0.3673551000D+00\n      0.6251213000D+01       0.7120146000D+00\nD    1   1.00\n      0.1979236000D+01       1.0000000\n\"\"\";\n\ngenBFuncsFromText(txt_Kr_631G, adjustContent=true)","category":"page"},{"location":"basis/#Constructing-basis-sets-from-GaussFunc","page":"Basis Sets","title":"Constructing basis sets from GaussFunc","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to specify the parameters of each Gaussian function when constructing a basis set, you can first construct the container for Gaussian functions: GaussFunc, and then build the basis function upon them:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"using Quiqbox # hide\n\ngf1 = GaussFunc(2.0, 1.0)\n\ngf2 = GaussFunc(2.5, 0.75)\n\nbf1 = genBasisFunc([1.0,0,0], [gf1, gf2])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Unlike BasisFunc there's no proprietary function for it, you simply input the exponent coefficient and the contraction coefficient as the 1st and 2nd arguments respectively to its default constructor. As for the method of genBasisFunc in this case, the default subshell is set to be \"S\" as the optional 3rd argument, but you can construct a BasisFuncs which contains all the orbitals within a specified one:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf2 = genBasisFunc([1.0,0,0], [gf1, gf2], \"P\")","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"You can even choose one or a few orbitals to keep by indicting them using a 3-element Array of the Cartesian representation:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf3 = genBasisFunc([1.0,0,0], [gf1, gf2], [1,0,0])\n\nbf4 = genBasisFunc([1.0,0,0], [gf1, gf2], [[1,0,0], [0,0,1]])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Again, if you want a faster solution, you can also directly define the 2 GaussFunc parameter(s) in a 2-element Tuple as the 2nd argument for genBasisFunc:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf5 = genBasisFunc([1.0,0,0], ([2.0, 2.5], [1.0, 0.75]), [[1,0,0], [0,0,1]])\n\nhasEqual(bf4, bf5)","category":"page"},{"location":"basis/#Constructing-basis-sets-based-on-ParamBox","page":"Basis Sets","title":"Constructing basis sets based on ParamBox","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Sometimes you may want the parameters of basis functions (or GaussFunc) to be under some constrains (which can be crucial for the later basis set optimization), this is when you need a deeper level of control over the parameters, through its direct container: ParamBox. In fact, in the above example we have already had an glimpse on it through the printed info in the REPL:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf1","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"the 2 fields of a GaussFunc, .xpn and .con are in fact ParamBox, and the actual value of them can be accessed through syntax []:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf1.xpn \n\ngf1.con\n\ngf1.xpn[] \n\ngf1.con[]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Since the data are not directly stored as primitive types but rather inside struct ParamBox, this allows the direct assignment or shallow copy of them to not create new data with same values, but bindings to the original objects:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf3 = GaussFunc(1.1, 1)\n\n# Direct assignment\ngf3_2 = gf3\n\ngf3.xpn[] *= 2\n\ngf3 \n\ngf3_2\n\n# Shallow copy: `fill`\nbf6 = genBasisFunc([1,0,0], fill(gf3, 2))\n\nbf6.gauss\n\nbf6.gauss[1].xpn[] = 1.1\n\ngf3_2.xpn[] == gf3.xpn[] == bf6.gauss[2].xpn[] == 1.1\n","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Based on such trait in Julia, you can, for instance, create a basis set that enforces all the GaussFuncs have the identical parameters:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf4 = GaussFunc(2.5, 0.5)\n\nbs7 = genBasisFunc.([rand(3) for _=1:2], Ref(gf4))\n\nuniqueParams!(bs7)","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"uniqueParams! marks all the parameters of the given basis set and  return the unique parameters. As you can see, even though bs7 has  2 GaussFuncs as basis functions, but over all it only has 1 unique coefficient exponent alpha_1 and 1 unique contraction coefficient d_1.","category":"page"},{"location":"basis/#Dependent-Variable-as-Parameter","page":"Basis Sets","title":"Dependent Variable as Parameter","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Another control the user can have on the parameters in Quiqbox is to not only store the each unique parameter as an independent variable, but also as a dependent variable, i.e., a math function of some more primitive independent variable:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"pb1 = gf4.xpn\n\npb1.map","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The map field of a ParamBox stores a RefValue{<:Function}, referencing the Function that maps the actual stored value to another value through math operations (R to R). The output value can be access through syntax (). In default the the variable is mapped to itself:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"pb1[] == pb1()","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Since ParamBox is a mutable struct you can redefine your own mapping Functions for the parameters; thus gain another layer of control over the basis set parameters:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"squareXpn(x) = x^2\n\npb1.map = Ref(squareXpn)\n\npb1[] = 3\n\npb1()","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"You can get a clearer view of the mapping relations in a ParamBox using getVar","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"getVar(pb1, includeMapping=true)","category":"page"},{"location":"SCF/#Self-Consistent-Field-Methods","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"","category":"section"},{"location":"SCF/#Hartree-Fock-Methods","page":"Self-Consistent Field Methods","title":"Hartree-Fock Methods","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox supports basic Hartree-Fock methods with various configurations: ","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Items Options\nHF Types Restricted Closed-Shell (RHF), Unrestricted Open-Shell (UHF)\nInitial Guesses Core Hamiltonian, Generalized Wolfsberg-Helmholtz, User-defined Coefficient Matrix\nConverging Methods Direct Diagonalization, DIIS, EDIIS, ADIIS, Combinations of Multi-methods\nDIIS-type Method Solvers Lagrange Multiplier Solver, ADMM Solver","category":"page"},{"location":"SCF/#Basic-Hartree-Fock","page":"Self-Consistent Field Methods","title":"Basic Hartree-Fock","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"To run a Hartree-Fock method, the lines of code required in Quiqbox is as simple as below:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nnuc = [\"H\", \"H\"];\n\nnucCoords = [[-0.7, 0.0, 0.0], [0.7, 0.0, 0.0]];\n\nbs = genBasisFunc.(nucCoords, (\"STO-3G\", \"H\") |> Ref) |> flatten\n\nresRHF = runHF(bs, nuc, nucCoords, HFtype=:RHF)\n\n@show resRHF.E0HF resRHF.C resRHF.Emo resRHF.occu","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"After the SCF procedure, one can also easily store the result in a Molecule for further data processing such as generating Molden files.","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"mol = Molecule(bs, nuc, nucCoords, resRHF);","category":"page"},{"location":"SCF/#Flexible-core-functions","page":"Self-Consistent Field Methods","title":"Flexible core functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"If the user want to fine-tune part of the SCF iteration steps to achieve better performance, Quiqbox also has provided various more flexible core functions that  allows user to customize the HF methods:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"SCFconfig","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"runHFcore","category":"page"},{"location":"SCF/#Standalone-Integral-Functions","page":"Self-Consistent Field Methods","title":"Standalone Integral Functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox also provides several integral functions that can be used independently of any SCF functions if intended.Those functions are wrappers of binary Julia library package (JLL) libcint_jll, with more simplistic signature and versatile functionality.","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlap","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlaps","category":"page"},{"location":"SCF/#One-electron-functions","page":"Self-Consistent Field Methods","title":"One-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttractions","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetic","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetics","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox.oneBodyBFTensor","category":"page"},{"location":"SCF/#Two-electron-functions","page":"Self-Consistent Field Methods","title":"Two-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteractions","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox.twoBodyBFTensor","category":"page"},{"location":"coreType/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"ParamBox{V, T}","category":"page"},{"location":"coreType/#Quiqbox.ParamBox","page":"Core Types","title":"Quiqbox.ParamBox","text":"ParamBox{V, T} <: DifferentiableParameter{ParamBox, T}\n\nParameter container that enables parameter differentiations.\n\n≡≡≡ Field(s) ≡≡≡\n\ndata::T: Stored parameter. It can be accessed through syntax [].\n\ncanDiff::Bool: Indicator that whether this container should be marked as differentiable.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nParamBox(data::Number, name::Symbol=:undef; mapFunction::Function=itself, \n         canDiff::Bool=true, paramType::Type{T}=Float64) -> \nParamBox{T}\n\nname specifies the name of the variable to be stored, which helps with symbolic  representation and automatic differentiation.\n\nmapFunction is for the case to the store the variable that is a dependent variable  (math function) f(x) of another variable x which is the actually stored in the struct, and  linked to the f(x) via the mapFunction. After initializing the ParamBox, e.g  pb1 = ParamBox(x, mapFunction=f), pb.data[] returns x, and pb.data() returns f(x).\n\ncanDiff is used to mark the (independent) variable as differentiable when set to true,  otherwise the ParamBox will be ignored in any differentiation process.\n\nparamType specifies the type of the stored variable to avoid data type mutation.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> Quiqbox.ParamBox(1.0)\nParamBox{Float64}(1.0)[∂]\n\nNOTE: When the parameter inside x::ParamBox is marked as \"differentiable\" (a.k.a.  x.canDiff=true), \"[∂]\" in the printing info is in color green, otherwise it's in grey.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GaussFunc","category":"page"},{"location":"coreType/#Quiqbox.GaussFunc","page":"Core Types","title":"Quiqbox.GaussFunc","text":"GaussFunc <: AbstractGaussFunc\n\nA single contracted gaussian function struct from package Quiqbox.\n\n≡≡≡ Field(s) ≡≡≡\n\nxpn::ParamBox{:𝛼, Float64}：Exponent of the gaussian function.\n\ncon::ParamBox{:𝑑, Float64}: Contraction coefficient of the gaussian function.\n\nparam::NTuple{2, ParamBox}: A Tuple that stores the ParamBoxs of xpn and con.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGaussFunc(xpn::Real, con::Real) -> GaussFunc\n\nGenerate a GaussFunc given the specified exponent and contraction coefficient.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> GaussFunc(5.0, 1.0)\nGaussFunc(xpn=ParamBox{:α, Float64}(5.0)[α][∂], con=ParamBox{:d, Float64}(1.0)[d][∂])\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"BasisFunc{S, GN}","category":"page"},{"location":"coreType/#Quiqbox.BasisFunc","page":"Core Types","title":"Quiqbox.BasisFunc","text":"BasisFunc{S, GN} <: FloatingGTBasisFunc{S, GN, 1}\n\nA (floating) basis function with the center attached to it instead of any nucleus.\n\n≡≡≡ Field(s) ≡≡≡\n\ncenter::NTuple{3, ParamBox}: The center coordinate in form of a 3-element ParamBox-type  Tuple.\n\ngauss::NTuple{N, GaussFunc}: Gaussian functions within the basis function.\n\nsubshell::String: The subshell (angular momentum symbol).\n\nijk::Tuple{String}: Cartesian representation (pseudo-quantum number) of the angular  momentum orientation. E.g., s would be (\"X⁰Y⁰Z⁰\")\n\nnormalizeGTO::Bool: Whether the GTO::GaussFunc will be normalized in calculations.\n\nparam::Tuple{Vararg{<:ParamBox}}： All the tunable parameters::ParamBox stored in the  BasisFunc.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nBasisFunc(center::Tuple{Vararg{<:ParamBox}}, gauss::Array{<:GaussFunc, 1}, \n          ijk::Array{Int, 1}, normalizeGTO::Bool) -> BasisFunc{S, GN}\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"BasisFuncs{S, GN, ON}","category":"page"},{"location":"coreType/#Quiqbox.BasisFuncs","page":"Core Types","title":"Quiqbox.BasisFuncs","text":"BasisFuncs{S, GN, ON} <: FloatingGTBasisFunc{S, GN, ON}\n\nA group of basis functions with identical parameters except they have different subshell  under the specified angular momentum. It has the same fields as BasisFunc and  specifically, for ijk, instead of being a 1-element Tuple, the size of the Tuple is  the size of the corresponding subshell.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GTBasis{N, BT}","category":"page"},{"location":"coreType/#Quiqbox.GTBasis","page":"Core Types","title":"Quiqbox.GTBasis","text":"GTBasis{N, BT} <: BasisSetData{N}\n\nThe container to store basis set information.\n\n≡≡≡ Field(s) ≡≡≡\n\nbasis::Array{<:AbstractFloatingGTBasisFunc, 1}: Basis set. S::Array{<:Number, 2}: Overlap matrix. Te::Array{<:Number, 2}: Kinetic energy part of the electronic core Hamiltonian. eeI::Array{<:Number, 4}: Electron-electron interaction. getVne::Function: A Function that returns the nuclear attraction Hamiltonian when                      nuclei::Array{String, 1} and                      their coordinates::Array{<:AbstractArray, 1} are input. getHcore::Function: Similar as getVne, a Function that returns the core Hamiltonian                      when nuclei and their coordinates of same DataType are input.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGTBasis(basis::Vector{<:AbstractFloatingGTBasisFunc}, S::Matrix{<:Number}, \n        Te::Matrix{<:Number}, eeI::Array{<:Number, 4}) -> \nGTBasis\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GridBox{NX, NY, NZ}","category":"page"},{"location":"coreType/#Quiqbox.GridBox","page":"Core Types","title":"Quiqbox.GridBox","text":"GridBox{NX, NY, NZ} <: SemiMutableParameter{GridBox, Float64}\n\nA struct that stores coordinates of grid points in terms of both Vectors and  ParamBoxs.\n\n≡≡≡ Field(s) ≡≡≡\n\nnum::Int: Total number of the grid points.\n\nspacing::Float64: The edge length of the grid box.\n\nbox::Vector{NTuple{3, ParamBox}}: The coordinates of grid points in terms of ParamBoxs.\n\ncoord::Array{Array{Float64, 1}, 1}: The coordinates of grid points in terms of Vectors.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGridBox(nGrids::NTuple{3, Int}, spacing::Real=10, \n        centerCoord::Array{<:Real, 1}=[0.0,0.0,0.0];\n        canDiff::Bool=true, index::Int=0) -> GridBox\n\nConstructor of a general GridBox that doesn't have to shape as a cube. nGrid is a  3-element Tuple that specifies the number of grids (number of grid points - 1) along  3 dimensions. spacing specifies the length between adjacent grid points.  centerCoord specifies the geometry center coordinate of the box. canDiff determines  whether the ParamBox should be marked as differentiable. index defines the index  number for the actual parameter: spacing L, with the default value 0 it would be L₀.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"SCFconfig{N}","category":"page"},{"location":"coreType/#Quiqbox.SCFconfig","page":"Core Types","title":"Quiqbox.SCFconfig","text":"SCFconfig{N} <: ImmutableParameter{SCFconfig, Any}\n\nThe struct for SCF iteration configurations.\n\n≡≡≡ Field(s) ≡≡≡\n\nmethods::NTuple{N, Symbol}: The applied methods. The available methods are their  configurations (in terms of keyword arguments):\n\nMethods Configuration(s) keyword argument(s) Default value(s)\n:DS Damping strength: [0,1] dampingStrength::Float64 0.0\n:DIIS, :EDIIS, :ADIIS Subspace size (>1); Coefficient solver(:ADMM-> ADMM solver, :LCM -> Lagrange solver) DIISsize::Int; solver::Symbol 15; :ADMM\n\nintervals: The stopping (skipping) thresholds for the required methods.\n\nmethodConfigs: The additional keywords arguments for each method stored as Tuples of  Pairs.\n\noscillateThreshold: The threshold for oscillating convergence.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nSCFconfig(methods::Vector{Symbol}, intervals::Vector{Float64}, \n          configs::Dict{Int, <:Vector{<:Pair}}=Dict(1=>Pair[]);\n          oscillateThreshold::Float64=1e-5) -> \nSCFconfig{N}\n\nmethods and intervals are the methods to be applied and their stopping (skipping)  thresholds respectively; the length of those two Vectors should be the same. configs  specifies the additional keyword arguments for each methods by a Pair of which the Int  key i is for ith method and the pointed Vector{<:Pair} is the pairs of keyword  arguments and their values respectively.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> SCFconfig([:SD, :ADIIS, :DIIS], [1e-4, 1e-12, 1e-13],                   Dict(2=>[:solver=>:LCM]) SCFconfig{3}((:SD, :ADIIS, :DIIS), (0.0001, 1.0e-12, 1.0e-13), ((), (:solver => :LCM,),  ()), 1.0e-5)\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Quiqbox.HFtempVars{HFtype, N}","category":"page"},{"location":"coreType/#Quiqbox.HFtempVars","page":"Core Types","title":"Quiqbox.HFtempVars","text":"HFtempVars{HFtype, N} <: HartreeFockintermediateData\n\nThe container to store the intermediate values (only of the same spin configuration) for  each iteration during the Hartree-Fock SCF procedure. \n\n≡≡≡ Field(s) ≡≡≡\n\nCs::Array{Array{T1, 2}, 1} where {Float64<:T1<:Float64}: Coefficient matrices.\n\nFs::Array{Array{T2, 2}, 1} where {Float64<:T2<:Float64}: Fock matrices\n\nDs::Array{Array{T3, 2}, 1} where {Float64<:T3<:Float64}: Density matrices corresponding  to only spin configuration. For RHF each elements means (unconverged) 0.5*Dᵀ.\n\nEs::Array{Float64, 1}: Part of Hartree-Fock energy corresponding to only spin  configuration. For RHF each element means (unconverged) 0.5*E0HF.\n\nshared.Dtots::Array{Array{T, 2}, 1} where {Float64<:T<:Float64}: The total density  matrices.\n\nshared.Etots::Array{Float64, 1}: The total Hartree-Fock energy.\n\nNOTE: For UHF, there are 2 HFtempVars being updated during the SCF iterations, and  change the field shared.Dtots or shared.Etots of one container will affect the other  one's.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Quiqbox.HFfinalVars{T, N, Nb}","category":"page"},{"location":"coreType/#Quiqbox.HFfinalVars","page":"Core Types","title":"Quiqbox.HFfinalVars","text":"HFfinalVars{T, N, Nb} <: HartreeFockFinalValue{T}\n\nThe container of the final values after a Hartree-Fock SCF procedure.\n\n≡≡≡ Field(s) ≡≡≡\n\nE0HF::Float64: Hartree-Fock energy of the electronic Hamiltonian. \n\nC::Union{Array{T1, 2}, NTuple{2, Array{T1, 2}}} where {Float64<:T1<:Float64}:  Coefficient matrix(s) for one spin configuration.\n\nF::Union{Array{T2, 2}, NTuple{2, Array{T2, 2}}} where {Float64<:T2<:Float64}: Fock  matrix(s) for one spin configuration.\n\nD::Union{Array{T3, 2}, NTuple{2, Array{T3, 2}}} where {Float64<:T3<:Float64}: Density  matrix(s) for one spin configuration.\n\nEmo::Union{Array{Float64, 1}, NTuple{2, Array{Float64, 1}}}: Energies of molecular  orbitals.\n\noccu::Union{Array{Int, 1}, NTuple{2, Array{Int, 1}}}: occupation numbers of molecular  orbitals.\n\ntemp::Union{HFtempVars{T}, NTuple{2, HFtempVars{T}}} the intermediate values.\n\nisConverged::Bool: Whether the SCF procedure is converged in the end.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Molecule{Nc, Ne, Nb}","category":"page"},{"location":"coreType/#Quiqbox.Molecule","page":"Core Types","title":"Quiqbox.Molecule","text":"Molecule{Nc, Ne, Nb} <:MolecularHartreeFockCoefficient{Nc, Ne}\n\nContainer for the information of a molecule.\n\n≡≡≡ Field(s) ≡≡≡\n\nnuc::Tuple{Vararg{String}}: Nuclei of the molecule.\n\nnucCoords::Tuple{Vararg{NTuple{3, Real}}}: The coordinates of the nuclei.\n\nNe::Int: The number of electrons.\n\norbital::Tuple{Vararg{MolOrbital}}: Molecular orbitals.\n\nbasis::Tuple{Vararg{FloatingGTBasisFunc}}: The basis set for the molecular orbitals.\n\nE0HF::Float64: Hartree-Fock energy of the electronic Hamiltonian from the basis set.\n\nEnnR::Float64: The nuclear-nuclear repulsion energy.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nMolecule(basis::Array{FloatingGTBasisFunc, 1}, nuc::Array{String, 1}, \n         nucCoords::Array{<:AbstractArray, 1}, Ne::Int, E0HF::Float64, \n         Emos::Array{Float64, 1}, occus::Array{<:Real, 1}, C::Array{Float64, 2}, \n         spins::Array{String, 1}, \n         symms::Array{String, 1}=repeat([\"A\"], length(occus))) -> \nMolecule{Nc, Ne, Nb}\n\nEmos are the energies of corresponding molecular energies. occus are the occupation  numbers of the orbitals. C is the coefficient matrix, which does not need to be a square  matrix since the number of rows is the size of the (spatial) basis set whereas the number  of the columns represents the number of molecular orbitals. spin specifies the spin  functions of the orbitals, entries of which can be set to \"Alpha\" or \"Beta\". symms are  symmetries of the orbitals where the default entry value is \"A\" for being antisymmetric.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"MolOrbital{N}","category":"page"},{"location":"coreType/#Quiqbox.MolOrbital","page":"Core Types","title":"Quiqbox.MolOrbital","text":"MolOrbital{N} <: AbstractMolOrbital\n\nStruct of molecular orbitals.\n\n≡≡≡ Field(s) ≡≡≡\n\nsymmetry::String: The symmetry of the orbital. The default value is \"A\" for being  antisymmetric.\n\nenergy::Float64: Molecular energy.\n\nspin::String: Spin function of the orbital. Available values: \"Alpha\", \"Beta\".\n\noccupancy::Real: Occupation number.\n\norbitalCoeffs::NTuple{N, Float64}: coefficients of the basis functions to form the  molecular orbital.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nMolOrbital(energy::Float64, occupancy::Real, orbitalCoeffs::Array{Float64, 1}, \n           spin::String=\"Alpha\", symmetry::String=\"A\") -> MolOrbital{N}\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Parameter-Optimization","page":"Parameter Optimization","title":"Parameter Optimization","text":"","category":"section"},{"location":"optimization/#Selectively-Optimizing-Parameters","page":"Parameter Optimization","title":"Selectively Optimizing Parameters","text":"","category":"section"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"In the Basis Sets section we have briefly introduced the parameters in terms of  ParamBox that are embedded in containers such as BasisFunc and BasisFuncs that are directly used to form a basis set. This means how we construct the basis set using the parameters will determine how large of a parameter space we have to optimize the basis set. For more information please refer to Constructing basis sets based on ParamBox. Here is a example to use GaussFunc and GridBox to quickly generate a grid-based basis set with only 3 actual parameters, 1 determines all the coordinates of basis function centers, the other 2 are the only exponent coefficient alpha and contraction coefficient d.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nnuc = [\"H\", \"H\"]\n\nnucCoords = [[-0.7,0.0,0.0], [0.7,0.0,0.0]]\n\ngrid = GridBox(1, 1.5)\n\ngf1 = GaussFunc(0.7,1)\n\nbs = genBasisFunc.(grid.box, Ref([gf1]))","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After constructing the basis set, we need to use uniqueParams! to mark all the  unique parameters that can also be optimized later:","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"pars = uniqueParams!(bs, filterMapping=true)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"As expected, there are indeed only 3 unique tunable parameters despite the basis set already has 8 basis functions. (note that keyword argument filterMapping in uniqueParams! is set to true because we want the function to only return independent parameters) However, if we take a step further, we can remove d since each basis function here is just a single Gaussian function, which means the contraction coefficient won't affect the optimization results. Thus, input the intent parameters (along with other necessary arguments) into the Quiqbox function optimizeParams! and we can sit and wait for the optimization iterations to complete.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"parsPartial = [pars[1], pars[3]]\n\noptimizeParams!(bs, parsPartial, nuc, nucCoords, maxSteps=20);","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After the optimization, you can check the basis set and we can see the parameters inside of it is also changed. This is because the ! in the function names indicates that optimizeParams! is a function that modifies its arguments.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"getParams(bs)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"It you want to go through the above example by yourself, you can also find the script here.","category":"page"},{"location":"optimization/#Store-Customized-Basis-Set","page":"Parameter Optimization","title":"Store Customized Basis Set","text":"","category":"section"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"Now, if you want, you can also store the information of the basis set in an container called GTBasis that not only includes the basis set, but also the related 1-electron and 2-electron integral values (nuclear attraction is not stored). GTBasis can also be accepted as an argument for runHF to save the time of calculating the integrals of the basis set.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"GTBasis(bs)","category":"page"},{"location":"coreFunction/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBasisFunc","category":"page"},{"location":"coreFunction/#Quiqbox.genBasisFunc","page":"Core Functions","title":"Quiqbox.genBasisFunc","text":"genBasisFunc(args..., kws...) -> BasisFunc\ngenBasisFunc(args..., kws...) -> BasisFuncs\ngenBasisFunc(args..., kws...) -> collection\n\nConstructor of BasisFunc and BasisFuncs, but it also returns different kinds of  collections of them based on the applied methods.\n\n≡≡≡ Method 1 ≡≡≡\n\ngenBasisFunc(coord::AbstractArray, gs::Array{<:GaussFunc, 1}, \n             ijkOrijks::Union{Array{Int, 1}, Array{Array{Int, 1}, 1}}; \n             normalizeGTO::Bool=false)\n\nijkOrijks is the Array of the pseudo-quantum number(s) to specify the angular  momentum(s). E.g., s is [0,0,0] and p is [[1,0,0], [0,1,0], [0,0,1]].\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), [0,1,0])\nBasisFunc{:P, 1}(gauss, subshell, center)[X⁰Y¹Z⁰][0.0, 0.0, 0.0]\n\n≡≡≡ Method 2 ≡≡≡\n\ngenBasisFunc(coord::AbstractArray, gs::Array{<:GaussFunc, 1}, subshell::String=\"S\"; \n             ijkFilter::Array{Bool, 1}=fill(true, SubshellDimList[subshell]), \n             normalizeGTO::Bool=false)\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), \"S\")\nBasisFunc{:S, 1}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), \"P\")\nBasisFuncs{:P, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]\n\n≡≡≡ Method 3 ≡≡≡\n\ngenBasisFunc(coord::AbstractArray, gExpsANDgCons::NTuple{2, Array{<:Real, 1}}, \n             subshell=\"S\"; kw...)\n\nInstead of directly inputting GaussFunc, one can also input a 2-element Tuple of the  exponent(s) and contraction coefficient(s) corresponding to the same GaussFunc(s).\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> genBasisFunc([0,0,0], (2, 1), \"P\")\nBasisFuncs{:P, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], ([2, 1.5], [1, 0.5]), \"P\")\nBasisFuncs{:P, 2, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]\n\n≡≡≡ Method 4 ≡≡≡\n\ngenBasisFunc(center, BSKeyANDnuc::Array{Tuple{String, String}, 1})\n\nIf the user wants to construct existed atomic basis set(s), they can use the (Array of)  (BS_name, Atom_name) as the second input. If the atom is omitted, then basis set for H  is used.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> genBasisFunc([0,0,0], (\"STO-3G\", \"Li\"))\n3-element Vector{Quiqbox.FloatingGTBasisFunc}:\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFuncs{:P, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], \"STO-3G\")\n1-element Vector{Quiqbox.FloatingGTBasisFunc}:\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], [\"STO-2G\", \"STO-3G\"])\n2-element Vector{Quiqbox.FloatingGTBasisFunc}:\nBasisFunc{:S, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], [(\"STO-2G\", \"He\"), (\"STO-3G\", \"O\")])\n4-element Vector{Quiqbox.FloatingGTBasisFunc}:\nBasisFunc{:S, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]\nBasisFuncs{:P, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"centerOf","category":"page"},{"location":"coreFunction/#Quiqbox.centerOf","page":"Core Functions","title":"Quiqbox.centerOf","text":"centerOf(bf::FloatingGTBasisFunc) -> Array{<:Real, 1}\n\nReturn the center coordinate of the input FloatingGTBasisFunc.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"GTBasis(basis::Vector{<:Quiqbox.AbstractFloatingGTBasisFunc})","category":"page"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"decomposeBasisFunc","category":"page"},{"location":"coreFunction/#Quiqbox.decomposeBasisFunc","page":"Core Functions","title":"Quiqbox.decomposeBasisFunc","text":"decomposeBasisFunc(bf::FloatingGTBasisFunc; splitGaussFunc::Bool=false) -> \nArray{<:FloatingGTBasisFunc, 1}\n\nDecompose a FloatingGTBasisFunc into a Vector of BasisFuncs. If splitGaussFunc is  true, then each BasisFunc in the returned Vector only contains 1 GaussFunc.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"basisSize","category":"page"},{"location":"coreFunction/#Quiqbox.basisSize","page":"Core Functions","title":"Quiqbox.basisSize","text":"basisSize(subshell::Union{String, Array{String, 1}}) -> Tuple\n\nReturn the size (number of orbitals) of each subshell.\n\n\n\n\n\nbasisSize(basisFunctions) -> Tuple\n\nReturn the numbers of orbitals of the input basis function(s).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBasisFuncText","category":"page"},{"location":"coreFunction/#Quiqbox.genBasisFuncText","page":"Core Functions","title":"Quiqbox.genBasisFuncText","text":"genBasisFuncText(bf::FloatingGTBasisFunc; norm=1.0, printCenter=true) -> String\n\nGenerate a String of the text of the input FloatingGTBasisFunc. norm is the  additional normalization factor. If printCenter is true, the center coordinate  will be added on the first line of the String.\n\n\n\n\n\ngenBasisFuncText(bs::Array{<:FloatingGTBasisFunc, 1}; \n                 norm=1.0, printCenter=true, groupCenters::Bool=true) -> \nString\n\nGenerate a String of the text of the input basis set. norm is the additional  normalization factor. If printCenter is true, the center coordinate will be added  on the first line of the String. groupCenters determines whether the function will  group the basis functions with same center together.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBFuncsFromText","category":"page"},{"location":"coreFunction/#Quiqbox.genBFuncsFromText","page":"Core Functions","title":"Quiqbox.genBFuncsFromText","text":"genBFuncsFromText(content::String; adjustContent::Bool=false, \n                  adjustFunction::F=sciNotReplace, \n                  excludeFirstNlines=0, excludeLastNlines=0, \n                  center::Union{AbstractArray, \n                                Tuple{N, ParamBox}, \n                                Missing}=missing) where {N, F<:Function} -> \nArray{<:FloatingGTBasisFunc, 1}\n\nGenerate the basis set from a String of basis set in Gaussian format or the String output  from genBasisFuncText. For the former, adjustContent needs to be set to true.  adjustFunction is only applied when adjustContent=true, which in default is a  function used to detect and convert the format of the scientific notation in the String.\n\nexcludeFirstNlines and excludeLastNlines are used to exclude first or last few lines of  the String if intent. genBFuncsFromText can't directly read center coordinate  information from the String even if it's included, so argument center is used to assign a  coordinate for all the basis functions from the String; it can be a Vector, a Tuple of  the positional ParamBoxs, or simply (in default) set to missing for later assignment.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"assignCenter!","category":"page"},{"location":"coreFunction/#Quiqbox.assignCenter!","page":"Core Functions","title":"Quiqbox.assignCenter!","text":"assignCenter!(center::AbstractArray, b::FloatingGTBasisFunc) -> NTuple{3, ParamBox}\n\nAssign a new coordinate to the center of the input FloatingGTBasisFunc.  Also return the altered center.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"uniqueParams!","category":"page"},{"location":"coreFunction/#Quiqbox.uniqueParams!","page":"Core Functions","title":"Quiqbox.uniqueParams!","text":"uniqueParams!(bs; onlyDifferentiable::Bool=false, ignoreContainerType::Bool=false, \n              filter::Bool=true, filterMapping::Bool=false) -> Array{<:ParamBox, 1}\n\nMark the parameters (ParamBox) in input bs which can a Vector of GaussFunc or  FloatingGTBasisFunc. The identical parameters will be marked with same index.\n\n=== Keyword argument(s) ===\n\nonlyDifferentiable: Determine whether ignore un-differentiable parameters.\n\nignoreContainerType: If set to true, then only the field data of the ParamBoxs will  be compared to determine whether each ParamBox are unique. \n\nfilter: Determine whether filter out the identical ParamBoxs and only return the unique  ones.\n\nfilterMapping: Determine wether return the ParamBoxs with identical fields except the  map field. When filter=false, this argument is automatically overwritten to be false.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getVar","category":"page"},{"location":"coreFunction/#Quiqbox.getVar","page":"Core Functions","title":"Quiqbox.getVar","text":"getVar(pb::ParamBox; markUndifferentiable::Bool=false, includeMapping::Bool=false) -> \nArray{<:Pair{Symbolics.Num, <:Number}, 1}\n\nReturn a 1-element Vector of Pair to show the Symbol::Symbolics.Num of the stored  variable and the corresponding values.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getVars","category":"page"},{"location":"coreFunction/#Quiqbox.getVars","page":"Core Functions","title":"Quiqbox.getVars","text":"getVars(obj::Union{GaussFunc, BasisFunc}; markUndifferentiable::Bool=false, \n        includeMapping::Bool=false) -> Array{<:Pair, 1}\n\ngetVars(collection::Array{<:Union{GaussFunc, BasisFunc, ParamBox}, 1}; \n        markUndifferentiable::Bool=false, includeMapping::Bool=false) -> \nArray{<:Pair, 1}\n\nReturn a Vector of Pair to indicate the mapping relations of and between the variables  stored in the ParamBoxs in the given input.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"expressionOf","category":"page"},{"location":"coreFunction/#Quiqbox.expressionOf","page":"Core Functions","title":"Quiqbox.expressionOf","text":"expressionOf(gf::GaussFunc; markUndifferentiable::Bool=false, \n             substituteValue::Bool=false) -> Symbolics.Num\n\nexpressionOf(gf::FloatingGTBasisFunc; markUndifferentiable::Bool=false, \n             substituteValue::Bool=false) -> Array{<:Symbolics.Num, 2}\n\nReturn the expression of a given GaussFunc or FloatingGTBasisFunc. When the latter is  the input, a Matrix is returned of which the row(s) is(are) one orbital with the  expression(s) of its Gaussian function(s) as entry(entries).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"GridBox(nGridPerEdge::Int, spacing::Real=10, \n        centerCoord::Array{<:Real, 1}=[0.0,0.0,0.0]; \n        canDiff::Bool=true, index::Int=0)","category":"page"},{"location":"coreFunction/#Quiqbox.GridBox","page":"Core Functions","title":"Quiqbox.GridBox","text":"GridBox(nGridPerEdge::Int, spacing::Real=10, \n        centerCoord::Array{<:Real, 1}=[0.0,0.0,0.0]; \n        canDiff::Bool=true, index::Int=0) -> GridBox\n\nMethod of generating a cubic GridBox. nGridPerEdge specifies the number of grids  (number of grid points - 1) along each dimension.spacing specifies the length between  adjacent grid points. centerCoord specifies the geometry center coordinate of the box.  canDiff determines whether the ParamBox should be marked as differentiable. index  defines the index number for the actual parameter: spacing L, with the default value 0  it would be L₀.\n\n\n\n\n\n","category":"type"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"gridPoint","category":"page"},{"location":"coreFunction/#Quiqbox.gridPoint","page":"Core Functions","title":"Quiqbox.gridPoint","text":"gridPoint(coord::Array{<:Real, 1}) -> NTuple{3, ParamBox}\n\nGenerate a Tuple of coordinate ParamBoxs given a Vector.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"runHF","category":"page"},{"location":"coreFunction/#Quiqbox.runHF","page":"Core Functions","title":"Quiqbox.runHF","text":"runHF(bs::Union{BasisSetData, Array{<:AbstractFloatingGTBasisFunc, 1}}, \n      nuc::Array{String, 1}, \n      nucCoords::Array{<:AbstractArray, 1}, \n      N::Union{NTuple{2, Int}, Int}=getCharge(nuc); \n      initialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=:GWH, \n      HFtype::Symbol=:RHF, \n      scfConfig::SCFconfig=defaultSCFconfig, \n      earlyTermination::Bool=true, \n      printInfo::Bool=true, \n      maxSteps::Int=1000) where {Float64<:T<:Float64} -> HFfinalVars\n\nMain function to run Hartree-Fock in Quiqbox.\n\n=== Positional argument(s) ===\n\nbs::Union{BasisSetData, Array{<:AbstractFloatingGTBasisFunc, 1}}: Basis set.\n\nnuc::Array{String, 1}: The element symbols of the nuclei for the Molecule.\n\nnucCoords::Array{<:AbstractArray, 1}: The coordinates of the nuclei.\n\nN::Union{NTuple{2, Int}, Int}: The total number of electrons or the numbers of electrons  with different spins respectively.\n\n=== Keyword argument(s) ===\n\ninitialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.\n\nHFtype::Symbol: Hartree-Fock type. Available values are :RHF and :UHF.\n\nscfConfig::SCFconfig: SCF iteration configuration.\n\nearlyTermination::Bool: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.\n\nprintInfo::Bool: Whether print out the information of each iteration step.\n\nmaxSteps::Int: Maximum allowed iteration steps regardless of whether the SCF converges.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"runHFcore","category":"page"},{"location":"coreFunction/#Quiqbox.runHFcore","page":"Core Functions","title":"Quiqbox.runHFcore","text":"runHFcore(N::Union{NTuple{2, Int}, Int}, \n          Hcore::Array{T1, 2}, \n          HeeI::Array{T2, 4}, \n          S::Array{T3, 2}, \n          X::Array{T4, 2}=getX(S), \n          C::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=guessC(S, Hcore; X);\n          HFtype::Symbol=:RHF,  \n          scfConfig::SCFconfig{L}, \n          earlyTermination::Bool=true, \n          printInfo::Bool=true, \n          maxSteps::Int=1000) where {Float64<:T1<:Float64, \n          Float64<:T2<:Float64, \n          Float64<:T3<:Float64, \n          Float64<:T4<:Float64, \n          Float64<:T5<:Float64, L}\n\nThe core function of runHF.\n\n=== Positional argument(s) ===\n\nN::Union{NTuple{2, Int}, Int}: The total number of electrons or the numbers of electrons  with different spins respectively.\n\nHcore::Array{T1, 2}: Core Hamiltonian of electronic Hamiltonian.\n\nHeeI::Array{T2, 4}: The electron-electron interaction Hamiltonian which includes both the  Coulomb interactions and the Exchange Correlations.\n\nS::Array{T3, 2}: Overlap matrix of the corresponding basis set.\n\nX::Array{T4, 2}: Orthogonal transformation matrix of S. Default value is S^(-0.5).\n\nC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.\n\n=== Keyword argument(s) ===\n\nHFtype::Symbol: Hartree-Fock type. Available values are :RHF and :UHF.\n\nscfConfig::SCFconfig: SCF iteration configuration.\n\nearlyTermination::Bool: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.\n\nprintInfo::Bool: Whether print out the information of each iteration step.\n\nmaxSteps::Int: Maximum allowed iteration steps regardless of whether the SCF converges.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Molecule(basis::Array{<:Quiqbox.FloatingGTBasisFunc, 1}, nuc::Array{String, 1}, \n         nucCoords::Array{<:AbstractArray, 1}, HFfVars::Quiqbox.HFfinalVars)","category":"page"},{"location":"coreFunction/#Quiqbox.Molecule-Tuple{Vector{var\"#s30\"} where var\"#s30\"<:Quiqbox.FloatingGTBasisFunc, Vector{String}, Vector{var\"#s29\"} where var\"#s29\"<:AbstractArray, Quiqbox.HFfinalVars}","page":"Core Functions","title":"Quiqbox.Molecule","text":"Molecule(basis::Array{<:FloatingGTBasisFunc, 1}, nuc::Array{String, 1}, \n         nucCoords::Array{<:AbstractArray, 1}, HFfVars::HFfinalVars) -> Molecule\n\nConstruct a Molecule from a basis set, nuclei information, and the result from the  corresponding Hartree-Fock SCF procedure, specifically a HFfinalVars struct.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getMolOrbitals","category":"page"},{"location":"coreFunction/#Quiqbox.getMolOrbitals","page":"Core Functions","title":"Quiqbox.getMolOrbitals","text":"getMolOrbitals(ens::Array{Float64, 1}, occus::Array{<:Real, 1}, C::Matrix{Float64}, \n               spins::Array{String, 1}, \n               symms::Array{String, 1}=repeat([\"A\"], length(occus))) -> \nTuple{Vararg{getMolOrbitals}}\n\nA function that returns the molecular orbitals.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nnRepulsions","category":"page"},{"location":"coreFunction/#Quiqbox.nnRepulsions","page":"Core Functions","title":"Quiqbox.nnRepulsions","text":"nnRepulsions(nuc::Array{String, 1}, nucCoords::Array{<:AbstractArray, 1}) -> Float64\n\nCalculate the nuclear-nuclear repulsion energy given the nuclei and their coordinates of a  molecule.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"optimizeParams!","category":"page"},{"location":"coreFunction/#Quiqbox.optimizeParams!","page":"Core Functions","title":"Quiqbox.optimizeParams!","text":"optimizeParams!(bs::Array{<:FloatingGTBasisFunc, 1}, pbs::Array{<:ParamBox, 1},\n                nuc::Array{String, 1}, nucCoords::Array{<:AbstractArray, 1}, \n                Ne::Union{NTuple{2, Int}, Int}=getCharge(nuc);\n                Etarget::Float64=NaN, threshold::Float64=1e-4, maxSteps::Int=2000, \n                printInfo::Bool=true, GDmethod::F1=gradDescent!, HFtype::Symbol=:RHF, \n                ECmethod::F2=Quiqbox.defaultECmethod) where \n               {F1<:Function, F2<:Function} -> \nEs::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}\n\nThe main function to optimize the parameters of a given basis set.\n\n=== Positional argument(s) ===\n\nbs::Array{<:FloatingGTBasisFunc, 1}: Basis set.\n\npbs::Array{<:ParamBox, 1}: The parameters to be optimized that are extracted from the  basis set.\n\nnuc::Array{String, 1}: The nuclei of the molecule.\n\nnucCoords::Array{<:AbstractArray, 1}: The nuclei coordinates.\n\nNe::Union{NTuple{2, Int}, Int}: The total number of electrons or the numbers of electrons  with different spins respectively.\n\n=== Keyword argument(s) ===\n\nEtarget::Float64: The target Hartree-Hock energy intent to achieve.\n\nthreshold::Float64: The threshold for the convergence when evaluating difference between  the latest two energies.\n\nmaxSteps::Int: Maximum allowed iteration steps regardless of whether the optimization  iteration converges.\n\nprintInfo::Bool: Whether print out the information of each iteration step.\n\nGDmethod::F1: Applied gradient descent Function.\n\nHFtype::Symbol: Hartree-Fock type. Available values are :RHF and :UHF.\n\nECmethod::F2: The Function used to update Hartree-Fock energy and coefficient matrix(s)  during the optimization iterations. === Keyword argument(s) ===\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"updateParams!","category":"page"},{"location":"coreFunction/#Quiqbox.updateParams!","page":"Core Functions","title":"Quiqbox.updateParams!","text":"updateParams!(pbs::Array{<:ParamBox, 1}, grads::Array{<:Real, 1}; \n              method::F=gradDescent!) where {F<:Function} -> Array{<:ParamBox, 1}\n\nGiven a Vector of parameters::ParamBox and its gradients with respect to each  parameter, update the ParamBoxs and return the updated values.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"gradDescent!","category":"page"},{"location":"coreFunction/#Quiqbox.gradDescent!","page":"Core Functions","title":"Quiqbox.gradDescent!","text":"gradDescent!(pars::Vector{<:Real}, grads::Vector{<:Real}, η=0.001) -> \npars::Vector{<:Real}\n\nDefault gradient descent method in used in Quiqbox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"overlap","category":"page"},{"location":"coreFunction/#Quiqbox.overlap","page":"Core Functions","title":"Quiqbox.overlap","text":"overlap(fb1::AbstractFloatingGTBasisFunc, fb2::AbstractFloatingGTBasisFunc) -> \nArray{Float64, 2}\n\nReturn the orbital overlap matrix (an N×N Matrix where N is the number of spatial  orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"overlaps","category":"page"},{"location":"coreFunction/#Quiqbox.overlaps","page":"Core Functions","title":"Quiqbox.overlaps","text":"overlaps(BSet::Array{<:AbstractFloatingGTBasisFunc, 1}) -> Array{Float64, 2}\n\nReturn the orbital overlap matrix (an N×N Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nucAttraction","category":"page"},{"location":"coreFunction/#Quiqbox.nucAttraction","page":"Core Functions","title":"Quiqbox.nucAttraction","text":"nucAttraction(fb1::AbstractFloatingGTBasisFunc, fb2::AbstractFloatingGTBasisFunc, \n              nuc::Array{String, 1}, nucCoords::Array{<:AbstractArray, 1}) -> \nArray{Float64, 2}\n\nReturn the nuclear attraction matrix (an N×N Matrix where N is the number of spatial  orbitals) given 2 basis functions, and the nuclei with their coordinates (in atomic unit).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nucAttractions","category":"page"},{"location":"coreFunction/#Quiqbox.nucAttractions","page":"Core Functions","title":"Quiqbox.nucAttractions","text":"nucAttractions(BSet::Array{<:AbstractFloatingGTBasisFunc, 1}, nuc::Array{String, 1}, \n               nucCoords::Array{<:AbstractArray, 1}) -> \nArray{Float64, 2}\n\nReturn the nuclear attraction matrix (an N×N Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array, and the nuclei with their  coordinates (in atomic unit).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"elecKinetic","category":"page"},{"location":"coreFunction/#Quiqbox.elecKinetic","page":"Core Functions","title":"Quiqbox.elecKinetic","text":"elecKinetic(fb1::AbstractFloatingGTBasisFunc, fb2::AbstractFloatingGTBasisFunc) -> \nArray{Float64, 2}\n\nReturn the electron kinetic energy matrix (an N×N Matrix where N is the number of spatial  orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"elecKinetics","category":"page"},{"location":"coreFunction/#Quiqbox.elecKinetics","page":"Core Functions","title":"Quiqbox.elecKinetics","text":"elecKinetics(BSet::Array{<:AbstractFloatingGTBasisFunc, 1}) -> Array{Float64, 2}\n\nReturn the electron kinetic energy matrix (an N×N Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"coreHij","category":"page"},{"location":"coreFunction/#Quiqbox.coreHij","page":"Core Functions","title":"Quiqbox.coreHij","text":"coreHij(fb1::AbstractFloatingGTBasisFunc, fb2::AbstractFloatingGTBasisFunc) -> \nArray{Float64, 2}\n\nReturn a matrix element or block of the core Hamiltonian (an N×N Matrix where N is the  number of spatial orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"coreH","category":"page"},{"location":"coreFunction/#Quiqbox.coreH","page":"Core Functions","title":"Quiqbox.coreH","text":"coreH(BSet::Array{<:AbstractFloatingGTBasisFunc, 1}) -> Array{Float64, 2}\n\nReturn the core Hamiltonian matrix (an N×N Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"eeInteraction","category":"page"},{"location":"coreFunction/#Quiqbox.eeInteraction","page":"Core Functions","title":"Quiqbox.eeInteraction","text":"eeInteraction(bf1::AbstractFloatingGTBasisFunc, \n              bf2::AbstractFloatingGTBasisFunc, \n              bf3::AbstractFloatingGTBasisFunc, \n              bf4::AbstractFloatingGTBasisFunc) -> \nArray{Float64, 4}\n\nReturn the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number of  spatial orbitals) given 4 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"eeInteractions","category":"page"},{"location":"coreFunction/#Quiqbox.eeInteractions","page":"Core Functions","title":"Quiqbox.eeInteractions","text":"eeInteractions(BSet::Array{<:AbstractFloatingGTBasisFunc, 1}) -> Array{Float64, 4}\n\nReturn the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number  of spatial orbitals) given a basis set in the form of an Array. \n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Quiqbox.oneBodyBFTensor","category":"page"},{"location":"coreFunction/#Quiqbox.oneBodyBFTensor","page":"Core Functions","title":"Quiqbox.oneBodyBFTensor","text":"oneBodyBFTensor(libcinFunc::Symbol, b1::AbstractFloatingGTBasisFunc, \n                b2::AbstractFloatingGTBasisFunc, nuclei::Array{String, 1}=String[], \n                nucleiCoords::Array{<:AbstractArray, 1}=Array[]; \n                isGradient::Bool=false) -> \nArray{Float64, 2}\n\nCore function for one-electron integrals.\n\nlibcinFunc::Symbol specifies the backend libcint (https://github.com/sunqm/libcint)  function name, e.g. \"int1enuccart\" should be converted to :int1e_nuc_cartas the input  argument. If the integral does not need the information of nuclei and their coordinates,  those 2 arguments can be omitted. If the integral is a spacial gradient, isGradient  should be set to true.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Quiqbox.twoBodyBFTensor","category":"page"},{"location":"coreFunction/#Quiqbox.twoBodyBFTensor","page":"Core Functions","title":"Quiqbox.twoBodyBFTensor","text":"twoBodyBFTensor(libcinFunc::Symbol, \n                b1::AbstractFloatingGTBasisFunc, b2::AbstractFloatingGTBasisFunc, \n                b3::AbstractFloatingGTBasisFunc, b4::AbstractFloatingGTBasisFunc; \n                isGradient::Bool=false) -> \nArray{Float64, 5}\n\nCore function for one-electron integrals.\n\nlibcinFunc::Symbol specifies the backend libcint (https://github.com/sunqm/libcint)  function name, e.g. \"cint2ecart\" should be converted to `:cint2ecart`as the input  argument. \n\n\n\n\n\n","category":"function"},{"location":"list/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"Below are the types and functions included in the documentation.","category":"page"},{"location":"list/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"order = [:type]","category":"page"},{"location":"list/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"order = [:function]","category":"page"},{"location":"toolFunction/#Tool-Functions","page":"Tool Functions","title":"Tool Functions","text":"","category":"section"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Quiqbox.checkFname","category":"page"},{"location":"toolFunction/#Quiqbox.checkFname","page":"Tool Functions","title":"Quiqbox.checkFname","text":"checkFname(Fname::String; showWarning::Bool=true) -> String\n\nCheck if there is a file with the same name in the current directory. If so, will add an  \"_N\" at the end of the file name String. showWarning determines whether prints out  the WARNING info when there is a file with the same name.\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"hasEqual","category":"page"},{"location":"toolFunction/#Quiqbox.hasEqual","page":"Tool Functions","title":"Quiqbox.hasEqual","text":"hasEqual(obj1, obj2, obj3...; ignoreFunction=false, ignoreContainerType=false) -> Bool\n\nCompare if two objects are the equal. \n\nIf ignoreFunction = true then the function will pop up a warning message when a field is  a function.\n\nIf ignoreContainerType = true then the function will ignore the type difference of the  (outermost) container as long as the inside fields are equal. \n\nThis function is an instantiation of hasBoolRelation.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> begin\n           struct S\n               a::Int\n               b::Float64\n           end\n           a = S(1, 1.0)\n           b = S(1, 1.0)\n           c = S(1, 1.0)\n           d = S(1, 1.1)\n\n           @show hasEqual(a, b, c)\n           @show hasEqual(a, b, c, d)\n       end\nhasEqual(a, b, c) = true\nhasEqual(a, b, c, d) = false\nfalse\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"hasIdentical","category":"page"},{"location":"toolFunction/#Quiqbox.hasIdentical","page":"Tool Functions","title":"Quiqbox.hasIdentical","text":"hasIdentical(obj1, obj2, obj3...; \n             ignoreFunction=false, ignoreContainerType=false) -> Bool\n\nCompare if two objects are the Identical. An instantiation of hasBoolRelation.\n\nIf ignoreFunction = true then the function will pop up a warning message when a field is  a function.\n\nIf ignoreContainerType = true then the function will ignore the type difference of the  (outermost) container as long as the inside fields are identical.\n\nThis function is an instantiation of hasBoolRelation.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> begin\n           struct S\n               a::Int\n               b::Array{Float64, 1}\n           end\n            \n           a = S(1, [1.0, 1.1])\n           b = a\n           c = b\n           d = S(1, [1.0, 1.1])\n\n           @show hasIdentical(a, b, c)\n           @show hasIdentical(a, b, c, d)\n       end\nhasIdentical(a, b, c) = true\nhasIdentical(a, b, c, d) = false\nfalse\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"flatten","category":"page"},{"location":"toolFunction/#Quiqbox.flatten","page":"Tool Functions","title":"Quiqbox.flatten","text":"flatten(a::Tuple) -> Tuple\n\nflatten(a::Array) -> Array\n\nFlatten a::Union{Array, Tuple} that contains Arrays and/or Tuples. Only operate on  the outermost layer.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> flatten((:one, 2, [3, 4.0], ([5], \"six\"), \"7\"))\n(:one, 2, 3.0, 4.0, [5], \"six\", \"7\")\n\njulia> flatten([:one, 2, [3, 4.0], ([5], \"six\"), \"7\"])\n7-element Vector{Any}:\n  :one\n 2\n 3.0\n 4.0\n  [5]\n  \"six\"\n  \"7\"\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"markUnique","category":"page"},{"location":"toolFunction/#Quiqbox.markUnique","page":"Tool Functions","title":"Quiqbox.markUnique","text":"markUnique(arr::AbstractArray, args...; compareFunction::Function = hasEqual, kws...)\n\nReturn a markingList using Int number to mark each different elements from  (and inside) the input argument(s) and a uniqueList to contain all the unique  elements when compareFunction is set to hasEqual (in default).\n\nargs and kws are positional arguments and keywords arguments respectively as  parameters of the specified compareFunction.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> markUnique([1, [1, 2],\"s\", [1, 2]])\n([1, 2, 3, 2], Any[1, [1, 2], \"s\"])\n\njulia> begin \n           struct S\n               a::Int\n               b::Float64\n           end\n           \n           a = S(1, 2.0)\n           b = S(1, 2.0)\n           c = S(1, 2.1)\n           d = a\n           \n           markUnique(a,b,c,d)\n       end\n([1, 1, 2, 1], Any[S(1, 2.0), S(1, 2.1)])\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Quiqbox.itself","category":"page"},{"location":"toolFunction/#Quiqbox.itself","page":"Tool Functions","title":"Quiqbox.itself","text":"A function that only returns its argument.\n\n\n\n\n\n","category":"function"},{"location":"#Quiqbox.jl","page":"Home","title":"Quiqbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quiqbox is a quantum chemistry and quantum computing software package that starts off around Gaussian basis set optimization of molecular electronic-structure problems. Quiqbox is written in pure Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Floating and fixed-basis Gaussian-type orbital (GTO) configurations.\nSymbolic representation and analysis of basis function parameters.\nStandalone 1-electron and 2-electron integral functions (powered by libcint_jll).\nRestricted (closed-shell) and unrestricted (open-shell) Hartree–Fock methods (RHF & UHF).\nMolecular orbital data output in Molden file format.\nVariational optimization of orbital geometry based on automatic differentiation (AD).","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"#Supported-system-platforms-(64-bit)","page":"Home","title":"Supported system platforms (64-bit)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linux\nMac OS\nWindows Subsystem for Linux","category":"page"},{"location":"#Julia-Environment","page":"Home","title":"Julia Environment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"1.5+","category":"page"},{"location":"#Installation-in-Julia-[REPL](https://docs.julialang.org/en/v1/manual/getting-started/)","page":"Home","title":"Installation in Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type ] to enter the Pkg mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type add Quiqbox and hit Enter key to install Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg> add Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the installation completes, hit Backspace key to go back to Julia REPL and use using to load Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more basic usage of the programming language behind Quiqbox, Julia, please refer to the official documentation or one official tutorial.","category":"page"},{"location":"molden/#Molden","page":"Molden","title":"Molden","text":"","category":"section"},{"location":"molden/","page":"Molden","title":"Molden","text":"Quiqbox supports outputting molecular (in Molecule) information to Molden file format.","category":"page"},{"location":"molden/","page":"Molden","title":"Molden","text":"Quiqbox.Molden.makeMoldenFile","category":"page"},{"location":"molden/#Quiqbox.Molden.makeMoldenFile","page":"Molden","title":"Quiqbox.Molden.makeMoldenFile","text":"makeMoldenFile(mol::Molecule; recordUMO::Bool=false, fileName::String = \"MO\") -> String\n\nWrite the information of input Molecule into a Molden file. recordUMO determines  whether to include the unoccupied molecular orbitals. fileName specifies the name of the  file, which is also the returned value.\n\n\n\n\n\n","category":"function"},{"location":"molden/","page":"Molden","title":"Molden","text":"A concrete example of the above function can be found here.","category":"page"}]
}
