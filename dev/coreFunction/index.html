<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions · Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/master/docs/src/coreFunction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFunc" href="#Quiqbox.genBasisFunc"><code>Quiqbox.genBasisFunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFunc(args..., kws...) -&gt; BasisFunc
genBasisFunc(args..., kws...) -&gt; BasisFuncs
genBasisFunc(args..., kws...) -&gt; collection</code></pre><p>Constructor of <code>BasisFunc</code> and <code>BasisFuncs</code>, but it also returns different kinds of  collections of them based on the applied methods.</p><p>≡≡≡ Method 1 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gs::Array{&lt;:GaussFunc, 1}, 
             ijkOrijks::Union{Array{Int, 1}, Array{Array{Int, 1}, 1}}; 
             normalizeGTO::Bool=false)</code></pre><p><code>ijkOrijks</code> is the Array of the pseudo-quantum number(s) to specify the angular  momentum(s). E.g., s is [0,0,0] and p is [[1,0,0], [0,1,0], [0,0,1]].</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="nohighlight hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), [0,1,0])
BasisFunc{:P, 1}(gauss, subshell, center)[X⁰Y¹Z⁰][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 2 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gs::Array{&lt;:GaussFunc, 1}, subshell::String=&quot;S&quot;; 
             ijkFilter::Array{Bool, 1}=fill(true, SubshellDimList[subshell]), 
             normalizeGTO::Bool=false)</code></pre><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="nohighlight hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;S&quot;)
BasisFunc{:S, 1}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;P&quot;)
BasisFuncs{:P, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 3 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gExpsANDgCons::NTuple{2, Array{&lt;:Real, 1}}, 
             subshell=&quot;S&quot;; kw...)</code></pre><p>Instead of directly inputting <code>GaussFunc</code>, one can also input a 2-element <code>Tuple</code> of the  exponent(s) and contraction coefficient(s) corresponding to the same <code>GaussFunc</code>(s).</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="nohighlight hljs">julia&gt; genBasisFunc([0,0,0], (2, 1), &quot;P&quot;)
BasisFuncs{:P, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], ([2, 1.5], [1, 0.5]), &quot;P&quot;)
BasisFuncs{:P, 2, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 4 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(center, BSKeyANDnuc::Array{Tuple{String, String}, 1})</code></pre><p>If the user wants to construct existed atomic basis set(s), they can use the (<code>Array</code> of)  <code>(BS_name, Atom_name)</code> as the second input. If the atom is omitted, then basis set for H  is used.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="nohighlight hljs">julia&gt; genBasisFunc([0,0,0], (&quot;STO-3G&quot;, &quot;Li&quot;))
3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFuncs{:P, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], &quot;STO-3G&quot;)
1-element Vector{Quiqbox.FloatingGTBasisFuncs}:
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [&quot;STO-2G&quot;, &quot;STO-3G&quot;])
2-element Vector{Quiqbox.FloatingGTBasisFuncs}:
BasisFunc{:S, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [(&quot;STO-2G&quot;, &quot;He&quot;), (&quot;STO-3G&quot;, &quot;O&quot;)])
4-element Vector{Quiqbox.FloatingGTBasisFuncs}:
BasisFunc{:S, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFunc{:S, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
BasisFuncs{:P, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L179-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerOf" href="#Quiqbox.centerOf"><code>Quiqbox.centerOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centerOf(bf::FloatingGTBasisFuncs) -&gt; Array{&lt;:Real, 1}</code></pre><p>Return the center coordinate of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L426-L430">source</a></section></article><pre><code class="language- hljs">GTBasis(basis::Vector{&lt;:Quiqbox.AbstractGTBasisFuncs})</code></pre><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.decompose" href="#Quiqbox.decompose"><code>Quiqbox.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 2}</code></pre><p>Decompose a <code>FloatingGTBasisFuncs</code> into an <code>Array</code> of <code>BasisFunc</code>s. Each column represents  one orbital of the input basis function(s). If <code>splitGaussFunc</code> is <code>true</code>, then each column  consists of the <code>BasisFunc</code>s each with only 1 <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L715-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.basisSize" href="#Quiqbox.basisSize"><code>Quiqbox.basisSize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basisSize(subshell::Union{String, Array{String, 1}}) -&gt; Tuple</code></pre><p>Return the size (number of orbitals) of each subshell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L755-L760">source</a></section><section><div><pre><code class="nohighlight hljs">basisSize(basisFunctions) -&gt; Tuple</code></pre><p>Return the numbers of orbitals of the input basis function(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L764-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText" href="#Quiqbox.genBasisFuncText"><code>Quiqbox.genBasisFuncText</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bf::FloatingGTBasisFuncs; norm=1.0, printCenter=true) -&gt; String</code></pre><p>Generate a <code>String</code> of the text of the input <code>FloatingGTBasisFuncs</code>. <code>norm</code> is the  additional normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate  will be added on the first line of the <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L783-L790">source</a></section><section><div><pre><code class="nohighlight hljs">genBasisFuncText(bs::Array{&lt;:FloatingGTBasisFuncs, 1}; 
                 norm=1.0, printCenter=true, groupCenters::Bool=true) -&gt; 
String</code></pre><p>Generate a <code>String</code> of the text of the input basis set. <code>norm</code> is the additional  normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate will be added  on the first line of the <code>String</code>. <code>groupCenters</code> determines whether the function will  group the basis functions with same center together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L802-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBFuncsFromText" href="#Quiqbox.genBFuncsFromText"><code>Quiqbox.genBFuncsFromText</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBFuncsFromText(content::String; adjustContent::Bool=false, 
                  adjustFunction::F=sciNotReplace, 
                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, 
                  center::Union{AbstractArray, 
                                Tuple{N, ParamBox}, 
                                Missing}=missing) where {N, F&lt;:Function} -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 1}</code></pre><p>Generate the basis set from a <code>String</code> of basis set in Gaussian format or the String output  from <code>genBasisFuncText</code>. For the former, <code>adjustContent</code> needs to be set to <code>true</code>.  <code>adjustFunction</code> is only applied when <code>adjustContent=true</code>, which in default is a  <code>function</code> used to detect and convert the format of the scientific notation in the String.</p><p><code>excludeFirstNlines</code> and <code>excludeLastNlines</code> are used to exclude first or last few lines of  the <code>String</code> if intent. <code>genBFuncsFromText</code> can&#39;t directly read center coordinate  information from the String even if it&#39;s included, so argument <code>center</code> is used to assign a  coordinate for all the basis functions from the String; it can be a <code>Vector</code>, a <code>Tuple</code> of  the positional <code>ParamBox</code>s, or simply (in default) set to <code>missing</code> for later assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L833-L853">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.assignCenter!" href="#Quiqbox.assignCenter!"><code>Quiqbox.assignCenter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assignCenter!(center::AbstractArray, b::FloatingGTBasisFuncs) -&gt; NTuple{3, ParamBox}</code></pre><p>Assign a new coordinate to the center of the input <code>FloatingGTBasisFuncs</code>.  Also return the altered center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L888-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getParams" href="#Quiqbox.getParams"><code>Quiqbox.getParams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParams(pbc::Union{ParamBox, GaussFunc, FloatingGTBasisFuncs}, 
          symbol::Union{Symbol, Nothing}=nothing; onlyDifferentiable::Bool=false) -&gt; 
Union{ParamBox, Array{&lt;:ParamBox, 1}}</code></pre><p>Return the parameter(s)<code>::ParamBox</code> stored in the input container. If keyword argument  <code>symbol</code> is <code>nothing</code>, then return all the different parameters; if it&#39;s set to the  <code>Symbol</code> type of a parameter (e.g. the symbol of <code>ParamBox{T}</code> would be <code>T</code>), the function  will only search for that type of parameters (which might have different indices).  <code>onlyDifferentiable</code> determines whether ignore non-differentiable parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L918-L929">source</a></section><section><div><pre><code class="nohighlight hljs">getParams(cs::Array, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}</code></pre><p>Method of <code>getParams</code> when the 1st argument is an <code>Array</code> of <code>ParamBox</code>, <code>GaussFunc</code>,  <code>FloatingGTBasisFuncs</code> or any of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L966-L974">source</a></section></article><pre><code class="language- hljs">dataCopy</code></pre><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.uniqueParams!" href="#Quiqbox.uniqueParams!"><code>Quiqbox.uniqueParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniqueParams!(bs; ignoreContainer::Bool=false, filter::Bool=true, 
              filterMapping::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}</code></pre><p>Mark the parameters (<code>ParamBox</code>) in input bs which can a <code>Vector</code> of <code>GaussFunc</code> or  <code>FloatingGTBasisFuncs</code>. The identical parameters will be marked with same index.</p><p>=== Keyword argument(s) ===</p><p><code>ignoreContainer</code>: If set to <code>true</code>, then only the field <code>data</code> of the <code>ParamBox</code>s will be  compared to determine whether each <code>ParamBox</code> are unique. </p><p><code>filter</code>: Determine whether filter out the identical <code>ParamBox</code>s and only return the unique  ones.</p><p><code>filterMapping</code>: Determine wether return the <code>ParamBox</code>s with identical fields except the  <code>map</code> field. When <code>filter=false</code>, this argument is automatically overwritten to be <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L1058-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVar" href="#Quiqbox.getVar"><code>Quiqbox.getVar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVar(pb::ParamBox; includeMapping::Bool=false) -&gt; 
Array{&lt;:Pair{Symbolics.Num, &lt;:Number}, 1}</code></pre><p>Return a 1-element <code>Vector</code> of <code>Pair</code> to show the <code>Symbol::Symbolics.Num</code> of the stored  variable and the corresponding values. <code>includeMapping</code> determines whether mappings from  the variable to the dependent variable if there is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L1083-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVars" href="#Quiqbox.getVars"><code>Quiqbox.getVars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVars(obj::Union{GaussFunc, BasisFunc}; includeMapping::Bool=false) -&gt; 
Array{&lt;:Pair, 1}

getVars(collection::Array{&lt;:Union{GaussFunc, BasisFunc, ParamBox}, 1}; 
        includeMapping::Bool=false) -&gt; 
Array{&lt;:Pair, 1}</code></pre><p>Return a <code>Vector</code> of <code>Pair</code> to of the mapping relations between the variables stored in the  <code>ParamBox</code>s and the corresponding values. <code>includeMapping</code> determines whether mappings from  the variable(s) to the dependent variable(s) if exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L1110-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.expressionOf" href="#Quiqbox.expressionOf"><code>Quiqbox.expressionOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expressionOf(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; Array{&lt;:Symbolics.Num, 2}</code></pre><p>Return the expression(s) of a given <code>CompositeGTBasisFuncs</code> (e.g. <code>BasisFuncMix</code> or  <code>FloatingGTBasisFuncs</code>) as a <code>Matrix{&lt;:Symbolics.Num}</code>of which the column(s) corresponds to  different orbitals. If <code>splitGaussFunc</code> is <code>true</code>, the column(s) will be expanded such that its  entries are <code>GaussFunc</code> inside the corresponding orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L1224-L1232">source</a></section><section><div><pre><code class="nohighlight hljs">expressionOf(gf::GaussFunc) -&gt; Symbolics.Num</code></pre><p>Return the expression of a given <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L1236-L1241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GridBox" href="#Quiqbox.GridBox"><code>Quiqbox.GridBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridBox(nGridPerEdge::Int, spacing::Real=10, 
        centerCoord::Array{&lt;:Real, 1}=[0.0,0.0,0.0]; 
        canDiff::Bool=true, index::Int=0) -&gt; GridBox</code></pre><p>Method of generating a cubic <code>GridBox</code>. <code>nGridPerEdge</code> specifies the number of grids  (number of grid points - 1) along each dimension.<code>spacing</code> specifies the length between  adjacent grid points. <code>centerCoord</code> specifies the geometry center coordinate of the box.  <code>canDiff</code> determines whether the <code>ParamBox</code> should be marked as differentiable. <code>index</code>  defines the index number for the actual parameter: spacing <code>L</code>, with the default value 0  it would be <code>L₀</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Box.jl#L71-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.makeCenter" href="#Quiqbox.makeCenter"><code>Quiqbox.makeCenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeCenter(coord::Array{&lt;:Real, 1}) -&gt; NTuple{3, ParamBox}</code></pre><p>Generate a <code>Tuple</code> of coordinate <code>ParamBox</code>s for a basis function center coordinate  given a <code>Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Basis.jl#L903-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gridCoords-Tuple{GridBox}" href="#Quiqbox.gridCoords-Tuple{GridBox}"><code>Quiqbox.gridCoords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridCoords(gb::GridBox) -&gt; Array{Array{Float64, 1}, 1}</code></pre><p>Return the grid-point coordinates in <code>Vector</code>s given the <code>GriBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Box.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHF" href="#Quiqbox.runHF"><code>Quiqbox.runHF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHF(bs::Union{BasisSetData, Array{&lt;:AbstractGTBasisFuncs, 1}}, 
      nuc::Array{String, 1}, 
      nucCoords::Array{&lt;:AbstractArray, 1}, 
      N::Union{NTuple{2, Int}, Int}=getCharge(nuc); 
      initialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=:GWH, 
      HFtype::Symbol=:RHF, 
      scfConfig::SCFconfig=defaultSCFconfig, 
      earlyTermination::Bool=true, 
      printInfo::Bool=true, 
      maxSteps::Int=1000) where {Float64&lt;:T&lt;:Float64} -&gt; HFfinalVars</code></pre><p>Main function to run Hartree-Fock in Quiqbox.</p><p>=== Positional argument(s) ===</p><p><code>bs::Union{BasisSetData, Array{&lt;:AbstractGTBasisFuncs, 1}}</code>: Basis set.</p><p><code>nuc::Array{String, 1}</code>: The element symbols of the nuclei for the Molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: The coordinates of the nuclei.</p><p><code>N::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p>=== Keyword argument(s) ===</p><p><code>initialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}</code>: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>scfConfig::SCFconfig</code>: SCF iteration configuration.</p><p><code>earlyTermination::Bool</code>: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the SCF converges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/HartreeFock.jl#L377-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHFcore" href="#Quiqbox.runHFcore"><code>Quiqbox.runHFcore</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHFcore(N::Union{NTuple{2, Int}, Int}, 
          Hcore::Array{T1, 2}, 
          HeeI::Array{T2, 4}, 
          S::Array{T3, 2}, 
          X::Array{T4, 2}=getX(S), 
          C::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=guessC(S, Hcore; X);
          HFtype::Symbol=:RHF,  
          scfConfig::SCFconfig{L}, 
          earlyTermination::Bool=true, 
          printInfo::Bool=true, 
          maxSteps::Int=1000) where {Float64&lt;:T1&lt;:Float64, 
          Float64&lt;:T2&lt;:Float64, 
          Float64&lt;:T3&lt;:Float64, 
          Float64&lt;:T4&lt;:Float64, 
          Float64&lt;:T5&lt;:Float64, L}</code></pre><p>The core function of <code>runHF</code>.</p><p>=== Positional argument(s) ===</p><p><code>N::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p><code>Hcore::Array{T1, 2}</code>: Core Hamiltonian of electronic Hamiltonian.</p><p><code>HeeI::Array{T2, 4}</code>: The electron-electron interaction Hamiltonian which includes both the  Coulomb interactions and the Exchange Correlations.</p><p><code>S::Array{T3, 2}</code>: Overlap matrix of the corresponding basis set.</p><p><code>X::Array{T4, 2}</code>: Orthogonal transformation matrix of S. Default value is S^(-0.5).</p><p><code>C::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}</code>: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.</p><p>=== Keyword argument(s) ===</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>scfConfig::SCFconfig</code>: SCF iteration configuration.</p><p><code>earlyTermination::Bool</code>: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the SCF converges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/HartreeFock.jl#L455-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.Molecule-Tuple{Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Quiqbox.FloatingGTBasisFuncs, Vector{String}, Vector{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:AbstractArray, Quiqbox.HFfinalVars}" href="#Quiqbox.Molecule-Tuple{Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Quiqbox.FloatingGTBasisFuncs, Vector{String}, Vector{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:AbstractArray, Quiqbox.HFfinalVars}"><code>Quiqbox.Molecule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Molecule(basis::Array{&lt;:FloatingGTBasisFuncs, 1}, nuc::Array{String, 1}, 
         nucCoords::Array{&lt;:AbstractArray, 1}, HFfVars::HFfinalVars) -&gt; Molecule</code></pre><p>Construct a <code>Molecule</code> from a basis set, nuclei information, and the result from the  corresponding Hartree-Fock SCF procedure, specifically a <code>HFfinalVars</code> <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Molecule.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getMolOrbitals" href="#Quiqbox.getMolOrbitals"><code>Quiqbox.getMolOrbitals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMolOrbitals(ens::Array{Float64, 1}, occus::Array{&lt;:Real, 1}, C::Matrix{Float64}, 
               spins::Array{String, 1}, 
               symms::Array{String, 1}=repeat([&quot;A&quot;], length(occus))) -&gt; 
Tuple{Vararg{getMolOrbitals}}</code></pre><p>A function that returns the molecular orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Molecule.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nnRepulsions" href="#Quiqbox.nnRepulsions"><code>Quiqbox.nnRepulsions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nnRepulsions(nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; Float64</code></pre><p>Calculate the nuclear-nuclear repulsion energy given the nuclei and their coordinates of a  molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Molecule.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.optimizeParams!" href="#Quiqbox.optimizeParams!"><code>Quiqbox.optimizeParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimizeParams!(bs::Array{&lt;:FloatingGTBasisFuncs, 1}, pbs::Array{&lt;:ParamBox, 1},
                nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}, 
                Ne::Union{NTuple{2, Int}, Int}=getCharge(nuc);
                Etarget::Float64=NaN, threshold::Float64=1e-4, maxSteps::Int=2000, 
                printInfo::Bool=true, GDmethod::F1=gradDescent!, HFtype::Symbol=:RHF, 
                ECmethod::F2=Quiqbox.defaultECmethod) where 
               {F1&lt;:Function, F2&lt;:Function} -&gt; 
Es::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}</code></pre><p>The main function to optimize the parameters of a given basis set.</p><p>=== Positional argument(s) ===</p><p><code>bs::Array{&lt;:FloatingGTBasisFuncs, 1}</code>: Basis set.</p><p><code>pbs::Array{&lt;:ParamBox, 1}</code>: The parameters to be optimized that are extracted from the  basis set.</p><p><code>nuc::Array{String, 1}</code>: The nuclei of the molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: The nuclei coordinates.</p><p><code>Ne::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p>=== Keyword argument(s) ===</p><p><code>Etarget::Float64</code>: The target Hartree-Hock energy intent to achieve.</p><p><code>threshold::Float64</code>: The threshold for the convergence when evaluating difference between  the latest two energies.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the optimization  iteration converges.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>GDmethod::F1</code>: Applied gradient descent <code>Function</code>.</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>ECmethod::F2</code>: The <code>Function</code> used to update Hartree-Fock energy and coefficient matrix(s)  during the optimization iterations. === Keyword argument(s) ===</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Optimization.jl#L53-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.updateParams!" href="#Quiqbox.updateParams!"><code>Quiqbox.updateParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateParams!(pbs::Array{&lt;:ParamBox, 1}, grads::Array{&lt;:Real, 1}; 
              method::F=gradDescent!) where {F&lt;:Function} -&gt; Array{&lt;:ParamBox, 1}</code></pre><p>Given a <code>Vector</code> of parameters::<code>ParamBox</code> and its gradients with respect to each  parameter, update the <code>ParamBox</code>s and return the updated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Optimization.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradDescent!" href="#Quiqbox.gradDescent!"><code>Quiqbox.gradDescent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradDescent!(pars::Vector{&lt;:Real}, grads::Vector{&lt;:Real}, η=0.001) -&gt; 
pars::Vector{&lt;:Real}</code></pre><p>Default gradient descent method in used in Quiqbox.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Optimization.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlap" href="#Quiqbox.overlap"><code>Quiqbox.overlap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlap(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlaps" href="#Quiqbox.overlaps"><code>Quiqbox.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlaps(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttraction" href="#Quiqbox.nucAttraction"><code>Quiqbox.nucAttraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttraction(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, 
              nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions, and the nuclei with their coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttractions" href="#Quiqbox.nucAttractions"><code>Quiqbox.nucAttractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, 
               nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>, and the nuclei with their  coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L134-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetic" href="#Quiqbox.elecKinetic"><code>Quiqbox.elecKinetic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetic(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetics" href="#Quiqbox.elecKinetics"><code>Quiqbox.elecKinetics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetics(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreHij" href="#Quiqbox.coreHij"><code>Quiqbox.coreHij</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreHij(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return a matrix element or block of the core Hamiltonian (an N×N <code>Matrix</code> where N is the  number of spatial orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreH" href="#Quiqbox.coreH"><code>Quiqbox.coreH</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreH(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the core Hamiltonian matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteraction" href="#Quiqbox.eeInteraction"><code>Quiqbox.eeInteraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteraction(bf1::AbstractGTBasisFuncs, 
              bf2::AbstractGTBasisFuncs, 
              bf3::AbstractGTBasisFuncs, 
              bf4::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number of  spatial orbitals) given 4 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/TwoBody.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractions" href="#Quiqbox.eeInteractions"><code>Quiqbox.eeInteractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number  of spatial orbitals) given a basis set in the form of an <code>Array</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/TwoBody.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractionsCore-Tuple{Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Quiqbox.AbstractGTBasisFuncs}" href="#Quiqbox.eeInteractionsCore-Tuple{Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Quiqbox.AbstractGTBasisFuncs}"><code>Quiqbox.eeInteractionsCore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeInteractionsCore(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}; 
                   outputUniqueIndices::Bool=false) -&gt; 
Array{Float64, 5}, [Array{&lt;:Array{Int, 1}, 1}]</code></pre><p>Return the electron-electron interaction tensor (an N×N×N×N×1 Tensor where N is the number  of spatial orbitals) given a basis set in the form of an <code>Array</code>.</p><p>If <code>outputUniqueIndices=true</code>, additionally return the indices for all the unique integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/TwoBody.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.oneBodyBFTensor" href="#Quiqbox.oneBodyBFTensor"><code>Quiqbox.oneBodyBFTensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oneBodyBFTensor(libcinFunc::Symbol, b1::AbstractGTBasisFuncs, 
                b2::AbstractGTBasisFuncs, nuclei::Array{String, 1}=String[], 
                nucleiCoords::Array{&lt;:AbstractArray, 1}=Array[]; 
                isGradient::Bool=false) -&gt; 
Array{Float64, 2}</code></pre><p>Core function for one-electron integrals.</p><p><code>libcinFunc::Symbol</code> specifies the backend <a href="https://github.com/sunqm/libcint">libcint</a>  function name, e.g. <code>&quot;int1e_nuc_cart&quot;</code> should be converted to <code>:int1e_nuc_cart</code> as the  input argument. If the integral does not need the information of nuclei and their  coordinates, those 2 arguments can be omitted. If the integral is a spacial gradient,  <code>isGradient</code> should be set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/OneBody.jl#L31-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.twoBodyBFTensor" href="#Quiqbox.twoBodyBFTensor"><code>Quiqbox.twoBodyBFTensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">twoBodyBFTensor(libcinFunc::Symbol, 
                b1::AbstractGTBasisFuncs, b2::AbstractGTBasisFuncs, 
                b3::AbstractGTBasisFuncs, b4::AbstractGTBasisFuncs; 
                isGradient::Bool=false) -&gt; 
Array{Float64, 5}</code></pre><p>Core function for one-electron integrals.</p><p><code>libcinFunc::Symbol</code> specifies the backend <a href="https://github.com/sunqm/libcint">libcint</a>  function name, e.g. <code>&quot;cint2e_cart&quot;</code> should be converted to <code>:cint2e_cart</code> as the input  argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/e57950c67c89f940626f04b0e39a6e1dc36d25b0/src/Integration/TwoBody.jl#L24-L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">« Parameter Optimization</a><a class="docs-footer-nextpage" href="../coreType/">Core Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Wednesday 6 October 2021 19:44">Wednesday 6 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
