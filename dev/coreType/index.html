<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Types ¬∑ Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../coreFunction/">Core Functions</a></li><li class="is-active"><a class="tocitem" href>Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/main/docs/src/coreType.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.ParamBox" href="#Quiqbox.ParamBox"><code>Quiqbox.ParamBox</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamBox{T, V, FL&lt;:FLevel} &lt;: DifferentiableParameter{T, ParamBox}</code></pre><p>Parameter container that can enable differentiation.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>data::Array{T, 0}</code>: The container of the data (i.e. the value of the input variable)  stored in the <code>ParamBox</code> that can be accessed by syntax <code>[]</code>.</p><p><code>dataName::Symbol</code>: The name of the input variable.</p><p><code>map::Function</code>: The mapping of the data within the same domain (<code>.map(::T)-&gt;T</code>). The  result (i.e., the value of the output variable) can be accessed by syntax <code>()</code>.</p><p><code>canDiff::Array{Bool, 0}</code>: Indicator of whether the output variable is &quot;marked&quot; as  differentiable with respect to the input variable in the differentiation process. In other  words, it determines whether the output variable represented by the <code>ParamBox</code> is treated  as a dependent variable or an independent variable.</p><p><code>index::Array{&lt;:Union{Int, Nothing}, 0}</code>: Additional index assigned to the <code>ParamBox</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">ParamBox(data, dataName=:undef; index=nothing) -&gt; ParamBox{&lt;:Any, dataName, FLevel{0}}

ParamBox(data, name, mapFunction, dataName=:undef; index=nothing, canDiff=true) -&gt;
ParamBox{&lt;:Any, name}</code></pre><p>=== Positional argument(s) ===</p><p><code>data::Union{Array{T, 0}, T}</code>: The input value to be stored or the container of it. If the  latter is the first argument, then it will directly be assigned to <code>.data</code>.</p><p><code>name::Symbol</code>: Specify the name of the output variable represented by the constructed  <code>ParamBox</code>. It&#39;s not required when <code>mapFunction</code> is not provided because then the output  variable is considered the same as the input variable. It&#39;s equal to the type parameter <code>V</code>  of the constructed <code>ParamBox</code>.</p><p><code>mapFunction::Function</code>: The mapping of the stored data (<code>mapFunction(::T)-&gt;T</code>), which will  be assigned to the field <code>.map</code>. After constructing a <code>ParamBox</code>, e.g  <code>pb = ParamBox(x, yName, f)</code>, <code>pb[]</code> returns the value of <code>x</code>, and <code>pb()</code> returns the value  of <code>f(x)::T</code>. When <code>mapFunction</code> is not provided, <code>.map</code> is set to <a href="../toolFunction/#Quiqbox.itself-Tuple{Any}"><code>itself</code></a> that  maps the stored data to itself.</p><p><code>dataName::Symbol</code>: The name of the stored data, i.e, the name of the input variable.</p><p>=== Keyword argument(s) ===</p><p><code>index::Union{Int, Nothing}</code>: The index of the constructed <code>ParamBox</code>. It&#39;s should be left  with its default value unless the user plans to utilize the index of a <code>ParamBox</code> for  specific application other than differentiation.</p><p><code>canDiff::Bool</code>: Determine whether the output variable is marked as &quot;differentiable&quot;.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; ParamBox(1.0)
ParamBox{Float64, :undef, FLevel{0}}(1.0)[‚àÇ][undef]

julia&gt; ParamBox(1.0, :a)
ParamBox{Float64, :a, FLevel{0}}(1.0)[‚àÇ][a]

julia&gt; ParamBox(1.0, :a, abs)
ParamBox{Float64, :a, FLevel{1}}(1.0)[‚àÇ][x_a]</code></pre><p><strong>NOTE 1:</strong> The rightmost &quot;<code>[‚àÇ][IV]</code>&quot; in the printed info indicates the differentiability  and the name (with an assigned index) of the independent variable held by the <code>ParamBox</code>.  When the <code>ParamBox</code> is marked as a &quot;differentiable parameter&quot;, &quot;<code>[‚àÇ]</code>&quot; is bold and green  instead of just being grey, and <code>IV</code> is the name of the input variable.</p><p><strong>NOTE 2:</strong> The output variable of a <code>ParamBox</code> is normally used to differentiate a  parameter functional (e.g., the Hartree-Fock energy). However, the derivative with respect  to the corresponding input variable can also be computed to when the <code>ParamBox</code> is marked  as differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Parameters.jl#L27-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFunc" href="#Quiqbox.BasisFunc"><code>Quiqbox.BasisFunc</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFunc{T, D, ùëô, GN, PT} &lt;: FloatingGTBasisFuncs{T, D, ùëô, GN, PT, 1}</code></pre><p>A (floating) Gaussian-type basis function with its center assigned to a defined coordinate.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>center::SpatialPoint{T, D, PT}</code>: The <code>D</code>-dimensional center.</p><p><code>gauss::NTuple{N, GaussFunc{T, &lt;:Any}}</code>: Gaussian functions within the basis function.</p><p><code>l::Tuple{LTuple{D, ùëô}}</code>: Cartesian representation of the angular momentum. E.g.,  <code>LTuple{3, 1}((1, 0, 0))</code> (X¬πY‚Å∞Z‚Å∞) would correspond to an specific angular momentum  configuration where the sum of all the components is <code>ùëô=1</code>.</p><p><code>normalizeGTO::Bool</code>: Whether each <code>GaussFunc</code> inside will be normalized in calculations.</p><p><code>param::NTuple{D+GN*2, ParamBox}</code>Ôºö All the tunable parameters stored in the basis function.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">BasisFunc(cen::SpatialPoint{T, D, PT}, gs::NTuple{GN, AbstractGaussFunc{T}}, 
          l::Union{Tuple{LTuple{D, ùëô}}, LTuple{D, ùëô}}, normalizeGTO::Bool) where 
         {T, D, PT, ùëô, GN} -&gt; 
BasisFunc{T, D, ùëô, GN, PT}

BasisFunc(cen::SpatialPoint{T, D, PT}, gs::AbstractGaussFunc{T}, 
          l::Union{Tuple{LTuple{D, ùëô}}, LTuple{D, ùëô}}, normalizeGTO::Bool) where 
         {T, D, PT, ùëô, GN} -&gt; 
BasisFunc{T, D, ùëô, 1, PT}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L277-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFuncMix" href="#Quiqbox.BasisFuncMix"><code>Quiqbox.BasisFuncMix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFuncMix{T, D, BN, BFT&lt;:BasisFunc{T, D}} &lt;: CompositeGTBasisFuncs{T, D, BN, 1}</code></pre><p>Sum of multiple <code>FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, 1}</code> without any  reformulation, treated as one basis function in the calculations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>BasisFunc::NTuple{BN, BFT}</code>: Basis functions used to sum up.</p><p><code>param::Tuple{Vararg{ParamBox}}</code>: Contained parameters.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">BasisFuncMix(bfs::Union{Tuple{Vararg{T}}, AbstractArray{T}}) where 
            {T&lt;:FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, 1}} -&gt; 
BasisFuncMix</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L738-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFuncs" href="#Quiqbox.BasisFuncs"><code>Quiqbox.BasisFuncs</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFuncs{T, D, ùëô, GN, PT, ON} &lt;: FloatingGTBasisFuncs{T, D, ùëô, GN, PT, ON}</code></pre><p>A collection of basis functions with identical parameters except having different  orientations within a specified subshell (i.e. same total orbital angular momentum). It has  the same fields as <code>BasisFunc</code>. Specifically, for <code>l</code>, its size <code>ON</code> can be no less than 1  and no larger than the size of the corresponding subshell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L333-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GTBasis" href="#Quiqbox.GTBasis"><code>Quiqbox.GTBasis</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GTBasis{T, D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}} &lt;: BasisSetData{T, D, BFT}</code></pre><p>The container of basis set information.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>basis::NTuple{BN, BFT}</code>: Stored basis set.</p><p><code>S::Matrix{T}</code>: Overlap matrix.</p><p><code>Te::Matrix{T}</code>: Kinetic energy part of the electronic core Hamiltonian.</p><p><code>eeI::Array{T, 4}</code>: Electron-electron interaction.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GTBasis(basis::Union{Tuple{Vararg{GTBasisFuncs{T, D}}}, 
                     AbstractVector{&lt;:GTBasisFuncs{T, D}}}) where {T, D} -&gt; 
GTBasis{T, D}</code></pre><p>Construct a <code>GTBasis</code> given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L802-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GaussFunc" href="#Quiqbox.GaussFunc"><code>Quiqbox.GaussFunc</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussFunc{T, FL1, FL2} &lt;: AbstractGaussFunc{T}</code></pre><p>A contracted primitive Gaussian-type function.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>xpn::ParamBox{T, :Œ±, FL1}</code>ÔºöThe exponent coefficient.</p><p><code>con::ParamBox{T, :d, FL2}</code>: The contraction coefficient.</p><p><code>param::Tuple{ParamBox{T, Œ±}, ParamBox{T, d}}</code>: The parameter containers  inside a <code>GaussFunc</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GaussFunc(e::Union{T, ParamBox{T}}, d::Union{T, ParamBox{T}}) where 
         {T&lt;:AbstractFloat} -&gt; 
GaussFunc{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L13-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.SpatialPoint" href="#Quiqbox.SpatialPoint"><code>Quiqbox.SpatialPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpatialPoint{T, D, PT} &lt;: AbstractSpatialPoint{T, D}</code></pre><p>A <code>D</code>-dimensional spatial point.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>param::PT</code>: A <code>Tuple</code> of <a href="#Quiqbox.ParamBox"><code>ParamBox</code></a>s as the components of the spatial coordinate.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">SpatialPoint(pbs::Union{Tuple{ParamBox{T, :X, FLevel{Lx}}} where Lx, Tuple{ParamBox{T, :X, FLevel{Lx}}, ParamBox{T, :Y, FLevel{Ly}}} where {Lx, Ly}, Tuple{ParamBox{T, :X, FLevel{Lx}}, ParamBox{T, :Y, FLevel{Ly}}, ParamBox{T, :Z, FLevel{Lz}}} where {Lx, Ly, Lz}} where T) -&gt; SpatialPoint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Basis.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFconfig" href="#Quiqbox.HFconfig"><code>Quiqbox.HFconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFconfig{T1, HFT, F, T2, L} &lt;: ConfigBox{T1, HFconfig, HFT}</code></pre><p>The container of Hartree-Fock method configuration.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>HF::Val{HFT}</code>: Hartree-Fock method type. Available values of <code>HFT</code> are  :RHF, :UHF.</p><p><code>C0::InitialC{T1, HFT, F}</code>: Initial guess of the coefficient matrix(s) C of the canonical  orbitals. When <code>C0</code> is a <code>Val{T}</code>, the available values of <code>T</code> are  <code>:GWH, :Hcore, :SAD</code>.</p><p><code>SCF::SCFconfig{T2, L}</code>: SCF iteration configuration. For more information please refer to  <a href="#Quiqbox.SCFconfig"><code>SCFconfig</code></a>.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>earlyStop::Bool</code>: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">HFconfig(;HF::Symbol=:RHF, 
          C0::Union{Tuple{AbstractMatrix}, 
                    NTuple{2, AbstractMatrix}, Symbol}=:SAD, 
          SCF::SCFconfig=SCFconfig{Float64, 2}(method=(:ADIIS, :DIIS), interval=(0.005, 1.0e-12), methodConfig, oscillateThreshold), 
          maxStep::Int=100, 
          earlyStop::Bool=true) -&gt; 
HFconfig</code></pre><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; HFconfig();

julia&gt; HFconfig(HF=:UHF);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/HartreeFock.jl#L497-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFfinalVars" href="#Quiqbox.HFfinalVars"><code>Quiqbox.HFfinalVars</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFfinalVars{T, D, HFT, NN, BN, HFTS} &lt;: HartreeFockFinalValue{T, HFT}</code></pre><p>The container of the final values after a Hartree-Fock SCF procedure.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>Ehf::T</code>: Hartree-Fock energy of the electronic Hamiltonian.</p><p><code>Enn::T</code>: The nuclear repulsion energy.</p><p><code>Ns::NTuple{2, Int}</code>: The numbers of two different spins respectively.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoords::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>C::NTuple{HFTS, Matrix{T}}</code>: Coefficient matrix(s) for one spin configuration.</p><p><code>D::NTuple{HFTS, Matrix{T}}</code>: Density matrix(s) for one spin configuration.</p><p><code>F::NTuple{HFTS, Matrix{T}}</code>: Fock matrix(s) for one spin configuration.</p><p><code>Eo::NTuple{HFTS, Vector{T}}</code>: Energies of canonical orbitals.</p><p><code>occu::NTuple{HFTS, NTuple{BN, String}}</code>: Occupations of canonical orbitals.</p><p><code>temp::NTuple{HFTS, HFtempVars{T, HFT}}</code>: the intermediate values.</p><p><code>isConverged::Bool</code>: Whether the SCF procedure is converged in the end.</p><p><code>basis::GTBasis{T, D, BN}</code>: The basis set used for the Hartree-Fock approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/HartreeFock.jl#L416-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFtempVars" href="#Quiqbox.HFtempVars"><code>Quiqbox.HFtempVars</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFtempVars{T, HFT} &lt;: HartreeFockintermediateData{T}</code></pre><p>The container to store the intermediate values (only of the one spin configuration) for  each iteration during the Hartree-Fock SCF procedure. </p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>N::Int</code>: The number of electrons with the one spin function.</p><p><code>Cs::Vector{Matrix{T}}</code>: Coefficient matrices.</p><p><code>Ds::Vector{Matrix{T}}</code>: Density matrices corresponding to only spin configuration.</p><p><code>Fs::Vector{Matrix{T}}</code>: Fock matrices.</p><p><code>Es::Vector{T}</code>: Part of the Hartree-Fock energy corresponding to one spin configuration.</p><p><code>shared.Dtots::Vector{Matrix{T}}</code>: The total density matrices.</p><p><code>shared.Etots::Vector{T}</code>: The total Hartree-Fock energy.</p><p><strong>NOTE: For unrestricted Hartree-Fock, there are 2 <code>HFtempVars</code> being updated during the  iterations, and changing the field <code>shared.Dtots</code> or <code>shared.Etots</code> of one <code>HFtempVars</code>  will affect the other one&#39;s.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/HartreeFock.jl#L361-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.SCFconfig" href="#Quiqbox.SCFconfig"><code>Quiqbox.SCFconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SCFconfig{T, L} &lt;: ImmutableParameter{T, SCFconfig}</code></pre><p>The <code>struct</code> for self-consistent field (SCF) iteration configurations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>method::NTuple{L, Symbol}</code>: The applied convergence methods. The available methods and  their configurations (in terms of keyword arguments):</p><table><tr><th style="text-align: left">Convergence Method(s)</th><th style="text-align: center">Configuration(s)</th><th style="text-align: center">Keyword(s)</th><th style="text-align: center">Range(s)/Option(s)</th><th style="text-align: right">Default(s)</th></tr><tr><td style="text-align: left"><code>:DD</code></td><td style="text-align: center">damping strength</td><td style="text-align: center"><code>dampStrength</code></td><td style="text-align: center">[<code>0</code>, <code>1</code>]</td><td style="text-align: right"><code>0.5</code></td></tr><tr><td style="text-align: left"><code>:DIIS</code>, <code>:EDIIS</code>, <code>:ADIIS</code></td><td style="text-align: center">subspace size; coefficient solver</td><td style="text-align: center"><code>DIISsize</code>; <code>solver</code></td><td style="text-align: center"><code>1</code>,<code>2</code>...; <code>:LCM</code>, <code>:LBFGS</code></td><td style="text-align: right"><code>12</code>; <code>:LBFGS</code></td></tr></table><p><strong>Convergence Methods</strong></p><ul><li>DD: Direct diagonalization of the Fock matrix.</li><li>DIIS: <a href="https://onlinelibrary.wiley.com/doi/10.1002/jcc.540030413">Direct inversion in the iterative subspace</a>.</li><li>EDIIS: <a href="https://aip.scitation.org/doi/abs/10.1063/1.1470195">Energy-DIIS</a>.</li><li>ADIIS: <a href="https://aip.scitation.org/doi/10.1063/1.3304922">DIIS based on the augmented Roothaan‚ÄìHall (ARH) energy function</a>.</li></ul><p><strong>DIIS-type Method Solvers</strong></p><ul><li>LCM: Lagrange multiplier solver.</li><li>LBFGS: <a href="https://github.com/JuliaNLSolvers/Optim.jl">Limited-memory BFGS with box constraints</a>.</li></ul><p><code>interval::NTuple{L, T}</code>: The stopping (or skipping) thresholds for required methods.</p><p><code>methodConfig::NTuple{L, Vector{&lt;:Pair}}</code>: The additional keywords arguments for each  method stored as <code>Tuple</code>s of <code>Pair</code>s.</p><p><code>oscillateThreshold::T</code>: The threshold for oscillating convergence.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">SCFconfig(methods::NTuple{L, Symbol}, intervals::NTuple{L, T}, 
          config::Dict{Int, &lt;:AbstractVector{&lt;:Pair}}=Dict(1=&gt;Pair[]);
          oscillateThreshold::Real=1.0e-6) where {L, T} -&gt; 
SCFconfig{T, L}</code></pre><p><code>methods</code> and <code>intervals</code> are the convergence methods to be applied and their stopping  (or skipping) thresholds respectively. <code>config</code> specifies additional keyword argument(s)  for each methods by a <code>Pair</code> of which the key <code>i::Int</code> is for <code>i</code>th method and the pointed  <code>AbstractVector{&lt;:Pair}</code> is the pairs of keyword arguments and their values respectively.</p><pre><code class="nohighlight hljs">SCFconfig(;threshold::AbstractFloat=(0.005, 1.0e-12), 
           oscillateThreshold::Real=defultOscThreshold) -&gt; 
SCFconfig{Float64, 2}</code></pre><p><code>threshold</code> will update the stopping threshold of the default SCF configuration used in  HFconfig() with a new value. In other words, it updates the stopping threshold of  <code>:1.0e-12</code>.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; SCFconfig((:DD, :ADIIS, :DIIS), (1e-4, 1e-12, 1e-13), Dict(2=&gt;[:solver=&gt;:LCM]));

julia&gt; SCFconfig(threshold=1e-8, oscillateThreshold=1e-5)
SCFconfig{Float64, 2}(method=(:ADIIS, :DIIS), interval=(0.005, 1.0e-8), methodConfig, oscillateThreshold)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/HartreeFock.jl#L257-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GridBox" href="#Quiqbox.GridBox"><code>Quiqbox.GridBox</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridBox{T, D, NP, GPT&lt;:SpatialPoint{T, D}} &lt;: SpatialStructure{T, D}</code></pre><p>A container of multiple <code>D</code>-dimensional grid points.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>spacing::T</code>: The distance between adjacent grid points, a.k.a the edge length of each grid.</p><p><code>nPoint::Int</code>: Total number of the grid points.</p><p><code>point::NTuple{NP, GPT}</code>: The grid points represented by <a href="#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p><p><code>param::Tuple{Vararg{ParamBox{T}}}</code>: All the parameters in the <code>GridBox</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GridBox(nGrids::NTuple{D, Int}, spacing::Union{T, Array{T, 0}}, 
        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_-&gt;T(0),Val(D)); 
        canDiff::Bool=true, index::Int=0) where {T&lt;:AbstractFloat, D} -&gt; 
GridBox{T, D}</code></pre><p>Construct a general <code>D</code>-dimensional <code>GridBox</code>.</p><p>=== Positional argument(s) ===</p><p><code>nGrids::NTuple{D, Int}</code>: The numbers of grids along each dimension.</p><p><code>spacing::Union{T, Array{T, 0}}</code>: The edge length of each grid.</p><p><code>center::Union{AbstractVector{T}, NTuple{D, T}}</code>: The coordinate of the geometric center of  the grid box.</p><p>=== Keyword argument(s) ===</p><p><code>canDiff</code>: If all the <code>ParamBox</code>es stored in the constructed <code>GridBox</code> will be marked as  differentiable.</p><p><code>index</code>: The Index that will be assigned to the shared input variable  <code>L</code> of all the stored <code>ParamBox</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Box.jl#L27-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GridBox-Union{Tuple{D}, Tuple{T}, Tuple{Int64, T}, Tuple{Int64, T, Union{Tuple{Vararg{T, D}}, AbstractVector{T}}}} where {T&lt;:AbstractFloat, D}" href="#Quiqbox.GridBox-Union{Tuple{D}, Tuple{T}, Tuple{Int64, T}, Tuple{Int64, T, Union{Tuple{Vararg{T, D}}, AbstractVector{T}}}} where {T&lt;:AbstractFloat, D}"><code>Quiqbox.GridBox</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GridBox(nGridPerEdge::Int, spacing::T, 
        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_-&gt;T(0), 3); 
        canDiff::Bool=true, index::Int=0) where {T&lt;:AbstractFloat, D} -&gt; 
GridBox{T, D}</code></pre><p>The method of generating a cubic <code>GridBox</code>. Aside from the common arguments, <code>nGridPerEdge</code>  specifies the number of grids for every dimension. The dimension of the grid box is  determined by the dimension of <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Box.jl#L99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.POconfig" href="#Quiqbox.POconfig"><code>Quiqbox.POconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">POconfig{T, M, CBT&lt;:ConfigBox, F&lt;:Function} &lt;: ConfigBox{T, POconfig, M}</code></pre><p>The mutable container of parameter optimization configurations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>method::Val{M}</code>: The method to calculate objective function (e.g., HF energy) for  optimization. Available values of <code>M</code> from Quiqbox are :HF,.</p><p><code>config::CBT</code>: The configuration for the selected <code>method</code>. E.g., for <code>:HF</code> it&#39;s  <a href="#Quiqbox.HFconfig"><code>HFconfig</code></a>.</p><p><code>target::T</code>: The value of target function aimed to achieve. If it&#39;s set to <code>NaN</code>, the  convergence will be solely based on <code>threshold</code> between the latest updated function values  rather then the latest value and <code>target</code>.</p><p><code>threshold::T</code>: The error threshold (i.e. the absolute value of the function loss with  respect to <code>target</code>) for the convergence; when set to <code>NaN</code>, there will be no convergence  detection.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>GD::F</code>: Applied gradient descent <code>Function</code>. Default method is <a href="../coreFunction/#Quiqbox.gradDescent!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, T}} where T"><code>gradDescent!</code></a>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">POconfig(;method=Val{:HF}(), 
          config=HFconfig(), 
          target=NaN, 
          threshold=5.0e-7, 
          maxStep=500, 
          GD=gradDescent!) -&gt; 
POconfig</code></pre><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; POconfig();

julia&gt; POconfig(maxStep=100);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Optimization.jl#L37-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.CanOrbital" href="#Quiqbox.CanOrbital"><code>Quiqbox.CanOrbital</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CanOrbital{T, D, NN} &lt;: AbstractSpinOrbital{T, D}</code></pre><p>The spatial part (orbital) of a canonical spin-orbital (the set of which diagonalizes the  Fock matrix of a Hartree-Fock state) with its occupation information. This means the  maximal occupation number for the mode corresponding to the orbital (namely a canonical  orbital) equals 2. Please refer to <a href="../coreFunction/#Quiqbox.getCanOrbitals-Tuple{Quiqbox.HFfinalVars}"><code>getCanOrbitals</code></a> for the construction of a  <code>CanOrbital</code>.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>energy::T</code>: The eigen energy corresponding to the orbital.</p><p><code>index::Int</code>: The index of the orbital within the same spin configuration.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoords::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>occu::NTuple{2, Array{Bool, 0}}</code>: The occupations of two spin configurations.</p><p><code>orbital::GTBasisFuncs{T, D, 1}</code>: The spatial orbital part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Matter.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.MatterByHF" href="#Quiqbox.MatterByHF"><code>Quiqbox.MatterByHF</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatterByHF{T, D, NN, N, BN, HFTS} &lt;:MatterData{T, D, N}</code></pre><p>Container of the electronic structure information of a quantum system.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>Ehf::T</code>: Hartree-Fock energy of the electronic Hamiltonian.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoord::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>Enn::T</code>: The nuclear repulsion energy.</p><p><code>Ns::NTuple{2, Int}</code>: The numbers of two different spins respectively.</p><p><code>occuOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}}</code>: The occupied canonical  orbitals.</p><p><code>unocOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}}</code> The unoccupied canonical  orbitals.</p><p><code>occuC::NTuple{HFTS, Matrix{T}}</code>: Coefficient matrix(s) of occupied canonical orbitals.</p><p><code>unocC::NTuple{HFTS, Matrix{T}}</code>: Coefficient matrix(s) of unoccupied canonical orbitals.</p><p><code>coreHsameSpin::NTuple{HFTS, Matrix{T}}</code>: Core Hamiltonian(s) (one-body integrals) of the  canonical orbitals with same spin configuration(s).</p><p><code>eeIsameSpin::NTuple{HFTS, Array{T, 4}}</code>: electron-electron interactions (two-body  integrals) of the canonical orbitals with same spin configuration(s).</p><p><code>eeIdiffSpin::Matrix{T}</code>: Coulomb interactions between canonical orbitals with different  spins.</p><p><code>basis::GTBasis{T, D, BN}</code>: The basis set used for the Hartree-Fock approximation.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">MatterByHF(HFres::HFfinalVars{T, D, &lt;:Any, NN, BN, HFTS}; 
           roundAtol::Real=getAtolVal(T)) where {T, D, NN, BN, HFTS} -&gt; 
MatterByHF{T, D, NN, &lt;:Any, BN, HFTS}</code></pre><p>Construct a <code>MatterByHF</code> from the result of a Hartree-Fock method <code>HFres</code>.  Each parameter stored in the constructed <a href="#Quiqbox.CanOrbital"><code>CanOrbital</code></a>s in <code>.occuOrbital</code> and  <code>.unocOrbital</code> will be rounded to the nearest multiple of <code>roundAtol</code>; when <code>roundAtol</code> is  set to <code>NaN</code>, no rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/528e7704779f4916d4659c5246d8fc2cec95ce7d/src/Matter.jl#L155-L204">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coreFunction/">¬´ Core Functions</a><a class="docs-footer-nextpage" href="../toolFunction/">Tool Functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 13 August 2022 19:04">Saturday 13 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
