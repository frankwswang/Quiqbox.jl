<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Types ¬∑ Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../coreFunction/">Core Functions</a></li><li class="is-active"><a class="tocitem" href>Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/main/docs/src/coreType.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.DI" href="#Quiqbox.DI"><code>Quiqbox.DI</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DI{F&lt;:Function} &lt;: StructFunction{F}</code></pre><p>A &quot;dressed-up&quot; <a href="../toolFunction/#Quiqbox.itself-Tuple{Any}"><code>itself</code></a> that carries the information of a function (of type <code>F</code>).  For an instance <code>di=Quiqbox.DI(someFunction)</code> where <code>someFunction isa Function</code>,  <code>di(anyArgument) === anyArgument</code> and <code>di() === someFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Mapping.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.ParamBox" href="#Quiqbox.ParamBox"><code>Quiqbox.ParamBox</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamBox{T, V, F&lt;:Function} &lt;: DifferentiableParameter{T, ParamBox}</code></pre><p>Parameter container that can enable differentiation.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>data::Array{Pair{Array{T, 0}, Symbol}, 0}</code>: The container of the input variable data  in the form of a <code>Pair</code> of its value container and symbol) stored in the <code>ParamBox</code>. The  value of the input variable can be accessed by syntax <code>[]</code>; to modify it, for example for a  <code>pb::ParamBox{T}</code>, use the syntax <code>pb[] = newVal</code> where <code>newVal</code> is the new value that is  or can be converted into type <code>T</code>.</p><p><code>map::Union{F,</code><a href="#Quiqbox.DI"><code>DI</code></a><code>{F}}</code>: The mapping of the value of the input variable (i.e.  the input value) within the same domain (<code>.map(::T)-&gt;T</code>). The result (i.e., the value of  the output variable, or the &quot;output value&quot;) can be accessed by syntax <code>()</code>.</p><p><code>canDiff::Array{Bool, 0}</code>: Indicator of whether the output variable is &quot;marked&quot; as  differentiable with respect to the input variable in the differentiation process. In other  words, it determines whether the output variable represented by the <code>ParamBox</code> is treated  as a dependent variable or an independent variable.</p><p><code>index::Array{Union{Int, Nothing}, 0}</code>: Additional index assigned to the <code>ParamBox</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">ParamBox(inVar::Union{T, Array{T, 0}}, outSym::Symbol=:undef, 
         inSym::Symbol=Symbol(IVsymSuffix, outSym); 
         index::Union{Int, Nothing}=nothing, canDiff::Bool=false) where {T} -&gt; 
ParamBox{T, outSym, typeof(itself)}

ParamBox(inVar::Union{T, Array{T, 0}}, outSym::Symbol, mapFunction::Function, 
         inSym::Symbol=Symbol(IVsymSuffix, outSym); 
         index::Union{Int, Nothing}=nothing, canDiff::Bool=true) where {T} -&gt; 
ParamBox{T, outSym}</code></pre><p>=== Positional argument(s) ===</p><p><code>inVar::Union{T, Array{T, 0}}</code>: The value or the container of the input variable to be  stored. If the latter is the type of <code>data</code>, then it will directly used to construct  <code>.data[]</code> with without any copy.</p><p><code>outSym::Symbol</code>: The symbol of the output variable represented by the constructed  <code>ParamBox</code>. It&#39;s equal to the type parameter <code>V</code> of the constructed <code>ParamBox</code>.</p><p><code>inSym::Symbol</code>: The symbol of the input variable held by the constructed <code>ParamBox</code>.</p><p><code>mapFunction::Function</code>: The mapping (<code>mapFunction(::T)-&gt;T</code>) of the input variable, which  will be assigned to the field <code>.map</code>. When <code>mapFunction</code> is not provided, <code>.map</code> is set to  <a href="../toolFunction/#Quiqbox.itself-Tuple{Any}"><code>itself</code></a> that maps the input variable to an identical-valued output variable.</p><p>=== Keyword argument(s) ===</p><p><code>index::Union{Int, Nothing}</code>: The index of the constructed <code>ParamBox</code>. It&#39;s should be left  with its default value unless the user plans to utilize the index of a <code>ParamBox</code> for  specific application other than differentiation.</p><p><code>canDiff::Bool</code>: Determine whether the output variable is marked as &quot;differentiable&quot; with  respect to the input variable.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; ParamBox(1.0)
ParamBox{Float64, :undef, iT}(1.0)[‚àÇ][undef]

julia&gt; ParamBox(1.0, :a)
ParamBox{Float64, :a, iT}(1.0)[‚àÇ][a]

julia&gt; ParamBox(1.0, :a, abs)
ParamBox{Float64, :a, typeof(abs)}(1.0)[ùõõ][x_a]</code></pre><p><strong>NOTE 1:</strong> The rightmost &quot;<code>[‚àÇ][IV]</code>&quot; in the printed info indicates the differentiability  and the name (the symbol with an assigned index if applied) of the independent variable  tied to the <code>ParamBox</code>. When the <code>ParamBox</code> is marked as non-differentiable, &quot;<code>[‚àÇ]</code>&quot; is  grey and <code>IV</code> is the name of the output variable; when it&#39;s marked as differentiable,  &quot;<code>[‚àÇ]</code>&quot; becomes a green &quot;<code>[ùõõ]</code>&quot;, and <code>IV</code> corresponds to the name of the stored input  variable.</p><p><strong>NOTE 2:</strong> The output variable of a <code>ParamBox</code> is normally used to differentiate a  parameter functional (e.g., the Hartree-Fock energy). However, the derivative with respect  to the stored input variable can also be computed to when the <code>ParamBox</code> is marked as  differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Parameters.jl#L5-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFunc" href="#Quiqbox.BasisFunc"><code>Quiqbox.BasisFunc</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFunc{T, D, ùëô, GN, PT} &lt;: FloatingGTBasisFuncs{T, D, ùëô, GN, PT, 1}</code></pre><p>A (floating) Gaussian-type basis function with its center assigned to a defined coordinate.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>center::SpatialPoint{T, D, PT}</code>: The <code>D</code>-dimensional center.</p><p><code>gauss::NTuple{GN, GaussFunc{T, &lt;:Any}}</code>: Gaussian functions within the basis function.</p><p><code>l::Tuple{LTuple{D, ùëô}}</code>: Cartesian representation of the angular momentum. E.g.,  <code>LTuple{3, 1}((1, 0, 0))</code> (X¬πY‚Å∞Z‚Å∞) would correspond to an specific angular momentum  configuration where the sum of all the components is <code>ùëô=1</code>.</p><p><code>normalizeGTO::Bool</code>: Whether each <code>GaussFunc</code> inside will be normalized in calculations.</p><p><code>param::NTuple{D+GN*2, ParamBox}</code>Ôºö All the tunable parameters stored in the basis function.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">BasisFunc(cen::SpatialPoint{T, D, PT}, gs::NTuple{GN, AbstractGaussFunc{T}}, 
          l::Union{Tuple{LTuple{D, ùëô}}, LTuple{D, ùëô}}, normalizeGTO::Bool) where 
         {T, D, PT, ùëô, GN} -&gt; 
BasisFunc{T, D, ùëô, GN, PT}

BasisFunc(cen::SpatialPoint{T, D, PT}, gs::AbstractGaussFunc{T}, 
          l::Union{Tuple{LTuple{D, ùëô}}, LTuple{D, ùëô}}, normalizeGTO::Bool) where 
         {T, D, PT, ùëô, GN} -&gt; 
BasisFunc{T, D, ùëô, 1, PT}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L295-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFuncMix" href="#Quiqbox.BasisFuncMix"><code>Quiqbox.BasisFuncMix</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFuncMix{T, D, BN, BFT&lt;:BasisFunc{T, D}} &lt;: CompositeGTBasisFuncs{T, D, BN, 1}</code></pre><p>Sum of multiple <code>FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, 1}</code> without any  reformulation, treated as one basis function in the calculations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>BasisFunc::NTuple{BN, BFT}</code>: Basis functions used to sum up.</p><p><code>param::Tuple{Vararg{ParamBox}}</code>: Contained parameters.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">BasisFuncMix(bfs::Union{Tuple{Vararg{T}}, AbstractArray{T}}) where 
            {T&lt;:FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, &lt;:Any, 1}} -&gt; 
BasisFuncMix</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L763-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.BasisFuncs" href="#Quiqbox.BasisFuncs"><code>Quiqbox.BasisFuncs</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisFuncs{T, D, ùëô, GN, PT, ON} &lt;: FloatingGTBasisFuncs{T, D, ùëô, GN, PT, ON}</code></pre><p>A collection of basis functions with identical parameters except having different  orientations within a specified subshell (i.e. same total orbital angular momentum). It has  the same fields as <code>BasisFunc</code>. Specifically, for <code>l</code>, its size <code>ON</code> can be no less than 1  and no larger than the size of the corresponding subshell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L351-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GTBasis" href="#Quiqbox.GTBasis"><code>Quiqbox.GTBasis</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GTBasis{T, D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}} &lt;: BasisSetData{T, D, BFT}</code></pre><p>The container of basis set information.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>basis::NTuple{BN, BFT}</code>: Stored basis set.</p><p><code>S::Matrix{T}</code>: Overlap matrix.</p><p><code>Te::Matrix{T}</code>: Kinetic energy part of the electronic core Hamiltonian.</p><p><code>eeI::Array{T, 4}</code>: Electron-electron interaction.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GTBasis(basis::Union{Tuple{Vararg{GTBasisFuncs{T, D}}}, 
                     AbstractVector{&lt;:GTBasisFuncs{T, D}}}) where {T, D} -&gt; 
GTBasis{T, D}</code></pre><p>Construct a <code>GTBasis</code> given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L826-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GaussFunc" href="#Quiqbox.GaussFunc"><code>Quiqbox.GaussFunc</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussFunc{T, F1, F2} &lt;: AbstractGaussFunc{T}</code></pre><p>A contracted primitive Gaussian-type function.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>xpn::ParamBox{T, :Œ±, F1}</code>ÔºöThe exponent coefficient.</p><p><code>con::ParamBox{T, :d, F2}</code>: The contraction coefficient.</p><p><code>param::Tuple{ParamBox{T, Œ±}, ParamBox{T, d}}</code>: The parameter containers  inside a <code>GaussFunc</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GaussFunc(e::Union{T, ParamBox{T}}, d::Union{T, ParamBox{T}}) where 
         {T&lt;:AbstractFloat} -&gt; 
GaussFunc{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.SpatialPoint" href="#Quiqbox.SpatialPoint"><code>Quiqbox.SpatialPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpatialPoint{T, D, PT} &lt;: AbstractSpatialPoint{T, D}</code></pre><p>A <code>D</code>-dimensional spatial point.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>param::PT</code>: A <code>Tuple</code> of <a href="#Quiqbox.ParamBox"><code>ParamBox</code></a>s as the components of the spatial coordinate.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">SpatialPoint(pbs::Union{Tuple{ParamBox{T, :X, Fx}} where Fx, Tuple{ParamBox{T, :X, Fx}, ParamBox{T, :Y, Fy}} where {Fx, Fy}, Tuple{ParamBox{T, :X, Fx}, ParamBox{T, :Y, Fy}, ParamBox{T, :Z, Fz}} where {Fx, Fy, Fz}} where T) -&gt; SpatialPoint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Basis.jl#L153-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFconfig" href="#Quiqbox.HFconfig"><code>Quiqbox.HFconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFconfig{T1, HFT, F, T2, L, MS} &lt;: ConfigBox{T1, HFconfig, HFT}</code></pre><p>The container of Hartree-Fock method configuration.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>HF::Val{HFT}</code>: Hartree-Fock method type. Available values of <code>HFT</code> are  :RHF, :UHF.</p><p><code>C0::InitialC{T1, HFT, F}</code>: Initial guess of the orbital coefficient matrix(s) C of the  canonical orbitals. When <code>C0</code> is as an argument of <code>HFconfig</code>&#39;s constructor, it can be set  to <code>sym::Symbol</code> where available values of <code>sym</code> are  <code>:GWH, :Hcore, :SAD</code>; it can also be a <code>Tuple</code> of  prepared orbital coefficient matrix(s) for the corresponding Hartree-Fock method type.</p><p><code>SCF::SCFconfig{T2, L, MS}</code>: SCF iteration configuration. For more information please refer  to <a href="#Quiqbox.SCFconfig"><code>SCFconfig</code></a>.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>earlyStop::Bool</code>: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.</p><p><code>saveTrace::NTuple{4, Bool}</code>: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the field <code>.temp</code> of the output  <a href="#Quiqbox.HFfinalVars"><code>HFfinalVars</code></a> of <code>runHF</code>. The types of relevant information are:</p><table><tr><th style="text-align: center">Sequence</th><th style="text-align: center">Information</th><th style="text-align: center">Corresponding field in <a href="#Quiqbox.HFtempVars"><code>HFtempVars</code></a></th></tr><tr><td style="text-align: center">1</td><td style="text-align: center">orbital coefficient matrix(s)</td><td style="text-align: center"><code>.Cs</code></td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">density matrix(s)</td><td style="text-align: center"><code>.Ds</code>, <code>.shared.Dtots</code></td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">Fock matrix(s)</td><td style="text-align: center"><code>.Fs</code></td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">unconverged Hartree-Fock energy(s)</td><td style="text-align: center"><code>.Es</code>, <code>.shared.Etots</code></td></tr></table><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">HFconfig(;HF::Union{Symbol, Val}=:RHF, 
          C0::Union{Tuple{AbstractMatrix}, NTuple{2, AbstractMatrix}, 
                    Symbol, Val}=:SAD, 
          SCF::SCFconfig=SCFconfig{Float64, 2, Tuple{Val{:ADIIS}, Val{:DIIS}}}(method, interval=(0.001, 1.0e-12), methodConfig, oscillateThreshold), 
          maxStep::Int=150, 
          earlyStop::Bool=true, 
          saveTrace::NTuple{4, Bool}=(false, false, false, true)) -&gt; 
HFconfig</code></pre><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; HFconfig();

julia&gt; HFconfig(HF=:UHF);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/HartreeFock.jl#L642-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFfinalVars" href="#Quiqbox.HFfinalVars"><code>Quiqbox.HFfinalVars</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFfinalVars{T, D, HFT, NN, BN, HFTS} &lt;: HartreeFockFinalValue{T, HFT}</code></pre><p>The container of the final values after a Hartree-Fock SCF procedure.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>Ehf::T</code>: Hartree-Fock energy of the electronic Hamiltonian.</p><p><code>Enn::T</code>: The nuclear repulsion energy.</p><p><code>Ns::NTuple{HFTS, Int}</code>: The number(s) of electrons with same spin configurations(s). For  restricted closed-shell Hartree-Fock (RHF), the single element in <code>.Ns</code> represents both  spin-up electrons and spin-down electrons.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoords::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>C::NTuple{HFTS, Matrix{T}}</code>: Orbital coefficient matrix(s) for one spin configuration.</p><p><code>D::NTuple{HFTS, Matrix{T}}</code>: Density matrix(s) for one spin configuration.</p><p><code>F::NTuple{HFTS, Matrix{T}}</code>: Fock matrix(s) for one spin configuration.</p><p><code>Eo::NTuple{HFTS, Vector{T}}</code>: Energies of canonical orbitals.</p><p><code>occu::NTuple{HFTS, NTuple{BN, Int}}</code>: Occupations of canonical orbitals.</p><p><code>temp::NTuple{HFTS, [HFtempVars](@ref){T, HFT}}</code>: the intermediate values stored during  the Hartree-Fock interactions.</p><p><code>isConverged::Bool</code>: Whether the SCF procedure is converged in the end.</p><p><code>basis::GTBasis{T, D, BN}</code>: The basis set used for the Hartree-Fock approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/HartreeFock.jl#L548-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.HFtempVars" href="#Quiqbox.HFtempVars"><code>Quiqbox.HFtempVars</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HFtempVars{T, HFT} &lt;: HartreeFockintermediateData{T}</code></pre><p>The container to store the intermediate values (only of the one spin configuration) for  each iteration during the Hartree-Fock SCF procedure.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>N::Int</code>: The number of electrons with the one spin function.</p><p><code>Cs::Vector{Matrix{T}}</code>: Orbital coefficient matrices.</p><p><code>Ds::Vector{Matrix{T}}</code>: Density matrices corresponding to only spin configuration.</p><p><code>Fs::Vector{Matrix{T}}</code>: Fock matrices.</p><p><code>Es::Vector{T}</code>: Part of the Hartree-Fock energy corresponding to one spin configuration.</p><p><code>shared.Dtots::Vector{Matrix{T}}</code>: The total density matrices.</p><p><code>shared.Etots::Vector{T}</code>: The total Hartree-Fock energy.</p><p><strong>NOTE:</strong> For unrestricted Hartree-Fock, there are 2 <code>HFtempVars</code> being updated during the  iterations, and changing the field <code>shared.Dtots</code> or <code>shared.Etots</code> of one <code>HFtempVars</code>  will affect the other one&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/HartreeFock.jl#L285-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.SCFconfig" href="#Quiqbox.SCFconfig"><code>Quiqbox.SCFconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SCFconfig{T, L, MS&lt;:NTuple{L, Val}} &lt;: ImmutableParameter{T, SCFconfig}</code></pre><p>The <code>struct</code> for self-consistent field (SCF) iteration configurations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>method::MS</code>: The applied convergence methods. They can be specified as the elements inside  an <code>NTuple{L, Symbol}</code>, which is then input to the constructor of <code>SCFconfig</code> as the  positional argument <code>methods</code>. The available configuration(s) corresponding to each method  in terms of keyword arguments are:</p><table><tr><th style="text-align: left">Convergence Method(s)</th><th style="text-align: center">Configuration(s)</th><th style="text-align: center">Keyword(s)</th><th style="text-align: center">Range(s)/Option(s)</th><th style="text-align: right">Default(s)</th></tr><tr><td style="text-align: left"><code>:DD</code></td><td style="text-align: center">damping strength</td><td style="text-align: center"><code>dampStrength</code></td><td style="text-align: center">[<code>0</code>, <code>1</code>]</td><td style="text-align: right"><code>0.5</code></td></tr><tr><td style="text-align: left"><code>:DIIS</code>, <code>:EDIIS</code>, <code>:ADIIS</code></td><td style="text-align: center">subspace size; DIIS-Method solver</td><td style="text-align: center"><code>DIISsize</code>; <code>solver</code></td><td style="text-align: center"><code>1</code>,<code>2</code>...; <code>:LBFGS</code>...</td><td style="text-align: right"><code>10</code>; <code>:LBFGS</code></td></tr></table><p><strong>Convergence Methods</strong></p><ul><li><code>:DD</code>: Direct diagonalization of the Fock matrix.</li><li><code>:DIIS</code>: <a href="https://onlinelibrary.wiley.com/doi/10.1002/jcc.540030413">Direct inversion in the iterative subspace</a>.</li><li><code>:EDIIS</code>: <a href="https://aip.scitation.org/doi/abs/10.1063/1.1470195">Energy-DIIS</a>.</li><li><code>:ADIIS</code>: <a href="https://aip.scitation.org/doi/10.1063/1.3304922">DIIS based on the augmented Roothaan‚ÄìHall (ARH) energy function</a>.</li></ul><p><strong>DIIS-Method Solvers</strong></p><ul><li><code>:LBFGS</code>: <a href="https://github.com/JuliaNLSolvers/Optim.jl">Limited-memory BFGS with box constraints</a>.</li><li><code>:LCM</code>: Lagrange multiplier solver.</li><li><code>:SPGB</code>: <a href="https://github.com/m3g/SPGBox.jl">Spectral Projected Gradient Method with box constraints</a>.</li></ul><p><code>interval::NTuple{L, T}</code>: The stopping (or skipping) thresholds for required methods.</p><p><code>methodConfig::NTuple{L, Vector{&lt;:Pair}}</code>: The additional keywords arguments for each  method stored as <code>Tuple</code>s of <code>Pair</code>s.</p><p><code>oscillateThreshold::T</code>: The threshold for oscillating convergence.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">SCFconfig(methods::NTuple{L, Symbol}, intervals::NTuple{L, T}, 
          config::Dict{Int, &lt;:AbstractVector{&lt;:Pair}}=Dict(1=&gt;Pair[]);
          oscillateThreshold::Real=1.0e-6) where {L, T} -&gt; 
SCFconfig{T, L}</code></pre><p><code>methods</code> and <code>intervals</code> are the convergence methods to be applied and their stopping  (or skipping) thresholds respectively. <code>config</code> specifies additional keyword argument(s)  for each methods by a <code>Pair</code> of which the key <code>i::Int</code> is for <code>i</code>th method and the pointed  <code>AbstractVector{&lt;:Pair}</code> is the pairs of keyword arguments and their values respectively.</p><pre><code class="nohighlight hljs">SCFconfig(;threshold::AbstractFloat=(0.001, 1.0e-12), 
           oscillateThreshold::Real=defultOscThreshold) -&gt; 
SCFconfig{Float64, 2}</code></pre><p><code>threshold</code> will update the stopping threshold of the default SCF configuration used in  HFconfig() with a new value. In other words, it updates the stopping threshold of  <code>:1.0e-12</code>.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; SCFconfig((:DD, :ADIIS, :DIIS), (1e-4, 1e-12, 1e-13), Dict(2=&gt;[:solver=&gt;:LCM]));

julia&gt; SCFconfig(threshold=1e-8, oscillateThreshold=1e-5)
SCFconfig{Float64, 2, Tuple{Val{:ADIIS}, Val{:DIIS}}}(method, interval=(0.001, 1.0e-8), methodConfig, oscillateThreshold)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/HartreeFock.jl#L437-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GridBox" href="#Quiqbox.GridBox"><code>Quiqbox.GridBox</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridBox(nGridPerEdge::Int, spacing, center=ntuple(_-&gt;eltype(spacing[begin])(0), 3); 
        canDiff::Bool=true, index::Int=0) -&gt; 
GridBox{T, D}</code></pre><p>The method of generating a cubic <code>GridBox</code>. Aside from the common arguments, <code>nGridPerEdge</code>  specifies the number of grids for every dimension. The dimension of the grid box is  determined by the dimension of <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Box.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GridBox" href="#Quiqbox.GridBox"><code>Quiqbox.GridBox</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridBox{T, D, NP, GPT&lt;:SpatialPoint{T, D}} &lt;: SpatialStructure{T, D}</code></pre><p>A container of multiple <code>D</code>-dimensional grid points.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>spacing::NTuple{D, T}</code>: The distance between adjacent grid points along each dimension.</p><p><code>nPoint::Int</code>: Total number of the grid points.</p><p><code>point::NTuple{NP, GPT}</code>: The grid points represented by <a href="#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p><p><code>param::Tuple{Vararg{ParamBox{T}}}</code>: All the parameters in the <code>GridBox</code>.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GridBox(nGrids::NTuple{D, Int}, spacing::NTuple{D, Union{Array{T, 0}, T}}, 
        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_-&gt;T(0),Val(D)); 
        canDiff::NTuple{D, Bool}=ntuple(_-&gt;true, Val(D)), 
        index::NTuple{D, Int}=ntuple(_-&gt;0, Val(D))) where {T&lt;:AbstractFloat, D} -&gt; 
GridBox{T, D}

GridBox(nGrids::NTuple{D, Int}, spacingForAllDim::Union{T, Array{T, 0}}, 
        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_-&gt;T(0), Val(D)); 
        canDiff::Bool=true, index::Int=0) where {T&lt;:AbstractFloat, D} -&gt; 
GridBox{T, D}</code></pre><p>Construct a general <code>D</code>-dimensional <code>GridBox</code>.</p><p>=== Positional argument(s) ===</p><p><code>nGrids::NTuple{D, Int}</code>: The numbers of grids along each dimension.</p><p><code>spacing::NTuple{D, Union{Array{T, 0}, T}}</code>: The spacing between grid points along each  dimension.</p><p><code>spacingForAllDim::NTuple{D, Union{Array{T, 0}, T}}</code>: A single spacing applied for all  dimensions.</p><p><code>center::Union{AbstractVector{T}, NTuple{D, T}}</code>: The coordinate of the geometric center of  the grid box.</p><p>=== Keyword argument(s) ===</p><p><code>canDiff</code>::NTuple{D, Bool}: Whether the <code>ParamBox</code>es of each dimension stored in the  constructed <code>GridBox</code> will be marked as differentiable.</p><p><code>index</code>::NTuple{D, Int}: The Index(s) that will be assigned to the shared input variable(s)  <code>L</code> of the stored <code>ParamBox</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Box.jl#L17-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.GDconfig" href="#Quiqbox.GDconfig"><code>Quiqbox.GDconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GDconfig{T, M, ST&lt;:Union{Array{T, 0}, T}} &lt;: ConfigBox{T, GDconfig, M}</code></pre><p>The mutable container of configurations for the default gradient descent method used to  optimize parameters.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>lineSearchMethod::M</code>: The selected line search method to optimize the step size for each  gradient descent iteration. It can be any algorithm defined in the Julia package  <a href="https://github.com/JuliaNLSolvers/LineSearches.jl">LineSearches.jl</a>, or <a href="../toolFunction/#Quiqbox.itself-Tuple{Any}"><code>itself</code></a>  so that the step size will be fixed to a constant value during all the iterations.</p><p><code>initialStep::ST</code>: The value of the initial step size in each iteration. If it&#39;s an  <code>Array{T, 0}</code>, then the final step size (optimized by <code>lineSearchMethod</code>) in current  interaction will be set as the initial step size for the next iteration.</p><p><code>stepBound::NTuple{2, T}</code>: The lower bound and upper bound of the step size to enforce  <code>stepBound[begin] ‚â§ Œ∑ ‚â§ stepBound[end]</code> (where <code>Œ∑</code> is the step size in each iteration).  Whenever the size size is out of the boundary, it will be clipped to a bound value.</p><p><code>scaleStepBound::Bool</code>: Determine whether <code>stepBound</code> will be scaled so that the norm of  the gradient descent in each iteration is constrained within the initially configured  <code>stepBound</code>, i.e., <code>stepBound[begin] ‚â§ norm(Œ∑*‚àáf) ‚â§ stepBound[end]</code> (where <code>‚àáf</code> is the  gradient of some function <code>f</code> in each iteration).</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">GDconfig(lineSearchMethod::M=BackTracking(), 
         initialStep::Union{Array{T, 0}, T}=ifelse(M==typeof(itself), 0.1, 1.0); 
         stepBound::NTuple{2, T}=convert.(eltype(initialStep), (0, Inf)), 
         scaleStepBound::Bool=ifelse(M==typeof(itself), true, false)) where 
        {M, T&lt;:AbstractFloat} -&gt; 
GDconfig{T, M, typeof(initialStep)}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Optimization.jl#L43-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.POconfig" href="#Quiqbox.POconfig"><code>Quiqbox.POconfig</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">POconfig{T, M, CBT&lt;:ConfigBox, TH&lt;:Union{T, NTuple{2, T}}, 
         OM} &lt;: ConfigBox{T, POconfig, M}</code></pre><p>The mutable container of parameter optimization configurations.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>method::Val{M}</code>: The method that defines the objective function (e.g., HF energy) for the  optimization. Available values of <code>M</code> from Quiqbox are :HFenergy, :DirectRHFenergy.</p><p><code>config::CBT</code>: The configuration for the selected <code>method</code>. E.g., for <code>:HFenergy</code> it&#39;s  <a href="#Quiqbox.HFconfig"><code>HFconfig</code></a>.</p><p><code>target::T</code>: The target value of the objective function. The difference between the  last-step value and the target value will be used for convergence detection. If it&#39;s set to  <code>NaN</code>, the gradient of the latest step and the difference between the function values of  latest two steps are used instead.</p><p><code>threshold::TH</code>: The error threshold/thresholds for the function value difference and  the gradient both/respectively to determine whether the optimization iteration has  converged. When it&#39;s (or either of them) set to <code>NaN</code>, there will be no corresponding  convergence detection, and when <code>target</code> is not <code>NaN</code>, the threshold for the gradient won&#39;t  be used because the gradient won&#39;t be part of the convergence criteria.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>optimizer::F</code>: Applied parameter optimizer. The default setting is <a href="#Quiqbox.GDconfig"><code>GDconfig</code></a><code>()</code>.  To use a function implemented by the user as the optimizer, it should have the following  function signature: </p><pre><code class="nohighlight hljs">optimizer(f::Function, gf::Function, x0::Vector{T}) where {T} -&gt; Function</code></pre><p>where <code>f</code> is the objective function to be minimized, <code>gf</code> is a function that returns  both the gradient and the returned value of <code>f</code> given the input value as a vector. <code>x0</code> is  the initial input value. The output of <code>optimizer</code>, if we name it <code>optimize!</code>, should have  the corresponding function signature: </p><pre><code class="nohighlight hljs">optimize!(x::Vector{T}, gx::Vector{T}, fx::T) where {T}</code></pre><p>where <code>x</code>, <code>gx</code>, <code>fx</code> are the input value, the gradient, and the returned value of <code>f</code>  respectively at one step. In other words, <code>(gx, fx) == (gx, f(x)) == gf(x)</code>. After  accepting those arguments, <code>optimizer</code> should update (i.e. mutate the elements of) <code>x</code> so  that f(x) will have lower returned value.</p><p><code>saveTrace::NTuple{4, Bool}</code>: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the output of <code>optimizeParams!</code>. The types of relevant information are:</p><table><tr><th style="text-align: center">Sequence</th><th style="text-align: center">Corresponding Information</th></tr><tr><td style="text-align: center">1</td><td style="text-align: center">function value of the applied method</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">parameter value(s)</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">function gradient with respect to the parameter(s)</td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">complete output of the applied method</td></tr></table><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">POconfig(;method::Union{Val{M}, Symbol}=HFenergy, 
          config::ConfigBox=Quiqbox.defaultOFconfigs[method], 
          target::T=NaN, 
          threshold::Union{T, NTuple{2, T}}=(5.0e-8, 5.0e-5), 
          maxStep::Int=200, 
          optimizer::Function=GDconfig()) where 
        {T, M} -&gt; 
POconfig{T, M}</code></pre><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; POconfig();

julia&gt; POconfig(maxStep=100);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Optimization.jl#L114-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.CanOrbital" href="#Quiqbox.CanOrbital"><code>Quiqbox.CanOrbital</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CanOrbital{T, D, NN} &lt;: AbstractSpinOrbital{T, D}</code></pre><p>The spatial part (orbital) of a canonical spin-orbital (the set of which diagonalizes the  Fock matrix of a Hartree-Fock state) with its occupation information. This means the  maximal occupation number for the mode corresponding to the orbital (namely a canonical  orbital) equals 2. Please refer to <a href="../coreFunction/#Quiqbox.genCanOrbitals-Union{Tuple{Quiqbox.HFfinalVars{T}}, Tuple{T}} where T"><code>genCanOrbitals</code></a> for the construction of a  <code>CanOrbital</code>.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>energy::T</code>: The eigen energy corresponding to the orbital.</p><p><code>index::Int</code>: The index of the orbital within the same spin configuration.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoords::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>occu::NTuple{2, Array{Bool, 0}}</code>: The occupations of two spin configurations.</p><p><code>orbital::GTBasisFuncs{T, D, 1}</code>: The spatial orbital part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Matter.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.MatterByHF" href="#Quiqbox.MatterByHF"><code>Quiqbox.MatterByHF</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatterByHF{T, D, NN, BN, HFTS} &lt;:MatterData{T, D}</code></pre><p>Container of the electronic structure information of a quantum system.</p><p>‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°</p><p><code>Ehf::T</code>: Hartree-Fock energy of the electronic Hamiltonian.</p><p><code>nuc::NTuple{NN, String}</code>: The nuclei in the studied system.</p><p><code>nucCoord::NTuple{NN, NTuple{D, T}}</code>: The coordinates of corresponding nuclei.</p><p><code>Enn::T</code>: The nuclear repulsion energy.</p><p><code>Ns::NTuple{HFTS, Int}</code>: The number(s) of electrons with same spin configurations(s). For  restricted closed-shell Hartree-Fock (RHF), the single element in <code>.Ns</code> represents both  spin-up electrons and spin-down electrons.</p><p><code>occu::NTuple{HFTS, NTuple{BN, Int}}</code>: Occupations of canonical orbitals.</p><p><code>occuOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}}</code>: The occupied canonical  orbitals.</p><p><code>unocOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}}</code> The unoccupied canonical  orbitals.</p><p><code>occuC::NTuple{HFTS, Matrix{T}}</code>: Coefficient matrix(s) of occupied canonical orbitals.</p><p><code>unocC::NTuple{HFTS, Matrix{T}}</code>: Coefficient matrix(s) of unoccupied canonical orbitals.</p><p><code>coreHsameSpin::NTuple{HFTS, Matrix{T}}</code>: Core Hamiltonian(s) (one-body integrals) of the  canonical orbitals with same spin configuration(s).</p><p><code>eeIsameSpin::NTuple{HFTS, Array{T, 4}}</code>: electron-electron interactions (two-body  integrals) of the canonical orbitals with same spin configuration(s).</p><p><code>eeIdiffSpin::Matrix{T}</code>: Coulomb interactions between canonical orbitals with different  spins.</p><p><code>basis::GTBasis{T, D, BN}</code>: The basis set used for the Hartree-Fock approximation.</p><p>‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">MatterByHF(HFres::HFfinalVars{T, D, &lt;:Any, NN, BN, HFTS}; 
           roundAtol::Real=getAtolVal(T)) where {T, D, NN, BN, HFTS} -&gt; 
MatterByHF{T, D, NN, BN, HFTS}</code></pre><p>Construct a <code>MatterByHF</code> from the result of a Hartree-Fock method <code>HFres</code>.  Each parameter stored in the constructed <a href="#Quiqbox.CanOrbital"><code>CanOrbital</code></a>s in <code>.occuOrbital</code> and  <code>.unocOrbital</code> will be rounded to the nearest multiple of <code>roundAtol</code>; when <code>roundAtol</code> is  set to <code>NaN</code>, no rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/ec34d21913e1d3c25be8dd50fc983a53a3cb3006/src/Matter.jl#L166-L219">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coreFunction/">¬´ Core Functions</a><a class="docs-footer-nextpage" href="../toolFunction/">Tool Functions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 6 March 2023 13:57">Monday 6 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
