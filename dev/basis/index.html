<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basis Sets · Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Basis Sets</a><ul class="internal"><li><a class="tocitem" href="#Basis-Set-Construction"><span>Basis Set Construction</span></a></li><li><a class="tocitem" href="#Dependent-Variable-as-Parameter"><span>Dependent Variable as Parameter</span></a></li></ul></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../coreFunction/">Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Basis Sets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basis Sets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/master/docs/src/basis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basis-Sets"><a class="docs-heading-anchor" href="#Basis-Sets">Basis Sets</a><a id="Basis-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Sets" title="Permalink"></a></h1><p>The procedure to construct a basis set can be fundamentally broken down into several basic steps: first, choose a set of (tunable) parameters, and build the Gaussian functions around those parameters, then the basis functions around the Gaussian functions, finally the basis set.</p><p>The data structure formularized by Quiqbox in each step, namely the level of data complexity, can be summarized in the following table.</p><table><tr><th style="text-align: center">level</th><th style="text-align: center">objective</th><th style="text-align: center">product examples</th><th style="text-align: center">abstract type</th><th style="text-align: center">type instances</th></tr><tr><td style="text-align: center">4</td><td style="text-align: center">basis set</td><td style="text-align: center">Array of basis functions (with reusable integrals)</td><td style="text-align: center"><code>Array</code>, <code>GTBasis</code></td><td style="text-align: center"><code>Array{&lt;:BasisFunc, 1}</code>...</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">basis functions</td><td style="text-align: center">single or linear combination of Gaussian functions</td><td style="text-align: center"><code>FloatingGTBasisFuncs</code></td><td style="text-align: center"><code>BasisFunc{0, 1}</code>, <code>BasisFuncs{1, 3, 3}</code>...</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">Gaussian functions</td><td style="text-align: center">(primitive) Gaussian functions</td><td style="text-align: center"><code>AbstractGaussFunc</code></td><td style="text-align: center"><code>GaussFunc</code></td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">a pool of parameters</td><td style="text-align: center">center coordinates, function coefficients</td><td style="text-align: center"><code>ParamBox</code></td><td style="text-align: center"><code>ParamBox</code>...</td></tr></table><p>Depending on how much control the user wants to have over each step, Quiqbox provides several <a href="https://docs.julialang.org/en/v1/manual/methods/">methods</a> of related functions to leave the user with the freedom to balance between efficiency and customizability. </p><p>Below are some examples from the simplest way to relatively more flexible ways to construct a basis set in Quiqbox. Hopefully these use cases can also work as inspirations for more creative ways to manipulate basis sets.</p><h2 id="Basis-Set-Construction"><a class="docs-heading-anchor" href="#Basis-Set-Construction">Basis Set Construction</a><a id="Basis-Set-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Set-Construction" title="Permalink"></a></h2><h3 id="Constructing-basis-sets-from-existed-basis-sets"><a class="docs-heading-anchor" href="#Constructing-basis-sets-from-existed-basis-sets">Constructing basis sets from existed basis sets</a><a id="Constructing-basis-sets-from-existed-basis-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-from-existed-basis-sets" title="Permalink"></a></h3><p>First, you can create a basis set at one coordinate by input the <code>Vector</code> of its center coordinate and a <code>Tuple</code> of its name and corresponding atom in <code>String</code>.</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsO = Quiqbox.genBasisFunc([0,0,0], (&quot;STO-3G&quot;, &quot;O&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre><p>Notice that in the above result there are 2 types of <code>struct</code>s in the returned <code>Vector</code>: <code>BasisFunc</code> and <code>BasisFuncs</code>. <code>BasisFunc</code> is the most basic <code>type</code> to hold the data of a basis function; <code>BasisFuncs</code> is very similar except it may hold multiple orbitals with only the spherical harmonics <span>$Y_{ml}$</span> being different when the orbital angular momentum <span>$l&gt;0$</span>.</p><div class="admonition is-info"><header class="admonition-header">Unit System</header><div class="admonition-body"><p>Hartree atomic units are the unit system used in Quiqbox.</p></div></div><p>If you want to postpone the specification of the center, you can replace the 1st argument with <code>missing</code>, and then use function <code>assignCenter!</code> to assign the coordinates later.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsO = genBasisFunc(missing, (&quot;STO-3G&quot;, &quot;O&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; assignCenter!([0,0,0], bsO[1]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsO</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; assignCenter!.(Ref([0,0,0]), bsO[2:end])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Tuple{ParamBox{Float64, :X, :itself}, ParamBox{Float64, :Y, :itself}, ParamBox{Float64, :Z, :itself}}}:
 (ParamBox{Float64, :X, :itself}(0.0)[∂][X], ParamBox{Float64, :Y, :itself}(0.0)[∂][Y], ParamBox{Float64, :Z, :itself}(0.0)[∂][Z])
 (ParamBox{Float64, :X, :itself}(0.0)[∂][X], ParamBox{Float64, :Y, :itself}(0.0)[∂][Y], ParamBox{Float64, :Z, :itself}(0.0)[∂][Z])</code></pre><p>If you omit the atom in the arguments, H will be set in default. Notice that even there&#39;s only 1 single basis function in H&#39;s STO-3G basis set, the returned value is still in <code>Array</code> type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsH_1 = genBasisFunc([-0.5, 0, 0], &quot;STO-3G&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][-0.5, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsH_2 = genBasisFunc([ 0.5, 0, 0], &quot;STO-3G&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.5, 0.0, 0.0]</code></pre><p>Finally, you can use Quiqbox&#39;s included tool function <code>flatten</code> to merge the three atomic basis set into one molecular basis set:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsH20 = [bsO, bsH_1, bsH_2] |&gt; flatten</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Quiqbox.FloatingGTBasisFuncs{Subshell, 3, OrbitalN} where {Subshell, OrbitalN}}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][-0.5, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.5, 0.0, 0.0]</code></pre><p>Not simple enough? Here&#39;s a more compact way of realizing the above steps if you are familiar with some <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugars</a> in Julia:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cens = [[0,0,0], [-0.5,0,0], [0.5,0,0]]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{Float64}}:
 [0.0, 0.0, 0.0]
 [-0.5, 0.0, 0.0]
 [0.5, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bsH20_2 = genBasisFunc.(cens, [(&quot;STO-3G&quot;, &quot;O&quot;), fill(&quot;STO-3G&quot;, 2)...]) |&gt; flatten</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Quiqbox.FloatingGTBasisFuncs{Subshell, 3, OrbitalN} where {Subshell, OrbitalN}}:
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][-0.5, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.5, 0.0, 0.0]</code></pre><p>In quiqbox, the user can often deal with several multi-layer containers (mainly <code>struct</code>s), it might be easy to get lost or uncertain that whether we are creating the objects intended. Quiqbox provides another tool function <code>hasEqual</code> that lets you compare if two objects hold the same data and structure. For example, if we want to see whether <code>bsH20_2</code> created in the faster way is same (not identical) as <code>bsH20</code>, we can verify it as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; hasEqual(bsH20, bsH20_2)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>If the basis set you want to use doesn&#39;t exist in Quiqbox&#39;s library, you can use <code>Function</code> <code>genBFuncsFromText</code> to generate the basis set from a <strong>Gaussian</strong> formatted <code>String</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; genBasisFunc(missing, (&quot;6-31G&quot;, &quot;Kr&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: KeyError: key &quot;Kr&quot; not found</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Data from https://www.basissetexchange.org
       txt_Kr_631G = &quot;&quot;&quot;
       Kr     0
       S    6   1.00
             0.1205524000D+06       0.1714050000D-02
             0.1810225000D+05       0.1313805000D-01
             0.4124126000D+04       0.6490006000D-01
             0.1163472000D+04       0.2265185000D+00
             0.3734612000D+03       0.4764961000D+00
             0.1280897000D+03       0.3591952000D+00
       SP   6   1.00
             0.2634681000D+04       0.2225111000D-02       0.3761911000D-02
             0.6284533000D+03       0.2971122000D-01       0.2977531000D-01
             0.2047081000D+03       0.1253926000D+00       0.1311878000D+00
             0.7790827000D+02       0.1947058000D-02       0.3425019000D+00
             0.3213816000D+02      -0.5987388000D+00       0.4644938000D+00
             0.1341845000D+02      -0.4958972000D+00       0.2087284000D+00
       SP   6   1.00
             0.1175107000D+03      -0.6157662000D-02      -0.6922855000D-02
             0.4152553000D+02       0.5464841000D-01      -0.3069239000D-01
             0.1765290000D+02       0.2706994000D+00       0.4480260000D-01
             0.7818313000D+01      -0.1426136000D+00       0.3636775000D+00
             0.3571775000D+01      -0.7216781000D+00       0.4952412000D+00
             0.1623750000D+01      -0.3412008000D+00       0.2086340000D+00
       SP   3   1.00
             0.2374560000D+01       0.3251184000D+00      -0.3009554000D-01
             0.8691930000D+00      -0.2141533000D+00       0.3598893000D+00
             0.3474730000D+00      -0.9755083000D+00       0.7103098000D+00
       SP   1   1.00
             0.1264790000D+00       0.1000000000D+01       0.1000000000D+01
       D    3   1.00
             0.6853888000D+02       0.7530705000D-01
             0.1914333000D+02       0.3673551000D+00
             0.6251213000D+01       0.7120146000D+00
       D    1   1.00
             0.1979236000D+01       1.0000000
       &quot;&quot;&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; genBFuncsFromText(txt_Kr_631G, adjustContent=true)</code><code class="nohighlight hljs ansi" style="display:block;">11-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 6}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFunc{0, 6}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 6, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]
 BasisFunc{0, 6}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 6, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]
 BasisFunc{0, 3}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]
 BasisFunc{0, 1}(gauss, subshell, center)[X⁰Y⁰Z⁰][NaN, NaN, NaN]
 BasisFuncs{1, 1, 3}(gauss, subshell, center)[3/3][NaN, NaN, NaN]
 BasisFuncs{2, 3, 6}(gauss, subshell, center)[6/6][NaN, NaN, NaN]
 BasisFuncs{2, 1, 6}(gauss, subshell, center)[6/6][NaN, NaN, NaN]</code></pre><h3 id="Constructing-basis-sets-from-GaussFunc"><a class="docs-heading-anchor" href="#Constructing-basis-sets-from-GaussFunc">Constructing basis sets from <code>GaussFunc</code></a><a id="Constructing-basis-sets-from-GaussFunc-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-from-GaussFunc" title="Permalink"></a></h3><p>If you want to specify the parameters of each Gaussian function when constructing a basis set, you can first construct the container for Gaussian functions: <code>GaussFunc</code>, and then build the basis function upon them:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1 = GaussFunc(2.0, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.0)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf2 = GaussFunc(2.5, 0.75)</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.5)[∂][α], con=ParamBox{Float64, :d, :itself}(0.75)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf1 = genBasisFunc([1.0,0,0], [gf1, gf2])</code><code class="nohighlight hljs ansi" style="display:block;">BasisFunc{0, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][1.0, 0.0, 0.0]</code></pre><p>Unlike <code>BasisFunc</code> there&#39;s no proprietary function for it, you simply input the exponent coefficient and the contraction coefficient as the 1st and 2nd arguments respectively to its default constructor. As for the method of <code>genBasisFunc</code> in this case, the default subshell is set to be &quot;S&quot; as the optional 3rd argument, but you can construct a <code>BasisFuncs</code> which contains all the orbitals within a specified one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf2 = genBasisFunc([1.0,0,0], [gf1, gf2], &quot;P&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">BasisFuncs{1, 2, 3}(gauss, subshell, center)[3/3][1.0, 0.0, 0.0]</code></pre><p>You can even choose one or a few orbitals to keep by indicting them using a 3-element <code>Array</code> of the Cartesian representation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf3 = genBasisFunc([1.0,0,0], [gf1, gf2], [1,0,0])</code><code class="nohighlight hljs ansi" style="display:block;">BasisFunc{1, 2}(gauss, subshell, center)[X¹Y⁰Z⁰][1.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf4 = genBasisFunc([1.0,0,0], [gf1, gf2], [[1,0,0], [0,0,1]])</code><code class="nohighlight hljs ansi" style="display:block;">BasisFuncs{1, 2, 2}(gauss, subshell, center)[2/3][1.0, 0.0, 0.0]</code></pre><p>Again, if you want a faster solution, you can also directly define the 2 <code>GaussFunc</code> parameter(s) in a 2-element <code>Tuple</code> as the 2nd argument for <code>genBasisFunc</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf5 = genBasisFunc([1.0,0,0], ([2.0, 2.5], [1.0, 0.75]), [[1,0,0], [0,0,1]])</code><code class="nohighlight hljs ansi" style="display:block;">BasisFuncs{1, 2, 2}(gauss, subshell, center)[2/3][1.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hasEqual(bf4, bf5)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Constructing-basis-sets-based-on-ParamBox"><a class="docs-heading-anchor" href="#Constructing-basis-sets-based-on-ParamBox">Constructing basis sets based on <code>ParamBox</code></a><a id="Constructing-basis-sets-based-on-ParamBox-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-based-on-ParamBox" title="Permalink"></a></h3><p>Sometimes you may want the parameters of basis functions (or <code>GaussFunc</code>) to be under some constrains (which can be crucial for the later basis set optimization), this is when you need a deeper level of control over the parameters, through its direct container: <code>ParamBox</code>. In fact, in the above example we have already had an glimpse on it through the printed info in the REPL:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.0)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code></pre><p>the 2 fields of a <code>GaussFunc</code>, <code>.xpn</code> and <code>.con</code> are in fact <code>ParamBox</code>, and the actual value of them can be accessed through syntax <code>[]</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1.xpn</code><code class="nohighlight hljs ansi" style="display:block;">ParamBox{Float64, :α, :itself}(2.0)[∂][α]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1.con</code><code class="nohighlight hljs ansi" style="display:block;">ParamBox{Float64, :d, :itself}(1.0)[∂][d]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1.xpn[]</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf1.con[]</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code></pre><p>Since the data are not directly stored as <code>primitive type</code>s but rather inside <code>struct</code> <code>ParamBox</code>, this allows the direct assignment or shallow copy of them to not create new data with same values, but bindings to the original objects:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf3 = GaussFunc(1.1, 1)</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(1.1)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Direct assignment
       gf3_2 = gf3</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(1.1)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf3.xpn[] *= 2</code><code class="nohighlight hljs ansi" style="display:block;">2.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf3</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.2)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf3_2</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.2)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Shallow copy: `fill`
       bf6 = genBasisFunc([1,0,0], fill(gf3, 2))</code><code class="nohighlight hljs ansi" style="display:block;">BasisFunc{0, 2}(gauss, subshell, center)[X⁰Y⁰Z⁰][1.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf6.gauss</code><code class="nohighlight hljs ansi" style="display:block;">(GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.2)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d]), GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.2)[∂][α], con=ParamBox{Float64, :d, :itself}(1.0)[∂][d]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf6.gauss[1].xpn[] = 1.1</code><code class="nohighlight hljs ansi" style="display:block;">1.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf3_2.xpn[] == gf3.xpn[] == bf6.gauss[2].xpn[] == 1.1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Based on such trait in Julia, you can, for instance, create a basis set that enforces all the <code>GaussFunc</code>s have the <strong>identical</strong> parameters:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gf4 = GaussFunc(2.5, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">GaussFunc(xpn=ParamBox{Float64, :α, :itself}(2.5)[∂][α], con=ParamBox{Float64, :d, :itself}(0.5)[∂][d])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bs7 = genBasisFunc.([rand(3) for _=1:2], Ref(gf4))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{BasisFunc{0, 1}}:
 BasisFunc{0, 1}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.01738086331, 0.2231703928, 0.4900511496]
 BasisFunc{0, 1}(gauss, subshell, center)[X⁰Y⁰Z⁰][0.3495936754, 0.771762182, 0.6513524267]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; uniqueParams!(bs7)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{ParamBox{Float64, V, :itself} where V}:
 ParamBox{Float64, :X, :itself}(0.01738086331)[∂][X₁]
 ParamBox{Float64, :X, :itself}(0.3495936754)[∂][X₂]
 ParamBox{Float64, :Y, :itself}(0.2231703928)[∂][Y₁]
 ParamBox{Float64, :Y, :itself}(0.771762182)[∂][Y₂]
 ParamBox{Float64, :Z, :itself}(0.4900511496)[∂][Z₁]
 ParamBox{Float64, :Z, :itself}(0.6513524267)[∂][Z₂]
 ParamBox{Float64, :α, :itself}(2.5)[∂][α₁]
 ParamBox{Float64, :α, :itself}(2.5)[∂][α₁]
 ParamBox{Float64, :d, :itself}(0.5)[∂][d₁]
 ParamBox{Float64, :d, :itself}(0.5)[∂][d₁]</code></pre><p><code>uniqueParams!</code> marks all the parameters of the given basis set and  return the unique parameters. As you can see, even though <code>bs7</code> has  2 <code>GaussFunc</code>s as basis functions, but over all it only has 1 unique coefficient exponent <span>$\alpha_1$</span> and 1 unique contraction coefficient <span>$d_1$</span>.</p><h2 id="Dependent-Variable-as-Parameter"><a class="docs-heading-anchor" href="#Dependent-Variable-as-Parameter">Dependent Variable as Parameter</a><a id="Dependent-Variable-as-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Dependent-Variable-as-Parameter" title="Permalink"></a></h2><p>Another control the user can have on the parameters in Quiqbox is to not only store the each unique parameter as an independent variable, but also as a dependent variable, i.e., a math function of some more primitive independent variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pb1 = gf4.xpn</code><code class="nohighlight hljs ansi" style="display:block;">ParamBox{Float64, :α, :itself}(2.5)[∂][α₁]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pb1.map</code><code class="nohighlight hljs ansi" style="display:block;">itself (generic function with 1 method)</code></pre><p>The <code>map</code> field of a <code>ParamBox</code> stores a <code>Function</code>, referencing the <code>Function</code> that can be defined as a mapping of the actual stored data to another output data (<span>$R \to R$</span>). The output value can be access through syntax <code>()</code>. In default the variable is mapped to itself:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pb1[] == pb1()</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>You can get a clearer view of the mapping relations in a <code>ParamBox</code> using <code>getVarDict</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; getVarDict(pb1)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Symbolics.Num, Float64} with 1 entry:
  α₁ =&gt; 2.5</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../SCF/">Self-Consistent Field Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 07:17">Tuesday 26 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
