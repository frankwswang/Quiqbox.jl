var documenterSearchIndex = {"docs":
[{"location":"basis/#Basis-Sets","page":"Basis Sets","title":"Basis Sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The procedure of constructing a Gaussian-type basis set can fundamentally break down into several basic steps: first, make primitive Gaussian-type orbitals (GTO) using a set of parameters, then construct the basis functions from the linear combinations of those orbitals, finally build the basis set.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The data structures defined by Quiqbox in each step, form levels of data complexity. They can be summarized in the following table.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"level objective container type type examples\n4 basis set Array, Tuple, GTBasis Vector{<:BasisFunc{Float64, 3}}, GTBasis{Float64, 3, 2}...\n3 basis function GTBasisFuncs BasisFunc{Float64, 3, 0, 6}, Quiqbox.BasisFuncMix{Float64, 3, 2}...\n2 Gaussian-type function AbstractGaussFunc GaussFunc{Float64, iT, iT}...\n1 tunable parameter ParamBox, SpatialPoint ParamBox{Float64, :α, iT}, SpatialPoint{Float64, 3, P3D{Float64, iT, iT, iT}}...","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Depending on how much control the user wants to have over each step, Quiqbox defines several methods of related functions to provide the freedom of balancing between efficiency and customizability.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Below are some examples from the simplest way to more flexible ways of constructing a basis set in Quiqbox. Hopefully, these use cases can also work as inspirations for more creative ways to customize basis sets.","category":"page"},{"location":"basis/#Basis-set-construction","page":"Basis Sets","title":"Basis set construction","text":"","category":"section"},{"location":"basis/#Constructing-basis-sets-from-existing-basis-sets","page":"Basis Sets","title":"Constructing basis sets from existing basis sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"First, you can construct an atomic basis set at one coordinate by inputting its center coordinate, the basis set name and the corresponding atom symbol.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bsO = Quiqbox.genBasisFunc(fill(1.0, 3), \"STO-3G\", \"O\");\n\njulia> bsO[begin]\nBasisFunc{Float64, 3, 0, 3, …}{0, 0, 0}[(1.0, 1.0, 1.0)][X⁰Y⁰Z⁰]\n\njulia> bsO[end]\nBasisFuncs{Float64, 3, 1, 3, …}{0, 0, 0}[(1.0, 1.0, 1.0)][3/3]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Notice that in the returned bsO there are two types of elements: BasisFunc and BasisFuncs. BasisFunc is the most basic DataType to hold the data of a basis function; BasisFuncs is very similar except it may hold multiple orbitals with only the spherical harmonics Y_ml being different when the orbital angular momentum l0.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"info: Unit system\nHartree atomic units are the unit system used in Quiqbox.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to postpone the specification of the center, you can replace the first argument with missing, then use the function assignCenInVal! to assign the coordinates later.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bsO = genBasisFunc(missing, \"STO-3G\", \"O\");\n\njulia> [assignCenInVal!(b, fill(1.0, 3)) for b in bsO]\n3-element Vector{SpatialPoint{Float64, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:\n SpatialPoint{Float64, …}{0, 0, 0}[∂∂∂][(1.0, 1.0, 1.0)]\n SpatialPoint{Float64, …}{0, 0, 0}[∂∂∂][(1.0, 1.0, 1.0)]\n SpatialPoint{Float64, …}{0, 0, 0}[∂∂∂][(1.0, 1.0, 1.0)]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you omit the atom in the arguments, \"H\" will be set in default. Notice that even though there's only one single basis function in H's STO-3G basis set, the returned value is still a Vector.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bsH_1 = genBasisFunc([-0.5, 0, 0], \"STO-3G\")\n1-element Vector{BasisFunc{Float64, 3, 0, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:\n BasisFunc{Float64, 3, 0, 3, …}{0, 0, 0}[(-0.5, 0.0, 0.0)][X⁰Y⁰Z⁰]\n\njulia> bsH_2 = genBasisFunc([ 0.5, 0, 0], \"STO-3G\")\n1-element Vector{BasisFunc{Float64, 3, 0, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:\n BasisFunc{Float64, 3, 0, 3, …}{0, 0, 0}[(0.5, 0.0, 0.0)][X⁰Y⁰Z⁰]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Finally, you can use Quiqbox's included tool function flatten to merge the three atomic basis sets into one molecular basis set:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bsH2O = [bsO, bsH_1, bsH_2] |> flatten;","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Not simple enough? Here's a more compact way of realizing the above steps if you are familiar with Julia's vectorization syntactic sugars:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> cens = [fill(1.0,3), [-0.5,0,0], [0.5,0,0]];\n\njulia> bsH2O_2 = genBasisFunc.(cens, \"STO-3G\", [\"O\", \"H\", \"H\"]) |> flatten;","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"In quiqbox, the user can often deal with several multi-layer containers (mainly structs). It might be easy to get lost or unsure about whether the objects are created as intended. Quiqbox provides another tool function hasEqual that lets you verify if two objects hold the same-valued data and have the same structure. For example, if we want to see whether bsH2O_2 created in the faster way is the same (not necessarily identical) as bsH2O, we can do as follows:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> hasEqual(bsH2O, bsH2O_2)\ntrue","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If the basis set you want to use is not pre-stored in Quiqbox, you can use genBFuncsFromText to generate the basis set from a Gaussian format String:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"    push!(LOAD_PATH,\"../../src/\")\n    using Quiqbox\n    bf8 = genBasisFunc([1.0, 0.0, 1.0], (2.0, 4.0))","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"genBasisFunc(missing, \"6-31G\", \"Kr\")\n\n# Data from https://www.basissetexchange.org\ntxt_Kr_631G = \"\"\"\nKr     0\nS    6   1.00\n      0.1205524000D+06       0.1714050000D-02\n      0.1810225000D+05       0.1313805000D-01\n      0.4124126000D+04       0.6490006000D-01\n      0.1163472000D+04       0.2265185000D+00\n      0.3734612000D+03       0.4764961000D+00\n      0.1280897000D+03       0.3591952000D+00\nSP   6   1.00\n      0.2634681000D+04       0.2225111000D-02       0.3761911000D-02\n      0.6284533000D+03       0.2971122000D-01       0.2977531000D-01\n      0.2047081000D+03       0.1253926000D+00       0.1311878000D+00\n      0.7790827000D+02       0.1947058000D-02       0.3425019000D+00\n      0.3213816000D+02      -0.5987388000D+00       0.4644938000D+00\n      0.1341845000D+02      -0.4958972000D+00       0.2087284000D+00\nSP   6   1.00\n      0.1175107000D+03      -0.6157662000D-02      -0.6922855000D-02\n      0.4152553000D+02       0.5464841000D-01      -0.3069239000D-01\n      0.1765290000D+02       0.2706994000D+00       0.4480260000D-01\n      0.7818313000D+01      -0.1426136000D+00       0.3636775000D+00\n      0.3571775000D+01      -0.7216781000D+00       0.4952412000D+00\n      0.1623750000D+01      -0.3412008000D+00       0.2086340000D+00\nSP   3   1.00\n      0.2374560000D+01       0.3251184000D+00      -0.3009554000D-01\n      0.8691930000D+00      -0.2141533000D+00       0.3598893000D+00\n      0.3474730000D+00      -0.9755083000D+00       0.7103098000D+00\nSP   1   1.00\n      0.1264790000D+00       0.1000000000D+01       0.1000000000D+01\nD    3   1.00\n      0.6853888000D+02       0.7530705000D-01\n      0.1914333000D+02       0.3673551000D+00\n      0.6251213000D+01       0.7120146000D+00\nD    1   1.00\n      0.1979236000D+01       1.0000000\n\"\"\";\n\ngenBFuncsFromText(txt_Kr_631G, adjustContent=true);","category":"page"},{"location":"basis/#Constructing-basis-sets-from-GaussFunc","page":"Basis Sets","title":"Constructing basis sets from GaussFunc","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to specify the parameters of each basis function when constructing a basis set, you can first construct the container for primitive GTO: GaussFunc, and then construct the basis function from them:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> gf1 = GaussFunc(2.0, 1.0)\nGaussFunc{Float64, …}{0, 0}[∂∂][{2.0, 1.0}]\n\njulia> gf2 = GaussFunc(2.5, 0.75)\nGaussFunc{Float64, …}{0, 0}[∂∂][{2.5, 0.75}]\n\njulia> bf1 = genBasisFunc([1.0, 0, 0], [gf1, gf2])\nBasisFunc{Float64, 3, 0, 2, …}{0, 0, 0}[(1.0, 0.0, 0.0)][X⁰Y⁰Z⁰]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Unlike BasisFunc, there's no additional constructor function for GaussFunc. As for the method of genBasisFunc in this case, the subshell is set to \"s\" as the default option since the third argument is omitted. You can construct a BasisFuncs which contains all the orbitals within one specified subshell:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bf2 = genBasisFunc([1.0, 0, 0], [gf1, gf2], \"p\")\nBasisFuncs{Float64, 3, 1, 2, …}{0, 0, 0}[(1.0, 0.0, 0.0)][3/3]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"You can even select one or few orbitals to keep by specifying the corresponding orbital angular momentums in the Cartesian representation using NTuple{3, Int}:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bf3 = genBasisFunc([1.0, 0, 0], [gf1, gf2], (1,0,0))\nBasisFunc{Float64, 3, 1, 2, …}{0, 0, 0}[(1.0, 0.0, 0.0)][X¹Y⁰Z⁰]\n\njulia> bf4 = genBasisFunc([1.0, 0, 0], [gf1, gf2], [(1,0,0), (0,0,1)])\nBasisFuncs{Float64, 3, 1, 2, …}{0, 0, 0}[(1.0, 0.0, 0.0)][2/3]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Again, if you want a faster solution, you can directly define the exponent coefficients and the contraction coefficients separately in a 2-element Tuple as the second argument of genBasisFunc:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bf5 = genBasisFunc([1.0, 0, 0], ([2.0, 2.5], [1.0, 0.75]), [(1,0,0), (0,0,1)]);\n\njulia> hasEqual(bf4, bf5)\ntrue","category":"page"},{"location":"basis/#Constructing-basis-sets-based-on-ParamBox","page":"Basis Sets","title":"Constructing basis sets based on ParamBox","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Sometimes you may want the parameters of basis functions (or GaussFunc) to be under some constraints (which can be crucial for the later basis set optimization), this is when you need a deeper level of control over the parameters, through its direct container: ParamBox. In fact, in the above example, we have already had a glimpse of it through the printed info in the REPL:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> gf1\nGaussFunc{Float64, …}{0, 0}[∂∂][{2.0, 1.0}]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The two fields of a GaussFunc, .xpn, and .con are ParamBox, and their input value (i.e. the value of the input variable) can be accessed through syntax []:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> gf1.xpn\nParamBox{Float64, :α, …}{0}[∂][α]⟦=⟧[2.0]\n\njulia> gf1.con\nParamBox{Float64, :d, …}{0}[∂][d]⟦=⟧[1.0]\n\njulia> gf1.xpn[]\n2.0\n\njulia> gf1.con[]\n1.0","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Since the data are not directly stored in primitive types but rather inside ParamBox, this allows the shallow copy of a ParamBox to share the same underlying data: ","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> gf3 = GaussFunc(1.1, 1.0);\n\njulia> gf3_2 = gf3; # Direct assignment\n\njulia> bf6 = genBasisFunc([1.0, 0, 0], fill(gf3, 2)); # Shallow copy is performed when using `fill`\n\njulia> bf6.gauss[1].xpn[] *= 2;\n\njulia> gf3_2.xpn[] == gf3.xpn[] == bf6.gauss[2].xpn[] == 2.2\ntrue","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Based on such feature of ParamBox, the user can, for instance, create a basis set that enforces all the GaussFuncs to have identical gaussian function parameters:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> gf4 = GaussFunc(2.5, 0.5);\n\njulia> bs7 = genBasisFunc.([[0.0, 0.1, 0.0], [1.4, 0.3, 0.0]], Ref(gf4));\n\njulia> markParams!(bs7)\n10-element Vector{ParamBox{Float64, V, typeof(itself)} where V}:\n ParamBox{Float64, :X, …}{0}[∂][X₁]⟦=⟧[0.0]\n ParamBox{Float64, :Y, …}{0}[∂][Y₁]⟦=⟧[0.1]\n ParamBox{Float64, :Z, …}{0}[∂][Z₁]⟦=⟧[0.0]\n ParamBox{Float64, :α, …}{0}[∂][α₁]⟦=⟧[2.5]\n ParamBox{Float64, :d, …}{0}[∂][d₁]⟦=⟧[0.5]\n ParamBox{Float64, :X, …}{0}[∂][X₂]⟦=⟧[1.4]\n ParamBox{Float64, :Y, …}{0}[∂][Y₂]⟦=⟧[0.3]\n ParamBox{Float64, :Z, …}{0}[∂][Z₂]⟦=⟧[0.0]\n ParamBox{Float64, :α, …}{0}[∂][α₁]⟦=⟧[2.5]\n ParamBox{Float64, :d, …}{0}[∂][d₁]⟦=⟧[0.5]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"markParams! marks all the parameters of a given basis set. Even though bs7 has two GaussFuncs as basis functions, overall it only has one unique coefficient exponent alpha_1 and one unique contraction coefficient d_1 besides the center coordinates.","category":"page"},{"location":"basis/#Dependent-variable-as-a-parameter","page":"Basis Sets","title":"Dependent variable as a parameter","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Another control the user have on the parameters in Quiqbox is through a ParamBox represent a variable equal to the returned value of a mapping function taking the data value stored in the ParamBox as the input argument. In other words, the data stored in the ParamBox is an \"input variable\", while the represented variable is an \"output variable\".","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Such a mapping function is stored in the map field of the ParamBox (which normally is an R to R mapping). The \"output value\" can be accessed through syntax (). In default, the input variable is mapped to an output variable that has the identical value:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> pb1 = gf4.xpn\nParamBox{Float64, :α, …}{0}[∂][α₁]⟦=⟧[2.5]\n\njulia> pb1.map\nitself (generic function with 1 method)\n\njulia> pb1[] === pb1()\ntrue","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"info: Parameter represented by `ParamBox`\nThe output variable of a ParamBox is always used in the construction of any basis function component. To optimize the input variable stored in an arbitrary ParamBox pb, pb needs to be marked as \"differentiable\" (i.e., isDiffParam(pb)==true). For more information on parameter optimization, please see the docstring of optimizeParams! and section Parameter Optimization.","category":"page"},{"location":"basis/#Linear-combinations-of-basis-functions","page":"Basis Sets","title":"Linear combinations of basis functions","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Apart from the flexible control of basis function parameters, another major feature of Quiqbox is the ability to construct a basis function from the linear combination of other basis functions. Specifically, additional methods of + and * (operator syntax for add and mul) are implemented for CompositeGTBasisFuncs:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"julia> bf7 = genBasisFunc([1.0, 0.0, 1.0], (1.5, 3.0))\nBasisFunc{Float64, 3, 0, 1, …}{0, 0, 0}[(1.0, 0.0, 1.0)][X⁰Y⁰Z⁰]\n\njulia> bf8 = genBasisFunc([1.0, 0.0, 1.0], (2.0, 4.0))\nBasisFunc{Float64, 3, 0, 1, …}{0, 0, 0}[(1.0, 0.0, 1.0)][X⁰Y⁰Z⁰]\n\njulia> bf9 = bf7*0.5 + bf8\nBasisFunc{Float64, 3, 0, 2, …}{0, 0, 0}[(1.0, 0.0, 1.0)][X⁰Y⁰Z⁰]\n\njulia> bf9.gauss[1].con() == 3 * 0.5\ntrue","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"As we can see, the type of bf9 is still BasisFunc, hence all the GTO inside bf9 have the same center coordinates as well. This is because bf7 and bf8 have the same center coordinates. What if the combined basis functions are multi-center?","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf10 = genBasisFunc(fill(1.0, 3), (1.2, 3.0))\n\nbf11 = bf8 + bf10","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The type of bf11 is called Quiqbox.BasisFuncMix, which means it cannot be expressed as a single contracted Gaussian-type orbital (CGTO) as it is a mixed-contracted GTO (MCGTO).","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"There are other cases that can result in a BasisFuncMix as the returned object. For example:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf12 = genBasisFunc(fill(1.0, 3), (1.2, 3.0), (1,1,0))\n\nbf10 + bf12","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"In Quiqbox, BasisFuncMix is also accepted as a valid basis function and the user can use it to call functions that accept CompositeGTBasisFuncs as input argument(s):","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"overlap(bf11, bf11)","category":"page"},{"location":"SCF/#Self-Consistent-Field-Methods","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"","category":"section"},{"location":"SCF/#Hartree-Fock-methods","page":"Self-Consistent Field Methods","title":"Hartree-Fock methods","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox supports basic Hartree-Fock methods with various configurations: ","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Items Options\nHF Types restricted closed-shell (RHF), unrestricted open-shell (UHF)\nInitial Guesses core Hamiltonian, generalized Wolfsberg-Helmholtz, superposition of atomic densities (SAD), pre-defined coefficient matrix\nConverging Methods direct diagonalization, direct inversion in the iterative subspace (DIIS), E-DIIS, A-DIIS, combinations of multiple methods\nDIIS-type Method Solvers Lagrange multiplier solver, L-BFGS solver","category":"page"},{"location":"SCF/#Basic-Hartree-Fock","page":"Self-Consistent Field Methods","title":"Basic Hartree-Fock","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"To run a Hartree-Fock method, the lines of code required in Quiqbox are as simple as below:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"    push!(LOAD_PATH,\"../../src/\")\n    using Quiqbox","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nuc = [\"H\", \"H\"];\n\nnucCoords = [[-0.7, 0.0, 0.0], [0.7, 0.0, 0.0]];\n\nbs = genBasisFunc.(nucCoords, \"STO-3G\", nuc) |> flatten;\n\nresRHF = runHF(bs, nuc, nucCoords)\n\n@show resRHF.Ehf resRHF.C resRHF.Eo resRHF.occu;","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"After the SCF procedure, one can also store the result in a MatterByHF for further data processing such as generating a Molden file.","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"mol = MatterByHF(resRHF); ","category":"page"},{"location":"SCF/#Flexible-core-functions","page":"Self-Consistent Field Methods","title":"Flexible core functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"If the user wants to fine-tune the SCF iteration to achieve better performance, Quiqbox has provided various core types and functions that allow the user to customize the HF methods:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"HFconfig","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"SCFconfig","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"runHFcore","category":"page"},{"location":"SCF/#Stand-alone-integral-functions","page":"Self-Consistent Field Methods","title":"Stand-alone integral functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox also provides efficient native functions for one-electron and two-electron integral calculations.","category":"page"},{"location":"SCF/#One-electron-functions","page":"Self-Consistent Field Methods","title":"One-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlap","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlaps","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eKinetic","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eKinetics","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"neAttraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"neAttractions","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"coreHij","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"coreH","category":"page"},{"location":"SCF/#Two-electron-functions","page":"Self-Consistent Field Methods","title":"Two-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteractions","category":"page"},{"location":"coreType/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Modules = [Quiqbox]\nPages   = [\"Library.jl\", \"Mapping.jl\", \"Parameters.jl\", \"Basis.jl\", \"HartreeFock.jl\", \n           \"Differentiation.jl\", \"Box.jl\", \"Optimization.jl\", \"Matter.jl\"]\nOrder   = [:type]","category":"page"},{"location":"coreType/#Quiqbox.DI","page":"Core Types","title":"Quiqbox.DI","text":"DI{F<:Function} <: StructFunction{F}\n\nA \"dressed-up\" itself that carries the information of a function (of type F).  For an instance di=Quiqbox.DI(someFunction) where someFunction isa Function,  di(anyArgument) === anyArgument and di() === someFunction.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.ParamBox","page":"Core Types","title":"Quiqbox.ParamBox","text":"ParamBox{T, V, F<:Function} <: DifferentiableParameter{T, ParamBox}\n\nParameter container that can enable differentiation.\n\n≡≡≡ Field(s) ≡≡≡\n\ndata::Array{Pair{Array{T, 0}, Symbol}, 0}: The container of the input variable data  in the form of a Pair of its value container and symbol) stored in the ParamBox. The  value of the input variable can be accessed by syntax []; to modify it, for example for a  pb::ParamBox{T}, use the syntax pb[] = newVal where newVal is the new value that is  or can be converted into type T.\n\nmap::Union{F,DI{F}}: The mapping of the value of the input variable (i.e.  the input value) within the same domain (.map(::T)->T). The result (i.e., the value of  the output variable, or the \"output value\") can be accessed by syntax ().\n\ncanDiff::Array{Bool, 0}: Indicator of whether the output variable is \"marked\" as  differentiable with respect to the input variable in the differentiation process. In other  words, it determines whether the output variable represented by the ParamBox is treated  as a dependent variable or an independent variable.\n\nindex::Array{Union{Int, Nothing}, 0}: Additional index assigned to the ParamBox.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nParamBox(inVar::Union{T, Array{T, 0}}, outSym::Symbol=:undef, \n         inSym::Symbol=Symbol(IVsymSuffix, outSym); \n         index::Union{Int, Nothing}=nothing, canDiff::Bool=false) where {T} -> \nParamBox{T, outSym, typeof(itself)}\n\nParamBox(inVar::Union{T, Array{T, 0}}, outSym::Symbol, mapFunction::Function, \n         inSym::Symbol=Symbol(IVsymSuffix, outSym); \n         index::Union{Int, Nothing}=nothing, canDiff::Bool=true) where {T} -> \nParamBox{T, outSym}\n\n=== Positional argument(s) ===\n\ninVar::Union{T, Array{T, 0}}: The value or the container of the input variable to be  stored. If the latter is the type of data, then it will directly used to construct  .data[] with without any copy.\n\noutSym::Symbol: The symbol of the output variable represented by the constructed  ParamBox. It's equal to the type parameter V of the constructed ParamBox.\n\ninSym::Symbol: The symbol of the input variable held by the constructed ParamBox.\n\nmapFunction::Function: The mapping (mapFunction(::T)->T) of the input variable, which  will be assigned to the field .map. When mapFunction is not provided, .map is set to  itself that maps the input variable to an identical-valued output variable.\n\n=== Keyword argument(s) ===\n\nindex::Union{Int, Nothing}: The index of the constructed ParamBox. It's should be left  with its default value unless the user plans to utilize the index of a ParamBox for  specific application other than differentiation.\n\ncanDiff::Bool: Determine whether the output variable is marked as \"differentiable\" with  respect to the input variable.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> ParamBox(1.0)\nParamBox{Float64, :undef, …}{0}[∂][undef]⟦=⟧[1.0]\n\njulia> ParamBox(1.0, :a)\nParamBox{Float64, :a, …}{0}[∂][a]⟦=⟧[1.0]\n\njulia> ParamBox(1.0, :a, abs)\nParamBox{Float64, :a, …}{1}[𝛛][x_a]⟦→⟧[1.0]\n\nNOTE 1: The markers \"[∂][IV]\" in the printed info indicate the differentiability and  the name (the symbol with an assigned index if applied) respectively of the independent  variable tied to the ParamBox. When the ParamBox is marked as non-differentiable,  \"[∂]\" is grey and IV corresponds to the name of the output variable; when the  ParamBox is  marked as differentiable, \"[∂]\" becomes a green \"[𝛛]\", and IV  corresponds to the name of the stored input variable.\n\nNOTE 2: The output variable of a ParamBox is normally used to differentiate a  parameter functional (e.g., the Hartree-Fock energy). However, the derivative with respect  to the stored input variable can also be computed to when the ParamBox is marked as  differentiable.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.BasisFunc","page":"Core Types","title":"Quiqbox.BasisFunc","text":"BasisFunc{T, D, 𝑙, GN, PT} <: FloatingGTBasisFuncs{T, D, 𝑙, GN, PT, 1}\n\nA (floating) Gaussian-type basis function with its center assigned to a defined coordinate.\n\n≡≡≡ Field(s) ≡≡≡\n\ncenter::SpatialPoint{T, D, PT}: The D-dimensional center.\n\ngauss::NTuple{GN, GaussFunc{T, <:Any}}: Gaussian functions within the basis function.\n\nl::Tuple{LTuple{D, 𝑙}}: Cartesian representation of the angular momentum. E.g.,  LTuple{3, 1}((1, 0, 0)) (X¹Y⁰Z⁰) would correspond to an specific angular momentum  configuration where the sum of all the components is 𝑙=1.\n\nnormalizeGTO::Bool: Whether each GaussFunc inside will be normalized in calculations.\n\nparam::NTuple{D+GN*2, ParamBox}： All the tunable parameters stored in the basis function.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nBasisFunc(cen::SpatialPoint{T, D, PT}, \n          gs::Tuple{AbstractGaussFunc{T}, Vararg{AbstractGaussFunc{T}, GN-1}}, \n          l::Union{Tuple{LTuple{D, 𝑙}}, LTuple{D, 𝑙}}, normalizeGTO::Bool) where \n         {T, D, PT, 𝑙, GN} -> \nBasisFunc{T, D, 𝑙, GN, PT}\n\nBasisFunc(cen::SpatialPoint{T, D, PT}, gs::AbstractGaussFunc{T}, \n          l::Union{Tuple{LTuple{D, 𝑙}}, LTuple{D, 𝑙}}, normalizeGTO::Bool) where \n         {T, D, PT, 𝑙, GN} -> \nBasisFunc{T, D, 𝑙, 1, PT}\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.BasisFuncMix","page":"Core Types","title":"Quiqbox.BasisFuncMix","text":"BasisFuncMix{T, D, BN, BFT<:BasisFunc{T, D}} <: CompositeGTBasisFuncs{T, D, BN, 1}\n\nSum of multiple FloatingGTBasisFuncs{<:Any, <:Any, <:Any, <:Any, <:Any, 1} without any  reformulation, treated as one basis function in the calculations.\n\n≡≡≡ Field(s) ≡≡≡\n\nBasisFunc::NTuple{BN, BFT}: Basis functions used to sum up.\n\nparam::Tuple{Vararg{ParamBox}}: Contained parameters.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nBasisFuncMix(bfs::Union{Tuple{Vararg{T}}, AbstractArray{T}}) where \n            {T<:FloatingGTBasisFuncs{<:Any, <:Any, <:Any, <:Any, <:Any, 1}} -> \nBasisFuncMix\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.BasisFuncs","page":"Core Types","title":"Quiqbox.BasisFuncs","text":"BasisFuncs{T, D, 𝑙, GN, PT, ON} <: FloatingGTBasisFuncs{T, D, 𝑙, GN, PT, ON}\n\nA collection of basis functions with identical parameters except having different  orientations within a specified subshell (i.e. same total orbital angular momentum). It has  the same fields as BasisFunc. Specifically, for l, its size ON can be no less than 1  and no larger than the size of the corresponding subshell.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.GTBasis","page":"Core Types","title":"Quiqbox.GTBasis","text":"GTBasis{T, D, BN, BFT<:GTBasisFuncs{T, D, 1}} <: BasisSetData{T, D, BFT}\n\nThe container of basis set information.\n\n≡≡≡ Field(s) ≡≡≡\n\nbasis::NTuple{BN, BFT}: Stored basis set.\n\nS::Matrix{T}: Overlap matrix.\n\nTe::Matrix{T}: Kinetic energy part of the electronic core Hamiltonian.\n\neeI::Array{T, 4}: Electron-electron interaction.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGTBasis(basis::Union{Tuple{Vararg{GTBasisFuncs{T, D}}}, \n                     AbstractVector{<:GTBasisFuncs{T, D}}}) where {T, D} -> \nGTBasis{T, D}\n\nConstruct a GTBasis given a basis set.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.GaussFunc","page":"Core Types","title":"Quiqbox.GaussFunc","text":"GaussFunc{T, F1, F2} <: AbstractGaussFunc{T}\n\nA contracted primitive Gaussian-type function.\n\n≡≡≡ Field(s) ≡≡≡\n\nxpn::ParamBox{T, :α, F1}：The exponent coefficient.\n\ncon::ParamBox{T, :d, F2}: The contraction coefficient.\n\nparam::Tuple{ParamBox{T, α}, ParamBox{T, d}}: The parameter containers  inside a GaussFunc.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGaussFunc(e::Union{T, Array{T, 0}, ParamBox{T}}, d::Union{T, ParamBox{T}}) where \n         {T<:AbstractFloat} -> \nGaussFunc{T}\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.SpatialPoint","page":"Core Types","title":"Quiqbox.SpatialPoint","text":"SpatialPoint{T, D, PT} <: AbstractSpatialPoint{T, D}\n\nA D-dimensional spatial point.\n\n≡≡≡ Field(s) ≡≡≡\n\nparam::PT: A Tuple of ParamBoxs as the components of the spatial coordinate.\n\nmarker::Symbol: A marker that indicates the purpose or meaning of the constructed  SpatialPoint. The default marker is set to :point.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nSpatialPoint(pbs::Union{Tuple{ParamBox{T, :X, Fx}} where Fx, Tuple{ParamBox{T, :X, Fx}, ParamBox{T, :Y, Fy}} where {Fx, Fy}, Tuple{ParamBox{T, :X, Fx}, ParamBox{T, :Y, Fy}, ParamBox{T, :Z, Fz}} where {Fx, Fy, Fz}} where T) -> SpatialPoint\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.HFconfig","page":"Core Types","title":"Quiqbox.HFconfig","text":"HFconfig{T1, HFT, F, T2, L, MS} <: ConfigBox{T1, HFconfig, HFT}\n\nThe container of Hartree-Fock method configuration.\n\n≡≡≡ Field(s) ≡≡≡\n\nHF::Val{HFT}: Hartree-Fock method type. Available values of HFT are  :RHF, :UHF.\n\nC0::InitialC{T1, HFT, F}: Initial guess of the orbital coefficient matrix(s) C of the  canonical orbitals. When C0 is as an argument of HFconfig's constructor, it can be set  to sym::Symbol where available values of sym are  :GWH, :Hcore, :SAD; it can also be a Tuple of  prepared orbital coefficient matrix(s) for the corresponding Hartree-Fock method type.\n\nSCF::SCFconfig{T2, L, MS}: SCF iteration configuration. For more information please refer  to SCFconfig.\n\nmaxStep::Int: Maximum iteration steps allowed regardless if the iteration converges.\n\nearlyStop::Bool: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.\n\nsaveTrace::NTuple{4, Bool}: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the field .temp of the output  HFfinalVars of runHF. The types of relevant information are:\n\nSequence Information Corresponding field in HFtempVars\n1 orbital coefficient matrix(s) .Cs\n2 density matrix(s) .Ds, .shared.Dtots\n3 Fock matrix(s) .Fs\n4 unconverged Hartree-Fock energy(s) .Es, .shared.Etots\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nHFconfig(;HF::Union{Symbol, Val}=:RHF, \n          C0::Union{Tuple{AbstractMatrix}, NTuple{2, AbstractMatrix}, \n                    Symbol, Val}=:SAD, \n          SCF::SCFconfig=SCFconfig{Float64, 2, Tuple{Val{:ADIIS}, Val{:DIIS}}}(method, interval=(0.001, 1.0e-12), methodConfig, oscillateThreshold), \n          maxStep::Int=150, \n          earlyStop::Bool=true, \n          saveTrace::NTuple{4, Bool}=(false, false, false, true)) -> \nHFconfig\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> HFconfig();\n\njulia> HFconfig(HF=:UHF);\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.HFfinalVars","page":"Core Types","title":"Quiqbox.HFfinalVars","text":"HFfinalVars{T, D, HFT, NN, BN, HFTS} <: HartreeFockFinalValue{T, HFT}\n\nThe container of the final values after a Hartree-Fock SCF procedure.\n\n≡≡≡ Field(s) ≡≡≡\n\nEhf::T: Hartree-Fock energy of the electronic Hamiltonian.\n\nEnn::T: The nuclear repulsion energy.\n\nNs::NTuple{HFTS, Int}: The number(s) of electrons with same spin configurations(s). For  restricted closed-shell Hartree-Fock (RHF), the single element in .Ns represents both  spin-up electrons and spin-down electrons.\n\nnuc::NTuple{NN, String}: The nuclei in the studied system.\n\nnucCoords::NTuple{NN, NTuple{D, T}}: The coordinates of corresponding nuclei.\n\nC::NTuple{HFTS, Matrix{T}}: Orbital coefficient matrix(s) for one spin configuration.\n\nD::NTuple{HFTS, Matrix{T}}: Density matrix(s) for one spin configuration.\n\nF::NTuple{HFTS, Matrix{T}}: Fock matrix(s) for one spin configuration.\n\nEo::NTuple{HFTS, Vector{T}}: Energies of canonical orbitals.\n\noccu::NTuple{HFTS, NTuple{BN, Int}}: Occupations of canonical orbitals.\n\ntemp::NTuple{HFTS, [HFtempVars](@ref){T, HFT}}: the intermediate values stored during  the Hartree-Fock interactions.\n\nisConverged::Bool: Whether the SCF procedure is converged in the end.\n\nbasis::GTBasis{T, D, BN}: The basis set used for the Hartree-Fock approximation.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.HFtempVars","page":"Core Types","title":"Quiqbox.HFtempVars","text":"HFtempVars{T, HFT} <: HartreeFockintermediateData{T}\n\nThe container to store the intermediate values (only of the one spin configuration) for  each iteration during the Hartree-Fock SCF procedure.\n\n≡≡≡ Field(s) ≡≡≡\n\nN::Int: The number of electrons with the one spin function.\n\nCs::Vector{Matrix{T}}: Orbital coefficient matrices.\n\nDs::Vector{Matrix{T}}: Density matrices corresponding to only spin configuration.\n\nFs::Vector{Matrix{T}}: Fock matrices.\n\nEs::Vector{T}: Part of the Hartree-Fock energy corresponding to one spin configuration.\n\nshared.Dtots::Vector{Matrix{T}}: The total density matrices.\n\nshared.Etots::Vector{T}: The total Hartree-Fock energy.\n\nNOTE: For unrestricted Hartree-Fock, there are 2 HFtempVars being updated during the  iterations, and changing the field shared.Dtots or shared.Etots of one HFtempVars  will affect the other one's.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.SCFconfig","page":"Core Types","title":"Quiqbox.SCFconfig","text":"SCFconfig{T, L, MS<:NTuple{L, Val}} <: ImmutableParameter{T, SCFconfig}\n\nThe struct for self-consistent field (SCF) iteration configurations.\n\n≡≡≡ Field(s) ≡≡≡\n\nmethod::MS: The applied convergence methods. They can be specified as the elements inside  an NTuple{L, Symbol}, which is then input to the constructor of SCFconfig as the  positional argument methods. The available configuration(s) corresponding to each method  in terms of keyword arguments are:\n\nConvergence Method(s) Configuration(s) Keyword(s) Range(s)/Option(s) Default(s)\n:DD damping strength dampStrength [0, 1] 0.5\n:DIIS, :EDIIS, :ADIIS subspace size; DIIS-Method solver DIISsize; solver 1,2...; :LBFGS... 10; :LBFGS\n\nConvergence Methods\n\n:DD: Direct diagonalization of the Fock matrix.\n:DIIS: Direct inversion in the iterative subspace.\n:EDIIS: Energy-DIIS.\n:ADIIS: DIIS based on the augmented Roothaan–Hall (ARH) energy function.\n\nDIIS-Method Solvers\n\n:LBFGS: Limited-memory BFGS with box constraints.\n:LCM: Lagrange multiplier solver.\n:SPGB: Spectral Projected Gradient Method with box constraints.\n\ninterval::NTuple{L, T}: The stopping (or skipping) thresholds for required methods.\n\nmethodConfig::NTuple{L, Vector{<:Pair}}: The additional keywords arguments for each  method stored as Tuples of Pairs.\n\noscillateThreshold::T: The threshold for oscillating convergence.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nSCFconfig(methods::NTuple{L, Symbol}, intervals::NTuple{L, T}, \n          config::Dict{Int, <:AbstractVector{<:Pair}}=Dict(1=>Pair[]);\n          oscillateThreshold::Real=1.0e-6) where {L, T} -> \nSCFconfig{T, L}\n\nmethods and intervals are the convergence methods to be applied and their stopping  (or skipping) thresholds respectively. config specifies additional keyword argument(s)  for each methods by a Pair of which the key i::Int is for ith method and the pointed  AbstractVector{<:Pair} is the pairs of keyword arguments and their values respectively.\n\nSCFconfig(;threshold::AbstractFloat=(0.001, 1.0e-12), \n           oscillateThreshold::Real=defultOscThreshold) -> \nSCFconfig{Float64, 2}\n\nthreshold will update the stopping threshold of the default SCF configuration used in  HFconfig() with a new value. In other words, it updates the stopping threshold of  :1.0e-12.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> SCFconfig((:DD, :ADIIS, :DIIS), (1e-4, 1e-12, 1e-13), Dict(2=>[:solver=>:LCM]));\n\njulia> SCFconfig(threshold=1e-8, oscillateThreshold=1e-5)\nSCFconfig{Float64, 2, Tuple{Val{:ADIIS}, Val{:DIIS}}}(method, interval=(0.001, 1.0e-8), methodConfig, oscillateThreshold)\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.GridBox","page":"Core Types","title":"Quiqbox.GridBox","text":"GridBox(nGridPerEdge::Int, spacing, center=ntuple(_->eltype(spacing[begin])(0), 3); \n        canDiff::Bool=true, index::Int=0) -> \nGridBox{T, D}\n\nThe method of generating a cubic GridBox. Aside from the common arguments, nGridPerEdge  specifies the number of grids for every dimension. The dimension of the grid box is  determined by the dimension of center.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.GridBox-2","page":"Core Types","title":"Quiqbox.GridBox","text":"GridBox{T, D, NP, GPT<:SpatialPoint{T, D}} <: SpatialStructure{T, D}\n\nA container of multiple D-dimensional grid points.\n\n≡≡≡ Field(s) ≡≡≡\n\nspacing::NTuple{D, T}: The distance between adjacent grid points along each dimension.\n\nnPoint::Int: Total number of the grid points.\n\npoint::NTuple{NP, GPT}: The grid points represented by SpatialPoint.\n\nparam::Tuple{Vararg{ParamBox{T}}}: All the parameters in the GridBox.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGridBox(nGrids::NTuple{D, Int}, spacing::NTuple{D, Union{Array{T, 0}, T}}, \n        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_->T(0),Val(D)); \n        canDiff::NTuple{D, Bool}=ntuple(_->true, Val(D)), \n        index::NTuple{D, Int}=ntuple(_->0, Val(D))) where {T<:AbstractFloat, D} -> \nGridBox{T, D}\n\nGridBox(nGrids::NTuple{D, Int}, spacingForAllDim::Union{T, Array{T, 0}}, \n        center::Union{AbstractVector{T}, NTuple{D, T}}=ntuple(_->T(0), Val(D)); \n        canDiff::Bool=true, index::Int=0) where {T<:AbstractFloat, D} -> \nGridBox{T, D}\n\nConstruct a general D-dimensional GridBox.\n\n=== Positional argument(s) ===\n\nnGrids::NTuple{D, Int}: The numbers of grids along each dimension.\n\nspacing::NTuple{D, Union{Array{T, 0}, T}}: The spacing between grid points along each  dimension.\n\nspacingForAllDim::NTuple{D, Union{Array{T, 0}, T}}: A single spacing applied for all  dimensions.\n\ncenter::Union{AbstractVector{T}, NTuple{D, T}}: The coordinate of the geometric center of  the grid box.\n\n=== Keyword argument(s) ===\n\ncanDiff::NTuple{D, Bool}: Whether the ParamBoxes of each dimension stored in the  constructed GridBox will be marked as differentiable.\n\nindex::NTuple{D, Int}: The Index(s) that will be assigned to the shared input variable(s)  L of the stored ParamBoxes.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.GDconfig","page":"Core Types","title":"Quiqbox.GDconfig","text":"GDconfig{T, M, ST<:Union{Array{T, 0}, T}} <: ConfigBox{T, GDconfig, M}\n\nThe mutable container of configurations for the default gradient descent method used to  optimize parameters.\n\n≡≡≡ Field(s) ≡≡≡\n\nlineSearchMethod::M: The selected line search method to optimize the step size for each  gradient descent iteration. It can be any algorithm defined in the Julia package  LineSearches.jl, or itself  so that the step size will be fixed to a constant value during all the iterations.\n\ninitialStep::ST: The value of the initial step size in each iteration. If it's an  Array{T, 0}, then the final step size (optimized by lineSearchMethod) in current  interaction will be set as the initial step size for the next iteration.\n\nstepBound::NTuple{2, T}: The lower bound and upper bound of the step size to enforce  stepBound[begin] ≤ η ≤ stepBound[end] (where η is the step size in each iteration).  Whenever the size size is out of the boundary, it will be clipped to a bound value.\n\nscaleStepBound::Bool: Determine whether stepBound will be scaled so that the norm of  the gradient descent in each iteration is constrained within the initially configured  stepBound, i.e., stepBound[begin] ≤ norm(η*∇f) ≤ stepBound[end] (where ∇f is the  gradient of some function f in each iteration).\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nGDconfig(lineSearchMethod::M=BackTracking(), \n         initialStep::Union{Array{T, 0}, T}=ifelse(M==typeof(itself), 0.1, 1.0); \n         stepBound::NTuple{2, T}=convert.(eltype(initialStep), (0, Inf)), \n         scaleStepBound::Bool=ifelse(M==typeof(itself), true, false)) where \n        {M, T<:AbstractFloat} -> \nGDconfig{T, M, typeof(initialStep)}\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.POconfig","page":"Core Types","title":"Quiqbox.POconfig","text":"POconfig{T, M, CBT<:ConfigBox, TH<:Union{T, NTuple{2, T}}, \n         OM} <: ConfigBox{T, POconfig, M}\n\nThe mutable container of parameter optimization configurations.\n\n≡≡≡ Field(s) ≡≡≡\n\nmethod::Val{M}: The method that defines the objective function (e.g., HF energy) for the  optimization. Available values of M from Quiqbox are :HFenergy, :DirectRHFenergy.\n\nconfig::CBT: The configuration for the selected method. E.g., for :HFenergy it's  HFconfig.\n\ntarget::T: The target value of the objective function. The difference between the  last-step value and the target value will be used for convergence detection. If it's set to  NaN, the gradient of the latest step and the difference between the function values of  latest two steps are used instead.\n\nthreshold::TH: The error threshold/thresholds for the function value difference and  the gradient both/respectively to determine whether the optimization iteration has  converged. When it's (or either of them) set to NaN, there will be no corresponding  convergence detection, and when target is not NaN, the threshold for the gradient won't  be used because the gradient won't be part of the convergence criteria.\n\nmaxStep::Int: Maximum iteration steps allowed regardless if the iteration converges.\n\noptimizer::F: Applied parameter optimizer. The default setting is GDconfig().  To use a function implemented by the user as the optimizer, it should have the following  function signature: \n\noptimizer(f::Function, gf::Function, x0::Vector{T}) where {T} -> Function\n\nwhere f is the objective function to be minimized, gf is a function that returns  both the gradient and the returned value of f given the input value as a vector. x0 is  the initial input value. The output of optimizer, if we name it optimize!, should have  the corresponding function signature: \n\noptimize!(x::Vector{T}, gx::Vector{T}, fx::T) where {T}\n\nwhere x, gx, fx are the input value, the gradient, and the returned value of f  respectively at one step. In other words, (gx, fx) == (gx, f(x)) == gf(x). After  accepting those arguments, optimizer should update (i.e. mutate the elements of) x so  that f(x) will have lower returned value.\n\nsaveTrace::NTuple{4, Bool}: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the output of optimizeParams!. The types of relevant information are:\n\nSequence Corresponding Information\n1 function value of the applied method\n2 parameter value(s)\n3 function gradient with respect to the parameter(s)\n4 complete output of the applied method\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nPOconfig(;method::Union{Val{M}, Symbol}=HFenergy, \n          config::ConfigBox=Quiqbox.defaultOFconfigs[method], \n          target::T=NaN, \n          threshold::Union{T, NTuple{2, T}}=(5.0e-8, 5.0e-5), \n          maxStep::Int=200, \n          optimizer::Function=GDconfig()) where \n        {T, M} -> \nPOconfig{T, M}\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> POconfig();\n\njulia> POconfig(maxStep=100);\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.CanOrbital","page":"Core Types","title":"Quiqbox.CanOrbital","text":"CanOrbital{T, D, NN} <: AbstractSpinOrbital{T, D}\n\nThe spatial part (orbital) of a canonical spin-orbital (the set of which diagonalizes the  Fock matrix of a Hartree-Fock state) with its occupation information. This means the  maximal occupation number for the mode corresponding to the orbital (namely a canonical  orbital) equals 2. Please refer to genCanOrbitals for the construction of a  CanOrbital.\n\n≡≡≡ Field(s) ≡≡≡\n\nenergy::T: The eigen energy corresponding to the orbital.\n\nindex::Int: The index of the orbital within the same spin configuration.\n\nnuc::NTuple{NN, String}: The nuclei in the studied system.\n\nnucCoords::NTuple{NN, NTuple{D, T}}: The coordinates of corresponding nuclei.\n\noccu::NTuple{2, Array{Bool, 0}}: The occupations of two spin configurations.\n\norbital::GTBasisFuncs{T, D, 1}: The spatial orbital part.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.MatterByHF","page":"Core Types","title":"Quiqbox.MatterByHF","text":"MatterByHF{T, D, NN, BN, HFTS} <:MatterData{T, D}\n\nContainer of the electronic structure information of a quantum system.\n\n≡≡≡ Field(s) ≡≡≡\n\nEhf::T: Hartree-Fock energy of the electronic Hamiltonian.\n\nnuc::NTuple{NN, String}: The nuclei in the studied system.\n\nnucCoord::NTuple{NN, NTuple{D, T}}: The coordinates of corresponding nuclei.\n\nEnn::T: The nuclear repulsion energy.\n\nNs::NTuple{HFTS, Int}: The number(s) of electrons with same spin configurations(s). For  restricted closed-shell Hartree-Fock (RHF), the single element in .Ns represents both  spin-up electrons and spin-down electrons.\n\noccu::NTuple{HFTS, NTuple{BN, Int}}: Occupations of canonical orbitals.\n\noccuOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}}: The occupied canonical  orbitals.\n\nunocOrbital::NTuple{HFTS, Tuple{Vararg{CanOrbital{T, D, NN}}}} The unoccupied canonical  orbitals.\n\noccuC::NTuple{HFTS, Matrix{T}}: Coefficient matrix(s) of occupied canonical orbitals.\n\nunocC::NTuple{HFTS, Matrix{T}}: Coefficient matrix(s) of unoccupied canonical orbitals.\n\ncoreHsameSpin::NTuple{HFTS, Matrix{T}}: Core Hamiltonian(s) (one-body integrals) of the  canonical orbitals with same spin configuration(s).\n\neeIsameSpin::NTuple{HFTS, Array{T, 4}}: electron-electron interactions (two-body  integrals) of the canonical orbitals with same spin configuration(s).\n\neeIdiffSpin::Matrix{T}: Coulomb interactions between canonical orbitals with different  spins.\n\nbasis::GTBasis{T, D, BN}: The basis set used for the Hartree-Fock approximation.\n\n≡≡≡ Initialization Method(s) ≡≡≡\n\nMatterByHF(HFres::HFfinalVars{T, D, <:Any, NN, BN, HFTS}; \n           roundAtol::Real=getAtolVal(T)) where {T, D, NN, BN, HFTS} -> \nMatterByHF{T, D, NN, BN, HFTS}\n\nConstruct a MatterByHF from the result of a Hartree-Fock method HFres.  Each parameter stored in the constructed CanOrbitals in .occuOrbital and  .unocOrbital will be rounded to the nearest multiple of roundAtol; when roundAtol is  set to NaN, no rounding will be performed.\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Parameter-Optimization","page":"Parameter Optimization","title":"Parameter Optimization","text":"","category":"section"},{"location":"optimization/#Selectively-optimizing-parameters","page":"Parameter Optimization","title":"Selectively optimizing parameters","text":"","category":"section"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"In the Basis Sets section, we have briefly introduced ParamBox as the parameters embedded in containers such as BasisFunc and BasisFuncs. This means how we construct the basis set using the parameters will determine the parameter space for the basis set optimization. (For more information please refer to Constructing basis sets based on ParamBox.) Sometimes, we can select parameters for optimization to achieve higher efficiency.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"Here is an example of using GaussFunc and GridBox to quickly generate a grid-based basis set with only 3 independent parameters. One is the spacing L of the grid points that determines all the center coordinates of the basis functions; the other two are the exponent coefficient alpha and the contraction coefficient d.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"    push!(LOAD_PATH,\"../../src/\")\n    using Quiqbox","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"nuc = [\"H\", \"H\"];\n\nnucCoords = [[-0.7,0.0,0.0], [0.7,0.0,0.0]];\n\ngrid = GridBox(1, 3.0)\n\ngf1 = GaussFunc(0.7, 1.0);\n\nbs = genBasisFunc.(grid.point, Ref(gf1)) |> collect;","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After building the basis set, we need to use markParams! to mark all the unique parameters that can also be optimized later:","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"pars = markParams!(bs, true)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"When markParams!'s second argument is set to true, it will return only the ParamBoxes that have unique independent variables. Thus, the length of pars is 3 for the aforementioned three independent parameters, despite the basis set having eight basis functions with a total of 40 parameters. However, if we take a step further, we can remove the ParamBox representing d since each basis function here is just one same Gaussian function. Thus, input the rest parameters (along with other necessary arguments) into optimizeParams! and we will have a more efficient optimization iteration: ","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"parsPartial = pars[1:2];\n\nisConverged, Es = optimizeParams!(parsPartial, bs, nuc, nucCoords, POconfig(maxStep=10));","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After the optimization, you can check the original bs and find that the inside parameters are changed as well. This is because the ! in the function name indicates that optimizeParams! is a function that modifies its arguments.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"getParams(bs)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"If you want to go through the above example by yourself, you can find the script here.","category":"page"},{"location":"coreFunction/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nPages   = [\"Library.jl\", \"Mapping.jl\", \"Parameters.jl\", \"Basis.jl\", \"HartreeFock.jl\", \n           \"Differentiation.jl\", \"Box.jl\", \"Optimization.jl\", \"Matter.jl\", \n           \"Integrals/OneBody.jl\", \"Integrals/TwoBody.jl\", \"Integrals/Core.jl\"]\nOrder   = [:function]","category":"page"},{"location":"coreFunction/#Quiqbox.getCharge-Tuple{Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}} where NNMO}","page":"Core Functions","title":"Quiqbox.getCharge","text":"getCharge(nucs::Union{AbstractVector{String}, Tuple{Vararg{String}}}) -> Int\n\nReturn the total electric charge (in 𝑒) of the input nuclei.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.orbitalLin","page":"Core Functions","title":"Quiqbox.orbitalLin","text":"orbitalLin(subshell::String, D::Int=3) -> Tuple{Vararg{NTuple{3, Int}}}\n\nReturn all the possible angular momentum configuration(s) within the input subshell of  D dimension.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.changeMapping-Union{Tuple{ParamBox{T, V}}, Tuple{V}, Tuple{T}, Tuple{ParamBox{T, V}, Function}, Tuple{ParamBox{T, V}, Function, Symbol}} where {T, V}","page":"Core Functions","title":"Quiqbox.changeMapping","text":"changeMapping(pb::ParamBox{T, V}, mapFunction::Function=itself, outSym::Symbol=V; \n              canDiff::Union{Bool, Array{Bool, 0}}=isDiffParam(pb)) where {T, V} -> \nParamBox{T, outSym}\n\nChange the mapping function of pb. The symbol of the output variable of the returned  ParamBox can be specified by outSym, and its differentiability is determined by  canDiff.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.dataOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.dataOf","text":"dataOf(pb::ParamBox{T}) where {T} -> Pair{Array{T, 0}, Symbol}\n\nReturn the Pair of the input variable and its symbol.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.disableDiff!-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.disableDiff!","text":"disableDiff!(pb::ParamBox) -> Bool\n\nMark pb as \"non-differentiable\" and then return false.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.enableDiff!-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.enableDiff!","text":"enableDiff!(pb::ParamBox) -> Bool\n\nMark pb as \"differentiable\" and then return true.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.fullVarCopy-Union{Tuple{ParamBox{<:Any, V}}, Tuple{V}} where V","page":"Core Functions","title":"Quiqbox.fullVarCopy","text":"fullVarCopy(pb::T) where {T<:ParamBox} -> T\n\nA shallow copy of the input ParamBox.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.inSymOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.inSymOf","text":"inSymOf(pb::ParamBox) -> Symbol\n\nReturn the symbol of the input variable of pb.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.inValOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.inValOf","text":"inValOf(pb::ParamBox{T}) where {T} -> T\n\nReturn the value of the input variable of pb. Equivalent to pb[].\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.indVarOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.indVarOf","text":"indVarOf(pb::ParamBox{T}) -> Pair{}\n\nReturn (the name and the value of) the independent variable tied to pb. Specifically,  return the input variable stored in pb when pb is marked as differentiable; return the  output variable of pb when pb is marked as non-differentiable. Thus, it is the variable  pb represents to differentiate any (differentiable) function of ParamBoxes.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.isDiffParam-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.isDiffParam","text":"isDiffParam(pb::ParamBox) -> Bool\n\nReturn the Boolean value of whether pb is differentiable with respect to its input  variable.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.isInSymEqual-Tuple{ParamBox, Symbol}","page":"Core Functions","title":"Quiqbox.isInSymEqual","text":"isInSymEqual(pb::ParamBox, sym::Symbol) -> Bool\n\nReturn the Boolean value of whether the symbol of  pb's input variable equals sym.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.isOutSymEqual-Union{Tuple{V}, Tuple{ParamBox{<:Any, V}, Symbol}} where V","page":"Core Functions","title":"Quiqbox.isOutSymEqual","text":"isOutSymEqual(::ParamBox, sym::Symbol) -> Bool\n\nReturn the Boolean value of whether the symbol of  pb's output variable equals sym.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.mapOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.mapOf","text":"mapOf(pb::ParamBox) -> Function\n\nReturn the mapping function of pb.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.outSymOf-Union{Tuple{ParamBox{<:Any, V}}, Tuple{V}} where V","page":"Core Functions","title":"Quiqbox.outSymOf","text":"outSymOf(pb::ParamBox) -> Symbol\n\nReturn the symbol of the output variable of pb.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.outValCopy-Union{Tuple{ParamBox{<:Any, V}}, Tuple{V}} where V","page":"Core Functions","title":"Quiqbox.outValCopy","text":"outValCopy(pb::ParamBox{T, V}) where {T} -> ParamBox{T, V, typeof(itself)}\n\nReturn a new ParamBox of which the input variable's value is equal to the output  variable's value of pb.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.outValOf-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.outValOf","text":"outValOf(pb::ParamBox) -> Number\n\nReturn the value of the output variable of pb. Equivalent to pb().\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.toggleDiff!-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.toggleDiff!","text":"toggleDiff!(pb::ParamBox) -> Bool\n\nToggle the differentiability of the input pb and then return the updated boolean value.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.absorbNormFactor-Tuple{BasisFunc{<:Any, 3}}","page":"Core Functions","title":"Quiqbox.absorbNormFactor","text":"absorbNormFactor(b::BasisFunc{T, 3, 𝑙, GN, PT}) where {T, 𝑙, GN, PT} -> \nFloatingGTBasisFuncs{T, 3, 𝑙, GN, PT}\n\nabsorbNormFactor(b::BasisFuncs{T, 3, 𝑙, GN, PT}) where {T, 𝑙, GN, PT} -> \nVector{<:FloatingGTBasisFuncs{T, 3, 𝑙, GN, PT}}\n\nIf hasNormFactor(b) == true, absorb the normalization factor of each Gaussian-type  orbital inside b into the orbital's corresponding contraction coefficient and then set  .normalizeGTO of b to false. Otherwise, directly return b when it's a BasisFunc,  or [b] when it's a BasisFuncs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.absorbNormFactor-Tuple{Quiqbox.BasisFuncMix{var\"#s59\", 3, BN, BFT} where {var\"#s59\", BN, BFT<:(BasisFunc{var\"#s59\", 3})}}","page":"Core Functions","title":"Quiqbox.absorbNormFactor","text":"absorbNormFactor(bfm::BasisFuncMix{T, 3}) where {T} -> GTBasisFuncs{T, 3}\n\nApply absorbNormFactor to every one of the BasisFunc inside bfm and them sum them  over.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.absorbNormFactor-Union{Tuple{AbstractVector{<:GTBasisFuncs{T, 3}}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.absorbNormFactor","text":"absorbNormFactor(bs::AbstractVector{<:GTBasisFuncs{T, 3}}) where {T} -> \nAbstractVector{<:GTBasisFuncs{T, 3}}\n\nabsorbNormFactor(bs::Tuple{Vararg{GTBasisFuncs{T, 3}}}) where {T} -> \nTuple{Vararg{GTBasisFuncs{T, 3}}}\n\nApply absorbNormFactor to every element inside bs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.add-Tuple{BasisFuncs{T, D, 𝑙, GN, PT, 1} where {T, D, 𝑙, GN, PT}}","page":"Core Functions","title":"Quiqbox.add","text":"add(b1::CompositeGTBasisFuncs{T, D, <:Any, 1}, \n    b2::CompositeGTBasisFuncs{T, D, <:Any, 1}; \n    roundAtol::Real=getAtolVal(T)) where {T, D} -> \nCompositeGTBasisFuncs{T, D, <:Any, 1}\n\nAddition between two CompositeGTBasisFuncs{T, D, <:Any, 1} such as BasisFunc  and BasisFuncMix. roundAtol specifies the absolute approximation tolerance of  comparing parameters stored in each CompositeGTBasisFuncs to determine whether they are  treated as \"equal\"; each parameter in the returned CompositeGTBasisFuncs is set to the  nearest exact multiple of 0.5atol. When roundAtol is set to NaN, there will be no  approximation nor rounding. This function can be called using + syntax with the keyword  argument set to it default value. \n\nNOTE: For the ParamBox (stored in the input  arguments) that are marked as non-differentiable, they will be fused together if possible  to generate new ParamBox(s) no longer linked to the input variable stored in them.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> bf1 = genBasisFunc([1.,1.,1.], (2.,1.));\n\njulia> bf2 = genBasisFunc([1.,1.,1.], (2.,2.));\n\njulia> bf3 = bf1 + bf2;\n\njulia> bf3.gauss[1].con() == bf1.gauss[1].con() + bf2.gauss[1].con()\ntrue\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.assignCenInVal!-Tuple{FloatingGTBasisFuncs, AbstractVector{<:Real}}","page":"Core Functions","title":"Quiqbox.assignCenInVal!","text":"assignCenInVal!(b::FloatingGTBasisFuncs{T, D}, center::AbstractVector{<:Real}) -> \nSpatialPoint{T, D}\n\nChange the input value of the ParamBox stored in b.center (meaning the output value  will also change according to the mapping function). Then, return the altered center.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.centerCoordOf-Tuple{FloatingGTBasisFuncs}","page":"Core Functions","title":"Quiqbox.centerCoordOf","text":"centerCoordOf(bf::FloatingGTBasisFuncs{T}) where {T} -> Vector{T}\n\nReturn the center coordinate of the input FloatingGTBasisFuncs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.centerNumOf-Union{Tuple{CompositeGTBasisFuncs{<:Any, <:Any, BN}}, Tuple{BN}} where BN","page":"Core Functions","title":"Quiqbox.centerNumOf","text":"centerNumOf(bf::CompositeGTBasisFuncs) -> Int\n\nReturn the number of center (coordinates) associated with the input CompositeGTBasisFuncs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.centerOf-Tuple{FloatingGTBasisFuncs}","page":"Core Functions","title":"Quiqbox.centerOf","text":"centerOf(bf::FloatingGTBasisFuncs{T, D}) where {T, D} -> SpatialPoint{T, D}\n\nReturn the center of the input FloatingGTBasisFuncs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.coordOf-Union{Tuple{SpatialPoint{T}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.coordOf","text":"coordOf(sp::SpatialPoint{T}) where {T} -> Vector{T}\n\nGet the coordinate represented by the input SpatialPoint.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.copyBasis","page":"Core Functions","title":"Quiqbox.copyBasis","text":"copyBasis(b::GaussFunc, copyOutVal::Bool=true) -> GaussFunc\n\ncopyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -> CompositeGTBasisFuncs\n\nReturn a copy of the input basis. If copyOutVal is set to true, then only the output  value(s) of the ParamBox(s) stored in b will be copied, i.e.,  outValCopy is used, otherwise fullVarCopy is used.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> f(x)=x^2; e = genExponent(3.0, f)\nParamBox{Float64, :α, …}{1}[𝛛][x_α]⟦→⟧[9.0]\n\njulia> c = genContraction(2.0)\nParamBox{Float64, :d, …}{0}[∂][d]⟦=⟧[2.0]\n\njulia> gf1 = GaussFunc(e, c);\n\njulia> gf2 = copyBasis(gf1)\nGaussFunc{Float64, …}{0, 0}[∂∂][{9.0, 2.0}]\n\njulia> gf1.xpn() == gf2.xpn()\ntrue\n\njulia> (gf1.xpn[] |> gf1.xpn.map) == gf2.xpn[]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.decompose","page":"Core Functions","title":"Quiqbox.decompose","text":"decompose(bf::CompositeGTBasisFuncs{T, D}, splitGaussFunc::Bool=false) -> \nMatrix{<:BasisFunc{T, D}}\n\nDecompose a CompositeGTBasisFuncs into a Matrix of BasisFuncs. The sum of  each column represents one orbital of the input basis function(s). If splitGaussFunc is  true, then each column consists of the BasisFuncs with only 1 GaussFunc.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.dimOf-Union{Tuple{Quiqbox.DimensionalParamContainer{<:Any, D}}, Tuple{D}} where D","page":"Core Functions","title":"Quiqbox.dimOf","text":"dimOf(::DimensionalParamContainer) -> Int\n\nReturn the spatial dimension of the input parameterized container such as  AbstractSpatialPoint and QuiqboxBasis.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.gaussCoeffOf-Union{Tuple{FloatingGTBasisFuncs{T, <:Any, <:Any, GN}}, Tuple{GN}, Tuple{T}} where {T, GN}","page":"Core Functions","title":"Quiqbox.gaussCoeffOf","text":"gaussCoeffOf(b::FloatingGTBasisFuncs{T}) -> Matrix{T}\n\nReturn the exponent and contraction coefficients of each GaussFunc (in each row  of the returned Matrix) inside b.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.gaussCoeffOf-Union{Tuple{GaussFunc{T}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.gaussCoeffOf","text":"gaussCoeffOf(gf::GaussFunc{T}) -> Matrix{T}\n\nReturn the exponent and contraction coefficients of gf.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T<:AbstractFloat}","page":"Core Functions","title":"Quiqbox.genBFuncsFromText","text":"genBFuncsFromText(content::String; \n                  adjustContent::Bool=false, \n                  adjustFunction::Function=sciNotReplace, \n                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, \n                  center::Union{AbstractArray{T}, \n                                NTuple{D, T}, \n                                NTuple{D, ParamBox{T}}, \n                                SpatialPoint{T, D}, \n                                Missing}=(NaN, NaN, NaN), \n                  unlinkCenter::Bool=false, \n                  normalizeGTO::Union{Bool, Missing}=\n                                ifelse(adjustContent, true, missing)) where \n                 {D, T<:AbstractFloat} -> \nArray{<:FloatingGTBasisFuncs, 1}\n\nGenerate a basis set from content which is either a basis set String in Gaussian format  or the output from genBasisFuncText. For the former, adjustContent needs to be set to  true. adjustFunction is only applied when adjustContent=true, which in default is a  function used to detect and convert the format of the scientific notation in content.\n\nexcludeFirstNlines and excludeLastNlines are used to exclude first or last few lines of  content if intended. center is used to assign a center coordinate for all the basis  functions from content; when it's set to missing, it will try to read the center  information in content, and leave the center as [NaN, NaN, Nan] if one cannot be found  for each corresponding FloatingGTBasisFuncs. If unlinkCenter = true, the center of each  FloatingGTBasisFuncs is a Base.deepcopy of the input center. Otherwise, they share  the same underlying data so changing the value of one will affect others. If the center  coordinate is included in content, it should be right above the subshell information for  the FloatingGTBasisFuncs. E.g.:\n\n\"\"\"\nX        1.0                       0.0                       0.0                \nS    1   1.0   false\n         2.0                       1.0\n\"\"\"\n\nFinally, normalizeGTO specifies the field .normalizeGTO of the generated  FloatingGTBasisFuncs. If it's set to missing (in default), the normalization  configuration of each FloatingGTBasisFuncs will depend on content, so different basis  functions may have different normalization configurations. However, when it's set to a  Bool value, .normalizeGTO of all the generated basis functions will be set to that  value.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genBasisFunc-Union{Tuple{𝑙}, Tuple{GN}, Tuple{T}, Tuple{D}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}, LTuple{D, 𝑙}}} where {D, T, GN, 𝑙}","page":"Core Functions","title":"Quiqbox.genBasisFunc","text":"genBasisFunc(center::Union{AbstractVector{T}, Tuple{Vararg{T}}, SpatialPoint, Missing}, \n             args..., kws...) where {T<:Union{AbstractFloat, ParamBox}} -> \nUnion{FloatingGTBasisFuncs{T}, Vector{<:FloatingGTBasisFuncs{T}}}\n\nThe constructor of FloatingGTBasisFuncs, but it also returns different kinds of  collections (Vector) of them based on the input arguments. The first argument center  specifies the center coordinate of the generated FloatingGTBasisFuncs, and can be left as  missing for later assignment.\n\nNOTE: Although not marked in the return types, if any allowed input argument can lead  to a FloatingGTBasisFuncs with no GaussFunc stored inside of it, e.g.,  genBasisFunc([1.0, 2.0, 3.0], ()), a Quiqbox.EmptyBasisFunc will be generated instead.\n\n≡≡≡ Method 1 ≡≡≡\n\ngenBasisFunc(center, GsOrCoeffs, Ls; normalizeGTO=false) -> \nFloatingGTBasisFuncs\n\n=== Positional argument(s) ===\n\nGsOrCoeffs::Union{     AbstractGaussFunc{T1},      AbstractVector{<:AbstractGaussFunc{T1}},      Tuple{Vararg{AbstractGaussFunc{T1}}},      NTuple{2, Union{T1, Array{T1, 0}, ParamBox{T1}},      NTuple{2, AbstractVector{<:Union{T1, Array{T1, 0}, ParamBox{T1}}}} } where {T1<:AbstractFloat}: A collection of concentric GaussFunc that will be used to  construct the basis function. To simplify the procedure, it can also be in the form of a  NTuple{2} of the exponent coefficient(s)::Union{AbstractFloat,  AbstractVector{<:AbstractFloat}} and contraction coefficients::Union{AbstractFloat,  AbstractVector{<:AbstractFloat}} of the GaussFunc(s) to be input.\n\nLs::Union{     T2,      AbstractVector{T2},      NTuple{<:Any, T2} } where {T2<:Union{NTuple{D, Int}, LTuple{D}} where {D}}: A collection of at least one  angular momentum configuration within the same subshell, in the Cartesian coordinate  representation. E.g., for p shell it can be set to ((1,0,0), (0,1,0)). This will  determine the number of spatial orbitals and their angular momentum respectively to be  stored in the output FloatingGTBasisFuncs.\n\n=== Keyword argument(s) ===\n\nnormalizeGTO::Bool: Determine whether the inside GaussFunc(s) will be normalized in the  during the calculation. \n\n=== Example(s) ===\n\njulia> genBasisFunc([0.,0.,0.], GaussFunc(2., 1.), (0, 1, 0))\nBasisFunc{Float64, 3, 1, 1, …}{0, 0, 0}[(0.0, 0.0, 0.0)][X⁰Y¹Z⁰]\n\n≡≡≡ Method 2 ≡≡≡\n\ngenBasisFunc(center, GsOrCoeffs, subshell=\"s\"; normalizeGTO=false) -> \nFloatingGTBasisFuncs\n\ngenBasisFunc(center, GsOrCoeffs, subshell, lFilter; normalizeGTO=false) -> \nFloatingGTBasisFuncs\n\n=== Positional argument(s) ===\n\nsubshell::Union{String, Symbol}: The third argument of the constructor can also be the  name of a subshell, which will make sure the output is a BasisFuncs that contains the  spatial orbitals that fully occupy the subshell.\n\nlFilter::Tuple{Vararg{Bool}}: When this 4th argument is provided, it can determine the  orbital(s) to be included based on the given subshell. The order of the corresponding  orbital angular momentum(s) can be inspected using function orbitalLin.\n\n=== Keyword argument(s) ===\n\nnormalizeGTO::Bool: Same as the one defined in method 1.\n\n=== Example(s) ===\n\njulia> genBasisFunc([0.,0.,0.], (2., 1.), \"p\")\nBasisFuncs{Float64, 3, 1, 1, …}{0, 0, 0}[(0.0, 0.0, 0.0)][3/3]\n\njulia> genBasisFunc([0.,0.,0.], (2., 1.5), \"p\", (true, false, true))\nBasisFuncs{Float64, 3, 1, 1, …}{0, 0, 0}[(0.0, 0.0, 0.0)][2/3]\n\n≡≡≡ Method 3 ≡≡≡\n\ngenBasisFunc(center, BSkey, atm=\"H\"; unlinkCenter=false) -> \nVector{<:FloatingGTBasisFuncs}\n\n=== Positional argument(s) ===\n\nBSkey::String: The name of an existed atomic basis set. The supported options are in  [\"STO-2G\", \"STO-3G\", \"STO-6G\", \"3-21G\", \"6-31G\", \"cc-pVDZ\", \"cc-pVTZ\", \"cc-pVQZ\"].\n\natm::Union{String, Symbol}: The name of the atom corresponding to the chosen basis set.  The supported options are in [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\", \"Na\", \"Mg\", \"Al\", \"Si\", \"P\", \"S\", \"Cl\", \"Ar\", \"K\", \"Ca\"].\n\n=== Keyword argument(s) ===\n\nunlinkCenter::Bool: Determine whether the centers of constructed FloatingGTBasisFuncs  are linked to each other. If set to true, the center of each FloatingGTBasisFuncs is a  Base.deepcopy of each other. Otherwise, they share the same underlying data so changing  the value of one will affect others.\n\n=== Example(s) ===\n\njulia> genBasisFunc([0.,0.,0.], \"6-31G\");\n\njulia> genBasisFunc([0.,0.,0.], \"STO-3G\", \"Li\");\n\n≡≡≡ Method 4 ≡≡≡\n\ngenBasisFunc(b::FloatingGTBasisFuncs{T, D}, newFieldVal) where {T, D} -> \nFloatingGTBasisFuncs{T, D}\n\n=== Positional argument(s) ===\n\nnewFieldVal::Union{     SpatialPoint{T, D},      Tuple{AbstractGaussFunc{T}, Vararg{AbstractGaussFunc{T}}},      Tuple{LTuple{D, 𝑙}, Vararg{LTuple{D, 𝑙}}} where 𝑙,      Bool } where {T<:AbstractFloat, D}: Any one of the fields inside a FloatingGTBasisFuncs  except param.\n\nThis method outputs a FloatingGTBasisFuncs that has identical fields as the input one  except the field that can be replaced by newFieldVal (and param if the replaced field  contains ParamBox).\n\n=== Example(s) ===\n\njulia> bf1 = genBasisFunc([1., 2., 3.], (2.0, 1.0), (0, 0, 0));\n\njulia> bf2 = genBasisFunc([1., 2., 3.], (2.0, fill(1.0)), (0, 0, 1));\n\njulia> bf1 = genBasisFunc(bf1, bf2.l);\n\njulia> hasEqual(bf1, bf2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genBasisFuncText-Union{Tuple{AbstractVector{<:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.genBasisFuncText","text":"genBasisFuncText(bs::Union{AbstractVector{<:FloatingGTBasisFuncs{T, D}}, \n                           Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}; \n                 norm::Real=1.0, printCenter::Bool=true, \n                 groupCenters::Bool=true, roundDigits::Int=-1) where {T, D} -> \nVector{String}\n\nGenerate the text of input basis set (consisting of FloatingGTBasisFuncs). norm is the  additional normalization factor. groupCenters determines whether the function will group  the basis functions with same center together.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genBasisFuncText-Union{Tuple{FloatingGTBasisFuncs{T, D}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.genBasisFuncText","text":"genBasisFuncText(bf::FloatingGTBasisFuncs; \n                 norm::Real=1.0, printCenter::Bool=true, roundDigits::Int=-1) -> String\n\nGenerate the text of input FloatingGTBasisFuncs. norm is the additional normalization  factor. If printCenter is true, the center coordinate will be added to the first line  of the output String. roundDigits specifies the rounding digits for the parameters  inside bf; when set to negative, no rounding will be performed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genContraction-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.genContraction","text":"genContraction(pb::ParamBox{T}) where {T<:AbstractFloat} -> ParamBox{T, :d}\n\nConvert a ParamBox to an exponent coefficient parameter.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genContraction-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T<:AbstractFloat","page":"Core Functions","title":"Quiqbox.genContraction","text":"genContraction(d::T, mapFunction::Function=itself; \n               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), \n               inSym::Symbol=x_d) where {T<:AbstractFloat} -> \nParamBox{T, :d}\n\ngenContraction(d::Array{T, 0}, mapFunction::Function=itself; \n               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), \n               inSym::Symbol=x_d) where {T<:AbstractFloat} -> \nParamBox{T, :d}\n\ngenContraction(dData::Pair{Array{T, 0}, Symbol}, \n               mapFunction::Function=itself; \n               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true)) where \n              {T<:AbstractFloat} -> \nParamBox{T, :d}\n\nConstruct a contraction coefficient given a value or variable (with its symbol).  mapFunction, canDiff, and inSym work the same way as in a general constructor of a  ParamBox.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genExponent-Tuple{ParamBox}","page":"Core Functions","title":"Quiqbox.genExponent","text":"genExponent(pb::ParamBox{T}) where {T<:AbstractFloat} -> ParamBox{T, :α}\n\nConvert a ParamBox to the container of an exponent coefficient.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genExponent-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T<:AbstractFloat","page":"Core Functions","title":"Quiqbox.genExponent","text":"genExponent(e::T, mapFunction::Function=itself; \n            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), \n            inSym::Symbol=x_α) where {T<:AbstractFloat} -> \nParamBox{T, :α}\n\ngenExponent(e::Array{T, 0}, mapFunction::Function=itself; \n            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), \n            inSym::Symbol=x_α) where {T<:AbstractFloat} -> \nParamBox{T, :α}\n\ngenExponent(eData::Pair{Array{T, 0}, Symbol}, \n            mapFunction::Function=itself; \n            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true)) where \n           {T<:AbstractFloat} -> \nParamBox{T, :α}\n\nConstruct an exponent coefficient given a value or variable (with its symbol).  mapFunction, canDiff, and inSym work the same way as in a general constructor of a  ParamBox.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genSpatialPoint","page":"Core Functions","title":"Quiqbox.genSpatialPoint","text":"genSpatialPoint(point::Union{NTuple{D, Union{T, Array{T, 0}, ParamBox{T}}}, \n                             AbstractVector}, \n                marker::Symbol=:point) where {D, T<:AbstractFloat} -> \nSpatialPoint{T, D}\n\nConstruct a SpatialPoint from a collection of coordinate components. ≡≡≡ Example(s) ≡≡≡\n\njulia> v1 = [1.0, 2.0, 3.0];\n\njulia> p1 = genSpatialPoint(v1, :p1)\nSpatialPoint{Float64, …}{0, 0, 0}[∂∂∂][(1.0, 2.0, 3.0)]\n\njulia> p1.marker\n:p1\n\njulia> v2 = [fill(1.0), 2.0, 3.0];\n\njulia> p2 = genSpatialPoint(v2); p2[1]\nParamBox{Float64, :X, …}{0}[∂][X]⟦=⟧[1.0]\n\njulia> v2[1][] = 1.2\n1.2\n\njulia> p2[1]\nParamBox{Float64, :X, …}{0}[∂][X]⟦=⟧[1.2]\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.genSpatialPoint-Union{Tuple{Tuple{ParamBox{T}, Vararg{ParamBox{T}, D}}}, Tuple{T}, Tuple{D}, Tuple{Tuple{ParamBox{T}, Vararg{ParamBox{T}, D}}, Symbol}} where {D, T}","page":"Core Functions","title":"Quiqbox.genSpatialPoint","text":"genSpatialPoint(point::Union{Tuple{ParamBox{T}, Vararg{ParamBox{T}}}, \n                             AbstractVector{<:ParamBox{T}}}, \n                marker::Symbol=:point) where {T} -> \nSpatialPoint{T}\n\nConvert a collection of ParamBoxs to a SpatialPoint.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genSpatialPoint-Union{Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Int64}, Tuple{Pair{Array{T, 0}, Symbol}, Int64, Function}} where T<:AbstractFloat","page":"Core Functions","title":"Quiqbox.genSpatialPoint","text":"genSpatialPoint(comp::T, compIndex::Int, \n                mapFunction::Function=itself; \n                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true), \n                inSym::Symbol=(:x_X, :x_Y, :x_Z)[compIndex]) where {T<:AbstractFloat} -> \nParamBox{T}\n\ngenSpatialPoint(comp::Array{T, 0}, compIndex::Int, \n                mapFunction::Function=itself; \n                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true), \n                inSym::Symbol=(:x_X, :x_Y, :x_Z)[compIndex]) where {T<:AbstractFloat} -> \nParamBox{T}\n\ngenSpatialPoint(compData::Pair{Array{T, 0}, Symbol}, compIndex::Int, \n                mapFunction::Function=itself; \n                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true)) -> \nParamBox{T}\n\nConstruct a ParamBox as the compIndex th component of a SpatialPoint  given a value or variable (with its symbol). mapFunction, canDiff, and inSym work  the same way as in a general constructor of a ParamBox.\n\ngenSpatialPoint(point::ParamBox{T}, compIndex::Int) where {T<:AbstractFloat} -> \nParamBox{T}\n\nConvert a ParamBox to the compIndex th component of a SpatialPoint.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> genSpatialPoint(1.2, 1)\nParamBox{Float64, :X, …}{0}[∂][X]⟦=⟧[1.2]\n\njulia> pointY1 = fill(2.0);\n\njulia> Y1 = genSpatialPoint(pointY1, 2)\nParamBox{Float64, :Y, …}{0}[∂][Y]⟦=⟧[2.0]\n\njulia> pointY1[] = 1.5;\n\njulia> Y1\nParamBox{Float64, :Y, …}{0}[∂][Y]⟦=⟧[1.5]\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.getNormFactor-Union{Tuple{FloatingGTBasisFuncs{T, 3, 𝑙, GN, PT, 1} where PT}, Tuple{GN}, Tuple{𝑙}, Tuple{T}} where {T, 𝑙, GN}","page":"Core Functions","title":"Quiqbox.getNormFactor","text":"getNormFactor(b::FloatingGTBasisFuncs{T, 3}) where {T} -> Array{T}\n\nReturn the normalization factors of the Gaussian-type orbitals (GTO) inside the input b.  Each column corresponds to one orbital.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.getParams","page":"Core Functions","title":"Quiqbox.getParams","text":"getParams(pbc::ParamBox, symbol::Union{Symbol, Missing}=missing) -> \nUnion{ParamBox, Nothing}\n\ngetParams(pbc::ParameterizedContainer, symbol::Union{Symbol, Missing}=missing) -> \nAbstractVector{<:ParamBox}\n\ngetParams(pbc::Union{AbstractArray{<:T}, Tuple{T, Vararg{T}}}, \n          symbol::Union{Symbol, Missing}=missing) where {T<:QuiqboxContainer} -> \nAbstractVector{<:ParamBox}\n\nReturn the parameter(s) stored in the input container. If symbol is set to missing,  then return all the parameter(s). If it's set to a Symbol tied to a parameter, for  example :α₁, the function will match any pb::ParamBox such that  indVarOf(pb)[begin] == :α₁. If it's set to a Symbol without any subscript,  for example :α, the function will match it with all the pbs such that  string(indVarOf(pb)[begin]) contains 'α'. If the first argument is a collection, its  entries must be ParamBox containers.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.hasNormFactor-Tuple{FloatingGTBasisFuncs}","page":"Core Functions","title":"Quiqbox.hasNormFactor","text":"hasNormFactor(b::FloatingGTBasisFuncs) -> Bool\n\nIndicate whether b' is be treated as having additional normalization factor(s) which its  Gaussian-type orbital(s) will be multiplied by during any calculation.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.lOf-Union{Tuple{FloatingGTBasisFuncs{<:Any, <:Any, 𝑙}}, Tuple{𝑙}} where 𝑙","page":"Core Functions","title":"Quiqbox.lOf","text":"lOf(::FloatingGTBasisFuncs) -> Int\n\nReturn the total orbital angular momentum quantum number (in Cartesian coordinate  representation).\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.markParams!-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}, Tuple{Union{AbstractVector{T}, T}, Bool}} where T<:Quiqbox.ParameterizedContainer","page":"Core Functions","title":"Quiqbox.markParams!","text":"markParams!(b::Union{AbstractVector{T}, T, Tuple{T, Vararg{T}}}, \n            filterMapping::Bool=false) where {T<:ParameterizedContainer} -> \nVector{<:ParamBox}\n\nMark the parameters (ParamBox) in b. The parameters that hold the same  independent variable (in other words, considered identical in the differentiation  procedure) will be marked with same index. filterMapping determines whether filtering out  (i.e. not return) the extra ParamBoxes that hold the same independent variables but  represent different output variables. The independent variable held by a ParamBox can be  inspected using indVarOf.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.mergeBasisFuncsIn-Union{Tuple{Union{Tuple{GTBasisFuncs{T, D}, Vararg{GTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:GTBasisFuncs{T, D}}} where NNMO}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.mergeBasisFuncsIn","text":"mergeBasisFuncsIn(bs::Union{AbstractVector{<:GTBasisFuncs{T, D}}, \n                            Tuple{Vararg{GTBasisFuncs{T, D}}}}; \n                  roundAtol::Real=NaN) where {T, D} -> \nVector{<:GTBasisFuncs{T, D}}\n\nTry merging multiple FloatingGTBasisFuncs (if there's any) in bs into  FloatingGTBasisFuncs{T, D, <:Any, <:Any, <:Any, ON} where ON > 1 if possible and then  return the resulted basis collection. If no merging is performed, then the returned  collection is same as (but not necessarily identical to) bs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{𝑙2}, Tuple{𝑙1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, 𝑙1, 1, PT1}, BasisFunc{T, D, 𝑙2, 1, PT2}}} where {T, D, 𝑙1, 𝑙2, PT1, PT2}","page":"Core Functions","title":"Quiqbox.mul","text":"mul(a1::Real, a2::CompositeGTBasisFuncs{T, D, <:Any, 1}; \n    normalizeGTO::Union{Bool, Missing}=missing, \n    roundAtol::Real=getAtolVal(T)) where {T, D} -> \nCompositeGTBasisFuncs{T, D, <:Any, 1}\n\nmul(a1::CompositeGTBasisFuncs{T, D, <:Any, 1}, a2::Real; \n    normalizeGTO::Union{Bool, Missing}=missing, \n    roundAtol::Real=getAtolVal(T)) where {T, D} -> \nCompositeGTBasisFuncs{T, D, <:Any, 1}\n\nmul(a1::CompositeGTBasisFuncs{T, D, <:Any, 1}, \n    a2::CompositeGTBasisFuncs{T, D, <:Any, 1}; \n    normalizeGTO::Union{Bool, Missing}=missing, \n    roundAtol::Real=getAtolVal(T)) where {T, D} -> \nCompositeGTBasisFuncs{T, D, <:Any, 1}\n\nMultiplication between two CompositeGTBasisFuncs{T, D, <:Any, 1} (e.g.,   BasisFunc and BasisFuncMix), or a Real number and a  CompositeGTBasisFuncs{T, D, <:Any, 1}. If normalizeGTO is set to missing (in  default), The GaussFunc inside the output containers will be normalized only if  every input FloatingGTBasisFuncs (or inside the input CompositeGTBasisFuncs) holds  hasNormFactor(ai) == true. roundAtol specifies the absolute approximation tolerance of  comparing parameters stored in each CompositeGTBasisFuncs to determine whether they are  treated as \"equal\"; each parameter in the returned CompositeGTBasisFuncs is set to the  nearest exact multiple of 0.5atol. When roundAtol is set to NaN, there will be no  approximation nor rounding. This function can be called using * syntax with the keyword  argument set to it default value.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> bf1 = genBasisFunc([1.0, 1.0, 1.0], ([2.0, 1.0], [0.1, 0.2]));\n\njulia> gaussCoeffOf(bf1)\n2×2 Matrix{Float64}:\n 2.0  0.1\n 1.0  0.2\n\njulia> bf2 = bf1 * 2;\n\njulia> gaussCoeffOf(bf2)\n2×2 Matrix{Float64}:\n 2.0  0.2\n 1.0  0.4\n\njulia> bf3 = bf1 * bf2;\n\njulia> gaussCoeffOf(bf3)\n3×2 Matrix{Float64}:\n 4.0  0.02\n 3.0  0.08\n 2.0  0.08\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.mul-Union{Tuple{T}, Tuple{GaussFunc{T}, Real}} where T","page":"Core Functions","title":"Quiqbox.mul","text":"mul(gf::GaussFunc{T}, coeff::Real; roundAtol::Real=getAtolVal(T)) where {T} -> \nGaussFunc\n\nmul(coeff::Real, gf::GaussFunc{T}; roundAtol::Real=getAtolVal(T)) where {T} -> \nGaussFunc\n\nmul(gf1::GaussFunc{T}, gf2::GaussFunc{T}; roundAtol::Real=getAtolVal(T)) where {T} -> \nGaussFunc\n\nMultiplication between a Real number and a GaussFunc or two GaussFuncs.  roundAtol specifies the absolute approximation tolerance of comparing parameters stored  in each GaussFunc to determine whether they are treated as \"equal\"; each parameter in the  returned GaussFunc is set to the nearest exact multiple of 0.5atol. When roundAtol is  set to NaN, there will be no approximation nor rounding. This function can be called  using * syntax with the keyword argument set to it default value. \n\nNOTE: For the ParamBox (stored in the input arguments) that are marked as  non-differentiable, they will be fused together if possible to generate new ParamBox(s)  no longer linked to the data (input variable) stored in them.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> gf1 = GaussFunc(3.0, 1.0)\nGaussFunc{Float64, …}{0, 0}[∂∂][{3.0, 1.0}]\n\njulia> gf1 * 2\nGaussFunc{Float64, …}{0, 0}[∂∂][{3.0, 2.0}]\n\njulia> gf1 * gf1\nGaussFunc{Float64, …}{0, 0}[∂∂][{6.0, 1.0}]\n\njulia> gf1 * 2 * gf1\nGaussFunc{Float64, …}{0, 0}[∂∂][{6.0, 2.0}]\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.normalizeBasis-Tuple{BasisFuncs}","page":"Core Functions","title":"Quiqbox.normalizeBasis","text":"normalizeBasis(b::BasisFuncs{T, D}) where {T, D} -> Vector{<:FloatingGTBasisFuncs{T, D}}\n\nNormalize each BasisFunc inside b and try to merge them back to one  BasisFuncs. If the all the BasisFunc(s) can be merged, the returned result will  be a 1-element Vector.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.normalizeBasis-Union{Tuple{GTBasisFuncs{T}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.normalizeBasis","text":"normalizeBasis(b::GTBasisFuncs{T, D, 1}) where {T, D} -> GTBasisFuncs{T, D, 1}\n\nMultiply the contraction coefficient(s) inside b by constant coefficient(s) to  normalizeBasis the b, and then return the normalized basis.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.orbitalNumOf","page":"Core Functions","title":"Quiqbox.orbitalNumOf","text":"orbitalNumOf(subshell::Union{String, Symbol}, D::Integer=3) -> Int\n\nReturn the size (number of orbitals) of each subshell in D dimensional real space.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.orbitalNumOf-Union{Tuple{Quiqbox.QuiqboxBasis{<:Any, <:Any, ON}}, Tuple{ON}} where ON","page":"Core Functions","title":"Quiqbox.orbitalNumOf","text":"orbitalNumOf(b::QuiqboxBasis) -> Int\n\nReturn the numbers of orbitals of the input basis.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.shift-Union{Tuple{F}, Tuple{GN}, Tuple{𝑙}, Tuple{D}, Tuple{FloatingGTBasisFuncs{var\"#s58\", D, 𝑙, GN, PT, 1} where {var\"#s58\", PT}, AbstractArray{Int64}}, Tuple{FloatingGTBasisFuncs{var\"#s57\", D, 𝑙, GN, PT, 1} where {var\"#s57\", PT}, AbstractArray{Int64}, F}} where {D, 𝑙, GN, F<:Function}","page":"Core Functions","title":"Quiqbox.shift","text":"shift(bf::FloatingGTBasisFuncs{T, D, 𝑙, GN, PT, 1}, \n      dl::Union{Vector{Int}, NTuple{D, Int}, LTuple{D}}, op::Function=+) where \n     {T, D, 𝑙, GN, PT} -> \nBasisFunc{T, D, <:Any, GN, PT}\n\nShift (+ as the default binary operator op) the angular momentum (in Cartesian  representation) of the input FloatingGTBasisFuncs given dl that specifies the change of  each component.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortBasis-Union{Tuple{AbstractArray{<:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortBasis","text":"sortBasis(bs::Union{AbstractArray{<:CompositeGTBasisFuncs{T, D}}, \n                    Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}; \n          roundAtol::Real=getAtolVal(T)) where {T, D} -> \nVector{<:CompositeGTBasisFuncs{T, D}}\n\nSort basis functions. roundAtol specifies the absolute approximation tolerance of  comparing parameters stored in each CompositeGTBasisFuncs to determine whether they are  treated as \"equal\"; when set to NaN, no approximation will be made during the comparison.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortBasis-Union{Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT<:GTBasisFuncs{T, D, 1}}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.sortBasis","text":"sortBasis(b::GTBasis{T, D}; roundAtol::Real=getAtolVal(T)) where {T, D} -> \nGTBasis{T, D}\n\nReconstruct a GTBasis by sorting the GTBasisFuncs stored in the input one.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortBasis-Union{Tuple{Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortBasis","text":"sortBasis(bs::Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}; \n          roundAtol::Real=getAtolVal(T)) where {T, D} -> \nTuple{Vararg{CompositeGTBasisFuncs{T, D}}}\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{<:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{<:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortBasisFuncs","text":"sortBasisFuncs(bs::AbstractArray{<:FloatingGTBasisFuncs{T, D}}, \n               groupCenters::Bool=false; roundAtol::Real=getAtolVal(T)) where {T, D} -> \nVector\n\nSort FloatingGTBasisFuncs. If groupCenters = true, Then the function will return an  Vector{<:Vector{<:FloatingGTBasisFuncs}} in which the elements are grouped basis  functions with same center coordinates. roundAtol specifies the absolute approximation  tolerance of comparing the center coordinates to determine whether they are treated as  \"equal\"; when set to NaN, no approximation will be made during the comparison.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortBasisFuncs-Union{Tuple{Tuple{FloatingGTBasisFuncs{T, D}, Vararg{FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}, Tuple{Tuple{FloatingGTBasisFuncs{T, D}, Vararg{FloatingGTBasisFuncs{T, D}}}, Bool}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortBasisFuncs","text":"sortBasisFuncs(bs::Tuple{FloatingGTBasisFuncs{T, D}, \n                         Vararg{FloatingGTBasisFuncs{T, D}}}, \n               groupCenters::Bool=false; \n               roundAtol::Real=getAtolVal(T)) where {T, D} -> \nTuple\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortPermBasis-Union{Tuple{AbstractArray{<:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortPermBasis","text":"sortPermBasis(bs::AbstractArray{<:CompositeGTBasisFuncs{T, D}}; \n              roundAtol::Real=getAtolVal(T)) where {T, D} -> \nVector{Int}\n\nReturn a Vector of indices I such that bs[I] ==sortBasis (bs; roundAtol)[I].\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sortPermBasisFuncs-Union{Tuple{AbstractArray{<:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.sortPermBasisFuncs","text":"sortPermBasisFuncs(bs::Union{AbstractArray{<:FloatingGTBasisFuncs{T, D}}, \n                             Tuple{FloatingGTBasisFuncs{T, D}, \n                                   Vararg{FloatingGTBasisFuncs{T, D}}}}; \n                   roundAtol::Real=getAtolVal(T)) where {T, D} -> \nVector{Int}\n\nReturn a Vector of indices I such that bs[I] ==sortBasisFuncs (bs; roundAtol)[I].\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.subshellOf-Tuple{FloatingGTBasisFuncs}","page":"Core Functions","title":"Quiqbox.subshellOf","text":"subshellOf(::FloatingGTBasisFuncs) -> String\n\nReturn the corresponding subshell of the input FloatingGTBasisFuncs.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.unpackBasis-Union{Tuple{Quiqbox.EmptyBasisFunc{T, D}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.unpackBasis","text":"unpackBasis(b::GTBasisFuncs{T, D}) -> Vector{<:BasisFunc{T, D}}\n\nUnpack b to return all the BasisFunc inside it.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.runHF-Union{Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT<:GTBasisFuncs{T, D, 1}}, Vararg{Any}}} where T","page":"Core Functions","title":"Quiqbox.runHF","text":"runHF(bs, nuc, nucCoords, config=HFconfig(), N=getCharge(nuc); \n      printInfo=true, infoLevel=3) -> \nHFfinalVars\n\nrunHF(bs, nuc, nucCoords, N=getCharge(nuc), config=HFconfig(); \n      printInfo=true, infoLevel=3) -> \nHFfinalVars\n\nMain function to run a Hartree-Fock method in Quiqbox. The returned result and relevant  information is stored in a HFfinalVars.\n\nrunHFcore(args...; printInfo=false, infoLevel=3) -> \nTuple{Tuple{Vararg{HFtempVars}}, Bool}\n\nThe core function of runHF that accept the same positional arguments as runHF, except  it returns the data (HFtempVars) collected during the iteration and the boolean result of  whether the SCF procedure is converged.\n\n≡≡≡ Positional argument(s) ≡≡≡\n\nbs::Union{     BasisSetData{T, D},      AbstractVector{<:AbstractGTBasisFuncs{T, D}},      Tuple{Vararg{AbstractGTBasisFuncs{T, D}}} } where {T, D}: The basis set used for the Hartree-Fock approximation.\n\nnuc::Union{     Tuple{String, Vararg{String, NNMO}} where NNMO,      AbstractVector{String} }: The nuclei in the studied system.\n\nnucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})} where {T, D, NNMO}: The coordinates of corresponding nuclei.\n\nconfig::HFconfig: The Configuration of selected Hartree-Fock method. For more information  please refer to HFconfig.\n\nN::Union{Int, Tuple{Int}, NTuple{2, Int}}: Total number of electrons, or the number(s) of  electrons with same spin configurations(s). NOTE: N::NTuple{2, Int} is only supported  by unrestricted Hartree-Fock (UHF).\n\n≡≡≡ Keyword argument(s) ≡≡≡\n\nprintInfo::Bool: Whether print out the information of iteration steps and result.\n\ninfoLevel::Int: Printed info's level of details when printInfo=true. The higher  (the absolute value of) it is, more intermediate steps will be printed. Once infoLevel  achieve 5, every step will be printed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.runHFcore-Union{Tuple{T2}, Tuple{HFTS}, Tuple{MS}, Tuple{L}, Tuple{T1}, Tuple{HFT}, Tuple{Val{HFT}, SCFconfig{T1, L, MS}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Int64, Bool, NTuple{4, Bool}}, Tuple{Val{HFT}, SCFconfig{T1, L, MS}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Int64, Bool, NTuple{4, Bool}, Bool}, Tuple{Val{HFT}, SCFconfig{T1, L, MS}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Int64, Bool, NTuple{4, Bool}, Bool, Int64}} where {HFT, T1, L, MS, HFTS, T2}","page":"Core Functions","title":"Quiqbox.runHFcore","text":"runHFcore(HTtype, scfConfig, Ns, Hcore, HeeI, S, X, C0, maxStep, earlyStop, saveTrace, \n          printInfo=false, infoLevel=3) -> \nTuple{Tuple{Vararg{HFtempVars}}, Bool}\n\nAnother method of runHFcore that has the same return value, but takes more underlying  data as arguments.\n\n=== Positional argument(s) ===\n\nHTtype::Val{HFT} where HFT: Hartree-Fock method type. Available values of HFT are  :RHF, :UHF.\n\nscfConfig::SCFconfig: The SCF iteration configuration.\n\nNs::NTuple{HFTS, Int} where HFTS: The numbers of electrons with same spin configurations. \n\nHcore::AbstractMatrix{T} where T: The core Hamiltonian of the electronic Hamiltonian.\n\nHeeI::AbstractArray{T, 4} where T: The electron-electron interaction tensor (in the  chemists' notation) which includes both the Coulomb interactions and the Exchange  Correlations.\n\nS::AbstractMatrix{T} where T: The overlap matrix of the used basis set.\n\nX::AbstractMatrix{T} where T: The transformation matrix of S.\n\nC0::NTuple{HFTS, AbstractMatrix{T}} where {HFTS, T}: Initial guess of the coefficient  matrix(s) of the canonical spin-orbitals.\n\nmaxStep::Int: Maximum iteration steps allowed regardless if the iteration converges.\n\nearlyStop::Bool: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.\n\nsaveTrace::NTuple{4, Bool}: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the output HFtempVars of  runHFcore. Its definition is the same as the field .saveTrace inside a  HFconfig.\n\nprintInfo::Bool: Whether print out the information of iteration steps and result.\n\ninfoLevel::Int: Printed info's level of details when printInfo=true. The higher  (the absolute value of) it is, more intermediate steps will be printed. Once infoLevel  achieve 5, every step will be printed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.gradOfHFenergy-Union{Tuple{NNMO}, Tuple{HFTS}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{<:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT<:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}, Tuple{AbstractVector{<:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT<:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, HFTS, NNMO}","page":"Core Functions","title":"Quiqbox.gradOfHFenergy","text":"gradOfHFenergy(par, basis, C, nuc, nucCoords, N=getCharge(nuc)) ->\nAbstractVector\n\ngradOfHFenergy(par, bs, S, C, nuc, nucCoords, N=getCharge(nuc)) ->\nAbstractVector\n\nTwo methods of gradOfHFenergy.\n\n≡≡≡ Positional argument(s) ≡≡≡\n\npar::AbstractVector{<:ParamBox}: The parameters for differentiation.\n\nbasis::GTBasis{T, D} where {T, D}: Basis set information.\n\nC::NTuple{<:Any, AbstractMatrix{T}} where T: The coefficient matrix(s) of the canonical  orbitals with respect to the selected basis set.\n\nnuc::Union{     Tuple{String, Vararg{String, NNMO}} where NNMO,      AbstractVector{String} }: The nuclei in the studied system.\n\nnucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})} where {T, D, NNMO}: The coordinates of corresponding nuclei.\n\nN::Union{Int, Tuple{Int}, NTuple{2, Int}}: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).\n\nbs::Union{     NTuple{BN, GTBasisFuncs{T, D, 1}},      AbstractVector{<:GTBasisFuncs{T, D, 1}} } where {T, D}: A collection of basis functions.\n\nS::AbstractMatrix{T} where T: The overlap lap of the basis set when bs is provided as  the second argument.\n\nNOTE: If any of these two methods is applied, the user needs to make sure the row  orders as well as the colum orders of C and (or) S are consistent with the element  order of bs (basis.basis). ``\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.gridCoordOf-Tuple{GridBox}","page":"Core Functions","title":"Quiqbox.gridCoordOf","text":"gridCoordOf(gb::GridBox{T}) where {T} -> Tuple{Vararg{Vector{T}}}\n\nReturn the coordinates of the grid points stored in gb.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{<:ParamBox{T}}, AbstractVector{<:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}, Tuple{AbstractVector{<:ParamBox{T}}, AbstractVector{<:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}, POconfig{<:Any, M, CBT, <:Any, F}}, Tuple{AbstractVector{<:ParamBox{T}}, AbstractVector{<:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}, POconfig{<:Any, M, CBT, <:Any, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NNMO, M, CBT, F}","page":"Core Functions","title":"Quiqbox.optimizeParams!","text":"optimizeParams!(pbs, bs, nuc, nucCoords, \n                config=POconfig(), N=getCharge(nuc); \n                printInfo=true, infoLevel=2) -> \nVector{Any}\n\noptimizeParams!(pbs, bs, nuc, nucCoords, \n                N=getCharge(nuc), config=POconfig(); \n                printInfo=true, infoLevel=2) -> \nVector{Any}\n\nThe main function to optimize the parameters of a given basis set. It returns a Vector of  the relevant information. The first element is the indicator of whether the  optimization is converged if the convergence detection is on (i.e., config.threshold is  not NaN), or else it's set to missing. More elements may be pushed to the returned  result in order depending on config.method.\n\n=== Positional argument(s) ===\n\npbs::AbstractVector{<:ParamBox{T}}: The parameters to be optimized that are extracted  from the basis set. If the parameter is marked as \"differentiable\", the value of its input  variable will be optimized.\n\nbs::AbstractVector{<:GTBasisFuncs{T, D}}: The basis set to be optimized.\n\nnuc::Union{     Tuple{String, Vararg{String, NNMO}} where NNMO,      AbstractVector{String} }: The nuclei in the studied system.\n\nnucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})} where {T, D, NNMO}: The coordinates of corresponding nuclei.\n\nconfig::POconfig: The Configuration of selected parameter optimization method. For more  information please refer to POconfig.\n\nN::Union{Int, Tuple{Int}, NTuple{2, Int}}: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).\n\n=== Keyword argument(s) ===\n\nprintInfo::Bool: Whether print out the information of iteration steps.\n\ninfoLevel::Int: Printed info's level of details when printInfo=true. The higher  (the absolute value of) it is, more intermediate steps will be printed. Once infoLevel  achieve 5, every step will be printed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeHbasis-Tuple{Quiqbox.HFfinalVars}","page":"Core Functions","title":"Quiqbox.changeHbasis","text":"changeHbasis(HFres::HFfinalVars) -> NTuple{2, Any}\n\nReturn the one-body and two-body integrals on the basis of the canonical orbitals  using the result of a Hartree-Fock method HFres.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeHbasis-Union{Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {BN, BFT<:GTBasisFuncs{T, D, 1}}, Tuple{String, Vararg{String, NNMO}}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractMatrix{T}}} where {T, D, NNMO}","page":"Core Functions","title":"Quiqbox.changeHbasis","text":"changeHbasis(b::GTBasis{T, D}, \n             nuc::Tuple{String, Vararg{String, NNMO}}, \n             nucCoords::Tuple{NTuple{D, T}, Vararg{NTuple{D, T}, NNMO}}, \n             C::Union{AbstractMatrix{T}, NTuple{2, AbstractMatrix{T}}}) where \n            {T, D, NNMO} -> \nNTuple{2, Any}\n\nReturn the one-body and two-body integrals after a change of basis based on the input C,  given the basis set information b. The type of each element in the returned Tuple is  consistent with the cases where the first argument of changeHbasis is an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Vararg{AbstractMatrix{T}, 2}}} where T","page":"Core Functions","title":"Quiqbox.changeHbasis","text":"changeHbasis(twoBodyInt::AbstractArray{T, 4}, \n             C1::AbstractMatrix{T}, C2::AbstractMatrix{T}) where {T} -> \nAbstractArray{T, 4}\n\nChange the basis of the input two-body integrals twoBodyInt based on two orbital  coefficient matrices C1 and C2 for different spin configurations (e.g., the  unrestricted case). The output is a 3-element Tuple of which the first 2 elements are the  spatial integrals of each spin configurations respectively, while the last element is the  Coulomb interactions between orbitals with different spins.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Core Functions","title":"Quiqbox.changeHbasis","text":"changeHbasis(DbodyInt::AbstractArray{T, D}, C::AbstractMatrix{T}) where {T} -> \nAbstractArray{T, D}\n\nChange the basis of the input one-body / two-body integrals DbodyInt based on the orbital  coefficient matrix C.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genCanOrbitals-Union{Tuple{Quiqbox.HFfinalVars{T}}, Tuple{T}} where T","page":"Core Functions","title":"Quiqbox.genCanOrbitals","text":"genCanOrbitals(fVars::HFfinalVars{T, D, <:Any, NN}; \n               roundAtol::Real=getAtolVal(T)) where {T, D, NN} -> \nNTuple{2, Vector{CanOrbital{T, D, NN}}}\n\nGenerate the occupied and unoccupied canonical orbitals from the result of a Hartree-Fock  approximation fVars. Each parameter stored in the constructed CanOrbital will  be rounded to the nearest multiple of roundAtol; when roundAtol is set to NaN, no  rounding will be performed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.nnRepulsions-Union{Tuple{T}, Tuple{NNMO}, Tuple{Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, var\"#s321\"}}, 1}, Tuple{Tuple{Vararg{T, var\"#s321\"}}, Vararg{Tuple{Vararg{T, var\"#s321\"}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})} where var\"#s321\"}} where {NNMO, T}","page":"Core Functions","title":"Quiqbox.nnRepulsions","text":"nnRepulsions(nuc::Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{String}}, \n             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}) where {NNMO, D, T} -> \nT\n\nReturn the nuclear repulsion energy given nuclei nuc and their coordinates nucCoords.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.coreH-Union{Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{AbstractGTBasisFuncs{T, D}, Vararg{AbstractGTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:AbstractGTBasisFuncs{T, D}}} where NNMO, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}} where {T, D, NNMO}","page":"Core Functions","title":"Quiqbox.coreH","text":"coreH(bs::Union{GTBasis, Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, \n                AbstractVector{<:AbstractGTBasisFuncs{T, D}}}, \n      nuc::Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{String}}, \n      nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}) where {T, D, NNMO} -> \nMatrix{T}\n\nReturn the core Hamiltonian given a basis set and the corresponding nuclei with their  coordinates (in atomic units).\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.coreHij-Union{Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}} where {T, D, NNMO}","page":"Core Functions","title":"Quiqbox.coreHij","text":"coreHij(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, \n        nuc::Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{String}}, \n        nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}) where {T, D, NNMO} -> \nT\n\nReturn a matrix element of the core Hamiltonian given two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.eKinetic-Union{Tuple{T}, Tuple{D}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {D, T}","page":"Core Functions","title":"Quiqbox.eKinetic","text":"eKinetic(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where \n        {T, D} -> \nT\n\nReturn the electron kinetic energy between two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.eKinetics-Union{Tuple{Union{Tuple{AbstractGTBasisFuncs{T, D}, Vararg{AbstractGTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:AbstractGTBasisFuncs{T, D}}} where NNMO}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.eKinetics","text":"eKinetics(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, \n                    AbstractVector{<:AbstractGTBasisFuncs{T, D}}}) where {T, D} -> \nMatrix{T}\n\nReturn the electron kinetic energy matrix given a basis set.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.neAttraction-Union{Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}} where {T, D, NNMO}","page":"Core Functions","title":"Quiqbox.neAttraction","text":"neAttraction(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, \n             nuc::Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{String}}, \n             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}) where {T, D, NNMO} -> \nT\n\nReturn the nuclear attraction between two basis functions, provided with the nuclei and  their coordinates (in the atomic units).\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.neAttractions-Union{Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{AbstractGTBasisFuncs{T, D}, Vararg{AbstractGTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:AbstractGTBasisFuncs{T, D}}} where NNMO, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{<:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}}} where {T, D, NNMO}","page":"Core Functions","title":"Quiqbox.neAttractions","text":"neAttractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, \n                        AbstractVector{<:AbstractGTBasisFuncs{T, D}}}, \n              nuc::Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{String}}, \n              nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{<:AbstractVector{<:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL<:(AbstractVector{<:T})}) where {T, D, NNMO} -> \nMatrix{T}\n\nReturn the nuclear attraction matrix given a basis set and the corresponding nuclei with  their coordinates (in atomic units).\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.overlap-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}","page":"Core Functions","title":"Quiqbox.overlap","text":"overlap(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where \n       {T, D, 1} -> \nT\n\nReturn the orbital overlap between two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.overlaps-Union{Tuple{Union{Tuple{AbstractGTBasisFuncs{T, D}, Vararg{AbstractGTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:AbstractGTBasisFuncs{T, D}}} where NNMO}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.overlaps","text":"overlaps(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, \n                   AbstractVector{<:AbstractGTBasisFuncs{T, D}}}) where {T, D} -> \nMatrix{T}\n\nReturn the orbital overlap matrix given a basis set.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.eeInteraction-Union{Tuple{D}, Tuple{T}, NTuple{4, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}","page":"Core Functions","title":"Quiqbox.eeInteraction","text":"eeInteraction(bf1::AbstractGTBasisFuncs{T, D, 1}, \n              bf2::AbstractGTBasisFuncs{T, D, 1}, \n              bf3::AbstractGTBasisFuncs{T, D, 1}, \n              bf4::AbstractGTBasisFuncs{T, D, 1}) where {T, D} -> \nT\n\nReturn an electron-electron interaction tensor element given four basis functions (ordered  in the chemists' notation).\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.eeInteractions-Union{Tuple{Union{Tuple{AbstractGTBasisFuncs{T, D}, Vararg{AbstractGTBasisFuncs{T, D}, NNMO}}, AbstractVector{<:AbstractGTBasisFuncs{T, D}}} where NNMO}, Tuple{D}, Tuple{T}} where {T, D}","page":"Core Functions","title":"Quiqbox.eeInteractions","text":"eeInteractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, \n                         AbstractVector{<:AbstractGTBasisFuncs{T, D}}}) -> \nArray{T, 4}\n\nReturn the tensor of electron-electron interactions (in the chemists' notation) given a  basis set.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.eeIuniqueIndicesOf-Tuple{Int64}","page":"Core Functions","title":"Quiqbox.eeIuniqueIndicesOf","text":"eeIuniqueIndicesOf(basisSetSize::Int) -> Vector{Vector{Int}}\n\nReturn the unique matrix element indices (in the chemists' notation) of electron-electron  interactions given the size of a basis set.\n\n\n\n\n\n","category":"method"},{"location":"list/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"Below are the links to all the docstrings (e.g., types, functions) included in the documentation.","category":"page"},{"location":"list/","page":"Index","title":"Index","text":"order = [:type]","category":"page"},{"location":"toolFunction/#Tool-Functions","page":"Tool Functions","title":"Tool Functions","text":"","category":"section"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Modules = [Quiqbox]\nPages   = [\"Tools.jl\", \"FileIO.jl\"]\nOrder   = [:function]","category":"page"},{"location":"toolFunction/#Quiqbox.flatten-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Tool Functions","title":"Quiqbox.flatten","text":"flatten(a::Tuple) -> Tuple\n\nflatten(a::AbstractVector) -> AbstractVector\n\nFlatten a::Union{AbstractVector, Tuple} that contains AbstractArrays and/or Tuples.  Only operate on the outermost container.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> flatten((:one, 2, [3, 4.0], ([5], \"six\"), \"7\"))\n(:one, 2, 3.0, 4.0, [5], \"six\", \"7\")\n\njulia> flatten([:one, 2, [3, 4.0], ([5], \"six\"), \"7\"])\n7-element Vector{Any}:\n  :one\n 2\n 3.0\n 4.0\n  [5]\n  \"six\"\n  \"7\"\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.getAtolDigits-Union{Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Tool Functions","title":"Quiqbox.getAtolDigits","text":"getAtolDigits(::Type{T}) where {T<:Real} -> Int\n\nReturn the maximal number of digits kept after rounding of the input real number type T.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.getAtolVal-Union{Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Tool Functions","title":"Quiqbox.getAtolVal","text":"getAtolVal(::Type{T}) where {T<:Real} -> Real\n\nReturn the absolute precision tolerance of the input real number type T.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.getUnique!-Union{Tuple{F}, Tuple{T}, Tuple{AbstractVector{T}, Vararg{Any}}} where {T, F<:Function}","page":"Tool Functions","title":"Quiqbox.getUnique!","text":"getUnique!(arr::AbstractVector, args...; compareFunction::Function = hasEqual, \n           kws...) -> \nAbstractVector\n\nSimilar to markUnique but instead, directly return the modified arr so that the  repeated entries are deleted.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> arr = [1, [1, 2],\"s\", [1, 2]]\n4-element Vector{Any}:\n 1\n  [1, 2]\n  \"s\"\n  [1, 2]\n\njulia> getUnique!(arr);\n\njulia> arr\n3-element Vector{Any}:\n 1\n  [1, 2]\n  \"s\"\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.hasApprox-Tuple{Any, Any, Vararg{Any}}","page":"Tool Functions","title":"Quiqbox.hasApprox","text":"hasApprox(obj1, obj2, obj3...; ignoreFunction::Bool=false, ignoreContainer::Bool=false,\n          decomposeNumberCollection::Bool=false, atol::Real=1e-15) -> \nBool\n\nSimilar to hasEqual, except it does not require the Number-typed fields  (e.g. Float64) of the compared containers to have the exact same values, but rather the  approximate values within an error threshold determined by atol, like in isapprox.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.hasBoolRelation-Union{Tuple{F}, Tuple{F, Any, Any, Any, Vararg{Any}}} where F<:Function","page":"Tool Functions","title":"Quiqbox.hasBoolRelation","text":"hasBoolRelation(boolOp::Function, obj1, obj2, obj3...; \n                ignoreFunction::Bool=false, \n                ignoreContainer::Bool=false,\n                decomposeNumberCollection::Bool=false) -> \nBool\n\nMethod for more than 2 objects. If returns true if and only if hasBoolRelation returns  true for every unique combination of two objects from the all the input objects under the  transitive relation. E.g.: hasBoolRelation(>, a, b, c) is equivalent to  hasBoolRelation(>, a, b) && hasBoolRelation(>, b, c).\n\n≡≡≡ Example(s) ≡≡≡\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n\n    a = S(1, 1.0)\n    b = S(2, 0.5)\n    c = S(2, 1.5)\n    d = S(3, 2.0)\n\n    Quiqbox.hasBoolRelation(>=, c, b, a) |> println\n    Quiqbox.hasBoolRelation(>=, d, c, b) |> println\nend\n\n# output\nfalse\ntrue\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.hasBoolRelation-Union{Tuple{F}, Tuple{T2}, Tuple{T1}, Tuple{F, T1, T2}} where {T1, T2, F<:Function}","page":"Tool Functions","title":"Quiqbox.hasBoolRelation","text":"hasBoolRelation(boolOp::Function, obj1, obj2; ignoreFunction::Bool=false, \n                ignoreContainer::Bool=false, decomposeNumberCollection::Bool=false) -> \nBool\n\nRecursively apply the specified boolean operator boolOp to all the fields inside two  objects (e.g., two structs of the same type). It returns true if and only if all  comparisons performed return true. Note that the boolean operator should have method(s)  defined for all the possible fields inside the compared objects.\n\nIf ignoreFunction = true, comparisons between Function-type fields will be ignored.\n\nIf ignoreContainer = true, the difference of the container(s) will be ignored as long as  the boolean operator returns true for the field(s)/entry(s) from two objects respectively.\n\nIf decomposeNumberCollection = true, Tuple{Vararg{Number}} and Array{<:Number} will  be treated as decomposable containers.\n\n≡≡≡ Example(s) ≡≡≡\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n\n    a = S(1, 1.0)\n    b = S(2, 0.5)\n    c = S(2, 1.5)\n\n    Quiqbox.hasBoolRelation(>, a, b) |> println\n    Quiqbox.hasBoolRelation(>, b, a) |> println\n    Quiqbox.hasBoolRelation(>, c, a) |> println\nend\n\n# output\nfalse\nfalse\ntrue\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n\n    struct S2\n        a::Int\n        b::Float64\n    end\n\n    Quiqbox.hasBoolRelation(==, S(1,2), S2(1,2), ignoreContainer=true)\nend\n\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.hasEqual-Tuple{Any, Any, Vararg{Any}}","page":"Tool Functions","title":"Quiqbox.hasEqual","text":"hasEqual(obj1, obj2, obj3...; \n         ignoreFunction::Bool=false, \n         ignoreContainer::Bool=false,\n         decomposeNumberCollection::Bool=false) -> \nBool\n\nCompare if two containers (e.g. struct) are equal. An instantiation of  hasBoolRelation. ≡≡≡ Example(s) ≡≡≡\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n    a = S(1, 1.0)\n    b = S(1, 1.0)\n    c = S(1, 1.0)\n    d = S(1, 1.1)\n\n    hasEqual(a, b, c) |> println\n    hasEqual(a, b, c, d) |> println\nend\n\n# output\ntrue\nfalse\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.hasIdentical-Tuple{Any, Any, Vararg{Any}}","page":"Tool Functions","title":"Quiqbox.hasIdentical","text":"hasIdentical(obj1, obj2, obj3...; \n             ignoreFunction::Bool=false, \n             ignoreContainer::Bool=false,\n             decomposeNumberCollection::Bool=false) -> \nBool\n\nCompare if two containers (e.g. struct) are the Identical. An instantiation of  hasBoolRelation.\n\n≡≡≡ Example(s) ≡≡≡\n\nbegin\n    struct S\n        a::Int\n        b::Vector{Float64}\n    end\n\n    a = S(1, [1.0, 1.1])\n    b = a\n    c = b\n    d = S(1, [1.0, 1.1])\n\n    hasIdentical(a, b, c) |> println\n    hasIdentical(a, b, c, d) |> println\nend\n\n# output\ntrue\nfalse\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.itself-Tuple{Any}","page":"Tool Functions","title":"Quiqbox.itself","text":"itself(::T) -> T\n\nA dummy function that returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.markUnique-Union{Tuple{F}, Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any}}} where {T, F<:Function}","page":"Tool Functions","title":"Quiqbox.markUnique","text":"markUnique(arr::AbstractArray{T}, args...; \n           compareFunction::Function=hasEqual, kws...) where {T} -> \nTuple{Vector{Int}, Vector{T}}\n\nReturn a Vector{Int} whose elements are indices to mark the elements inside arr such  that same element will be marked with same index, and a Vector{T} containing all the  unique elements. The definition of \"unique\" (or \"same\") is based on compareFunction  which is set to hasEqual in default. args and kws are placeholders for the  positional arguments and keyword arguments for compareFunction respectively.\n\n≡≡≡ Example(s) ≡≡≡\n\nmarkUnique([1, [1, 2],\"s\", [1, 2]])\n\n# output\n([1, 2, 3, 2], Any[1, [1, 2], \"s\"])\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n\n    a = S(1, 2.0)\n    b = S(1, 2.0)\n    c = S(1, 2.1)\n    d = a\n\n    markUnique([a,b,c,d])\nend\n\n# output\n([1, 1, 2, 1], S[S(1, 2.0), S(1, 2.1)])\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.printStyledInfo-Tuple{String}","page":"Tool Functions","title":"Quiqbox.printStyledInfo","text":"printStyledInfo(str::String; title::String=\"\", titleColor::Symbol=:light_blue) -> \nNothing\n\nPrint info with colorful title and automatically highlighted code blocks enclosed by .\n\nIf you want to highlight other contents in different colors, you can also start it with  \"///theColorSymbolName///\" and then enclose it with `. The available color names follows  the values ofcolorkeyword argument in functionBase.printstyled`.\n\nNOTE: There can only be one color in one  quote.\n\n≡≡≡ Example(s) ≡≡≡\n\njulia> Quiqbox.printStyledInfo(\"This `///magenta///word` is in color magenta.\")\nThis word is in color magenta.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.replaceSymbol-Tuple{Symbol, Pair{String, String}}","page":"Tool Functions","title":"Quiqbox.replaceSymbol","text":"replaceSymbol(sym::Symbol, pair::Pair{String, String}; count::Int=typemax(Int)) -> \nSymbol\n\nSimilar as Base.replace but for Symbols.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/#Quiqbox.checkFname-Tuple{String}","page":"Tool Functions","title":"Quiqbox.checkFname","text":"checkFname(Fname::String; showWarning::Bool=true) -> String\n\nCheck if there is a file with the same name in the current directory. If so, add a \"_N\"  at the end of Fname. showWarning determines whether to print out the WARNING info when  there is a file with the same name.\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Modules = [Quiqbox]\nPages   = [\"Overload.jl\"]\nFilter = f -> typeof(f) === typeof(Quiqbox.flatten)","category":"page"},{"location":"toolFunction/#Quiqbox.flatten-Union{Tuple{AbstractVector{<:GTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Tool Functions","title":"Quiqbox.flatten","text":"flatten(bs::AbstractVector{<:GTBasisFuncs{T, D}}) where {T, D} -> \nAbstractVector{<:GTBasisFuncs{T, D, 1}}\n\nflatten(bs::Tuple{Vararg{GTBasisFuncs{T, D}}}) where {T, D} -> \nTuple{Vararg{GTBasisFuncs{T, D, 1}}}\n\nFlatten a collection of GTBasisFuncs by decomposing every GTBasisFuncs{T, D, ON}  where ON > 1 into multiple GTBasisFuncs{T, D, 1}.\n\n\n\n\n\n","category":"method"},{"location":"#Quiqbox.jl","page":"Home","title":"Quiqbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quiqbox is a quantum chemistry and quantum physics software package that starts around Gaussian basis set optimization for electronic structure problems. Quiqbox is written in pure Julia. This work is supported by the U.S. Department of Energy under Award No. DESC0019374.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Native 1-electron and 2-electron integral functions.\nFloating and fixed-position contracted Gaussian-type orbital (CGTO).\nMixed-contracted GTO (linear combination of GTOs with mixed centers or orbital angular momentum) as a basis function.\nRestricted (closed-shell) and unrestricted (open-shell) Hartree–Fock methods (RHF & UHF).\nVariational optimization of basis sets based on automatic differentiation (AD) and symbolic differentiation (SD).","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"#OS-(64-bit)-support","page":"Home","title":"OS (64-bit) support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generic Linux\nmacOS\nWindows","category":"page"},{"location":"","page":"Home","title":"Home","text":"NOTE: Each operating system (OS) platform is only tested on the x86-64 architecture. The support of those systems on different architectures (such as macOS on ARM architecture) is not guaranteed.","category":"page"},{"location":"#Julia-(64-bit)-compatibility","page":"Home","title":"Julia (64-bit) compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quiqbox will always try to support the latest stable release of 64-bit Julia as soon as possible. On the other hand, backward compatibility with previous versions is not guaranteed but can be checked here.","category":"page"},{"location":"#Installation-in-Julia-[REPL](https://docs.julialang.org/en/v1/manual/getting-started/)","page":"Home","title":"Installation in Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type ] in the default Julian mode to switch to the Pkg mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type the following command and hit Enter key to install Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg> add Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the installation completes, hit the Backspace key to go back to the Julian mode and use using to load Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more basic usage of the programming language behind Quiqbox, Julia, please refer to the official documentation.","category":"page"},{"location":"#Manual-Contents","page":"Home","title":"Manual Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"basis.md\", \"SCF.md\", \"optimization.md\"]\nDepth = 3","category":"page"},{"location":"molden/#Molden","page":"Molden","title":"Molden","text":"","category":"section"},{"location":"molden/","page":"Molden","title":"Molden","text":"Quiqbox supports outputting the information of canonical spin-orbitals to Molden file format.","category":"page"},{"location":"molden/","page":"Molden","title":"Molden","text":"Modules = [Quiqbox.Molden]\nPages   = [\"SubModule/Molden.jl\"]\nOrder   = [:function]","category":"page"},{"location":"molden/#Quiqbox.Molden.makeMoldenFile-Union{Tuple{MatterByHF{T, 3}}, Tuple{T}} where T","page":"Molden","title":"Quiqbox.Molden.makeMoldenFile","text":"makeMoldenFile(mol::MatterByHF{T, 3}; roundDigits::Int=getAtolDigits(T), \n               recordUMO::Bool=false, fileName::String = \"MO\") where {T} -> \nString\n\nWrite the information of MatterByHF into a newly created Molden file. recordUMO  determines whether to include the unoccupied canonical orbitals. fileName specifies the  name of the file, which is also the returned value. If roundDigits < 0, there won't be  rounding for recorded data.\n\n\n\n\n\n","category":"method"},{"location":"molden/","page":"Molden","title":"Molden","text":"compat: Supported basis set type\nMolden format only supports the basis sets that contain solely the basis::FloatingGTBasisFuncs{<:Any, 3, <:Any, <:Any, <:Any, ON} where ON is equal to its maximal value. In other words, makeMoldenFile only supports MatterByHF whose .basis.basis are full-subshell FloatingGTBasisFuncs. Furthermore, the field .normalizeGTO for every inside basis function must all be true to avoid potential normalization issues.","category":"page"},{"location":"molden/","page":"Molden","title":"Molden","text":"An example of makeMoldenFile can be found here.","category":"page"}]
}
