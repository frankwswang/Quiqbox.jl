<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions ¬∑ Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/master/docs/src/coreFunction.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.Exponent" href="#Quiqbox.Exponent"><code>Quiqbox.Exponent</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Exponent(e::Union{Real, Array{Float64, 0}}, mapFunction::Function=itself; 
         canDiff::Bool=true, roundDigits::Int=15, dataName::Symbol=:undef) -&gt; 
ParamBox{Float64, :Œ±}</code></pre><p>Construct a <code>ParamBox</code> for an exponent coefficient given a value. Keywords <code>mapFunction</code>  and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>. If  <code>roundDigits &lt; 0</code> or the input <code>e</code> is a 0-d <code>Array</code>, there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L51-L60">source</a></section><section><div><pre><code class="nohighlight hljs">Exponent(pb::ParamBox{Float64}) -&gt; ParamBox{Float64, :Œ±}</code></pre><p>Convert a <code>ParamBox</code> to an exponent coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.Contraction" href="#Quiqbox.Contraction"><code>Quiqbox.Contraction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Contraction(c::Union{Real, Array{Float64, 0}}, mapFunction::Function=itself; 
            canDiff::Bool=true, roundDigits::Int=15, dataName::Symbol=:undef) -&gt; 
ParamBox{Float64, :d}</code></pre><p>Construct a <code>ParamBox</code> for an contraction coefficient given a value. Keywords <code>mapFunction</code>  and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>. If  <code>roundDigits &lt; 0</code> or the input <code>c</code> is a 0-d <code>Array</code>, there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L78-L87">source</a></section><section><div><pre><code class="nohighlight hljs">Contraction(pb::ParamBox{Float64}) -&gt; ParamBox{Float64, :Œ±}</code></pre><p>Convert a <code>ParamBox</code> to an contraction coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inValOf" href="#Quiqbox.inValOf"><code>Quiqbox.inValOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of stored data (independent variable) of the input <code>ParamBox</code>. Equivalent  to <code>pb[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValOf" href="#Quiqbox.outValOf"><code>Quiqbox.outValOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of mapped data (dependent variable) of the input <code>ParamBox</code>. Equivalent to  <code>pb()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymOf" href="#Quiqbox.inSymOf"><code>Quiqbox.inSymOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the <code>Symbol</code> of the stored data (independent variable) of the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outSymOf" href="#Quiqbox.outSymOf"><code>Quiqbox.outSymOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the <code>Symbol</code> of the mapped data (dependent variable) of the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dataOf" href="#Quiqbox.dataOf"><code>Quiqbox.dataOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dataOf(pb::ParamBox{T}) where {T&lt;:Number} -&gt; Array{T, 0}</code></pre><p>Return the 0-D <code>Array</code> of the data stored in the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mapOf" href="#Quiqbox.mapOf"><code>Quiqbox.mapOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapOf(pb::ParamBox{&lt;:Number, F}) where {F&lt;:Function} -&gt; F</code></pre><p>Return the mapping function of the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValCopy" href="#Quiqbox.outValCopy"><code>Quiqbox.outValCopy</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outValCopy(pb::ParamBox{&lt;:Number, V}) -&gt; ParamBox{&lt;:Number, V, :itself}</code></pre><p>Return a new <code>ParamBox</code> of which the stored data is a <strong>deep copy</strong> of the mapped data from  the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L186-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inVarCopy" href="#Quiqbox.inVarCopy"><code>Quiqbox.inVarCopy</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inVarCopy(pb::ParamBox) -&gt; ParamBox{&lt;:Number, &lt;:Any, :itself}</code></pre><p>Return a new <code>ParamBox</code> of which the stored data is a <strong>shallow copy</strong> of the stored data  from the input <code>ParamBox</code>.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; pb1 = ParamBox(-2.0, :a, abs)
ParamBox{Float64, :a, :abs}(-2.0)[‚àÇ][x_a]

julia&gt; pb2 = inVarCopy(pb1)
ParamBox{Float64, :x_a, :itself}(-2.0)[‚àÇ][x_a]

julia&gt; pb1[] == pb2[] == -2.0
true

julia&gt; pb1[] = 1.1
1.1

julia&gt; pb2[]
1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L196-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.enableDiff!" href="#Quiqbox.enableDiff!"><code>Quiqbox.enableDiff!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the input <code>ParamBox</code> as &quot;differentiable&quot; and return the marked <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.disableDiff!" href="#Quiqbox.disableDiff!"><code>Quiqbox.disableDiff!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the input <code>ParamBox</code> as &quot;non-differentiable&quot; and return the marked <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isDiffParam" href="#Quiqbox.isDiffParam"><code>Quiqbox.isDiffParam</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isDiffParam(pb::ParamBox) -&gt; Bool</code></pre><p>Return the Boolean value of if the input <code>ParamBox</code> is &quot;differentiable&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.toggleDiff!" href="#Quiqbox.toggleDiff!"><code>Quiqbox.toggleDiff!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toggleDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Toggle the differentiability (<code>pb.canDiff[]</code>) of the input <code>ParamBox</code> and return the  altered result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Differentiation.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFunc" href="#Quiqbox.genBasisFunc"><code>Quiqbox.genBasisFunc</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFunc(args..., kws...) -&gt; BasisFunc

genBasisFunc(args..., kws...) -&gt; BasisFuncs

genBasisFunc(args..., kws...) -&gt; collection</code></pre><p>Constructor of <code>BasisFunc</code> and <code>BasisFuncs</code>, but it also returns different kinds of  collections of them based on the applied methods.</p><p>‚â°‚â°‚â° Method 1 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gs::Array{GaussFunc, 1}, 
             ijkOrijks::Union{Array{Int, 1}, Array{Array{Int, 1}, 1}}; 
             normalizeGTO::Bool=false)</code></pre><p><code>ijkOrijks</code> is the Array of the pseudo-quantum number(s) to specify the angular  momentum(s). E.g., s is [0,0,0] and p is [[1,0,0], [0,1,0], [0,0,1]].</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), [0,1,0])
BasisFunc{1, 1}(gauss, subshell, center)[X‚Å∞Y¬πZ‚Å∞][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 2 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gs::Union{GaussFunc, Array{GaussFunc, 1}}, 
             subshell::String=&quot;S&quot;; 
             ijkFilter::Array{Bool, 1}=fill(true, SubshellDimList[subshell]), 
             normalizeGTO::Bool=false)</code></pre><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;S&quot;)
BasisFunc{0, 1}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;P&quot;)
BasisFuncs{1, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 3 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(coord::AbstractArray, gExpsANDgCons::NTuple{2, Array{&lt;:Real, 1}}, 
             subshell=&quot;S&quot;; kw...)</code></pre><p>Instead of directly inputting <code>GaussFunc</code>, one can also input a 2-element <code>Tuple</code> of the  exponent(s) and contraction coefficient(s) corresponding to the same <code>GaussFunc</code>(s).</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], (2, 1), &quot;P&quot;)
BasisFuncs{1, 1, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], ([2, 1.5], [1, 0.5]), &quot;P&quot;)
BasisFuncs{1, 2, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 4 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, BSKeyANDnuc::Array{Tuple{String, String}, 1})</code></pre><p>If the user wants to construct existed atomic basis set(s), they can use the (<code>Array</code> of)  <code>(BS_name, Atom_name)</code> as the second input. If the atom is omitted, then basis set for H  is used.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], (&quot;STO-3G&quot;, &quot;Li&quot;))
3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], &quot;STO-3G&quot;)
1-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [&quot;STO-2G&quot;, &quot;STO-3G&quot;])
2-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 2}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [(&quot;STO-2G&quot;, &quot;He&quot;), (&quot;STO-3G&quot;, &quot;O&quot;)])
4-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 2}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(gauss, subshell, center)[3/3][0.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L213-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs" href="#Quiqbox.sortBasisFuncs"><code>Quiqbox.sortBasisFuncs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::Array{&lt;:FloatingGTBasisFuncs, 1}; groupCenters::Bool=false) -&gt;
Array</code></pre><p>Sort basis functions. If <code>groupCenters = true</code>, Then the function will return an  <code>Array{&lt;:Array{&lt;:FloatingGTBasisFuncs, 1}, 1}</code> in which the arrays are grouped basis  functions with same center coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L435-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerOf" href="#Quiqbox.centerOf"><code>Quiqbox.centerOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centerOf(bf::FloatingGTBasisFuncs) -&gt; Array{&lt;:Real, 1}</code></pre><p>Return the center coordinate of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L473-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.add-Union{Tuple{BasisFuncs{ùëô, GN, 1}}, Tuple{GN}, Tuple{ùëô}} where {ùëô, GN}" href="#Quiqbox.add-Union{Tuple{BasisFuncs{ùëô, GN, 1}}, Tuple{GN}, Tuple{ùëô}} where {ùëô, GN}"><code>Quiqbox.add</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(b::CompositeGTBasisFuncs{&lt;:Any, 1}) -&gt; CompositeGTBasisFuncs{&lt;:Any, 1}

add(b1::CompositeGTBasisFuncs{&lt;:Any, 1}, b2::CompositeGTBasisFuncs{&lt;:Any, 1}) -&gt;
CompositeGTBasisFuncs{&lt;:Any, 1}</code></pre><p>Addition between <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code> such as <code>BasisFunc</code> and  <code>Quiqbox.BasisFuncMix</code>. It can be called using <code>+</code> syntax.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1,1,1], (2,1))
BasisFunc{0, 1}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf2 = genBasisFunc([1,1,1], (2,2))
BasisFunc{0, 1}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf3 = bf1 + bf2
BasisFunc{0, 1}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf3.gauss[1].con[]
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L609-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Tuple{GaussFunc, Real}" href="#Quiqbox.mul-Tuple{GaussFunc, Real}"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(gf::GaussFunc, coeff::Real) -&gt; GaussFunc

mul(coeff::Real, gf::GaussFunc) -&gt; GaussFunc

mul(gf1::GaussFunc, gf2::GaussFunc) -&gt; GaussFunc</code></pre><p>Multiplication between <code>GaussFunc</code>s or contraction coefficient multiplication between a  <code>Real</code> number and a <code>GaussFunc</code>. It can be called using <code>*</code> syntax.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; gf1 = GaussFunc(3,1)
GaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(3.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(1.0)[‚àÇ][d])

julia&gt; gf1 * 2
GaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(3.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])

julia&gt; gf1 * gf1
GaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(6.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(1.0)[‚àÇ][d])

julia&gt; gf1 * 2 * gf1
GaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(6.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L708-L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{ùëô2}, Tuple{ùëô1}, Tuple{BasisFunc{ùëô1, 1}, BasisFunc{ùëô2, 1}}} where {ùëô1, ùëô2}" href="#Quiqbox.mul-Union{Tuple{ùëô2}, Tuple{ùëô1}, Tuple{BasisFunc{ùëô1, 1}, BasisFunc{ùëô2, 1}}} where {ùëô1, ùëô2}"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(sgf1::BasisFunc{ùëô1, 1}, sgf2::BasisFunc{ùëô2, 1}; 
         normalizeGTO::Union{Bool, Missing}=missing)::BasisFunc{ùëô1+ùëô2, 1} where {ùëô1, ùëô2}

mul(a1::Real, a2::CompositeGTBasisFuncs{&lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing) -&gt; 
CompositeGTBasisFuncs{&lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{&lt;:Any, 1}, a2::CompositeGTBasisFuncs{&lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing) -&gt; 
CompositeGTBasisFuncs{&lt;:Any, 1}</code></pre><p>Multiplication between <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code>s such as <code>BasisFunc</code> and  <code>Quiqbox.BasisFuncMix</code>, or contraction coefficient multiplication between a <code>Real</code> number  and a <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code>. If <code>normalizeGTO</code> is set to <code>missing</code> (in  default), The <code>GaussFunc</code> in the output result will be normalized only if all the input  bases have <code>normalizeGTO = true</code>. The function can be called using <code>*</code> syntax.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1,1,1], ([2,1], [0.1, 0.2]))
BasisFunc{0, 2}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf2 = bf1 * 2
BasisFunc{0, 2}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; getindex.(getfield.(bf2.gauss, :con))
(0.2, 0.4)

julia&gt; bf3 = bf1 * bf2
BasisFunc{0, 3}(gauss, subshell, center)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L762-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.shift-Union{Tuple{GN}, Tuple{ùëô}, Tuple{Quiqbox.FloatingGTBasisFuncs{ùëô, GN, 1}, Vector{Int64}}} where {ùëô, GN}" href="#Quiqbox.shift-Union{Tuple{GN}, Tuple{ùëô}, Tuple{Quiqbox.FloatingGTBasisFuncs{ùëô, GN, 1}, Vector{Int64}}} where {ùëô, GN}"><code>Quiqbox.shift</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(bf::FloatingGTBasisFuncs{ùëô, GN, 1}, didjdk::Array{Int, 1}) where {ùëô, GN} -&gt; 
BasisFunc</code></pre><p>Shift (add) the angular momentum (Cartesian representation) given the a vector that  specifies the change of each pseudo-quantum number ùëëi, ùëëj, ùëëk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L903-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.decompose" href="#Quiqbox.decompose"><code>Quiqbox.decompose</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 2}</code></pre><p>Decompose a <code>FloatingGTBasisFuncs</code> into an <code>Array</code> of <code>BasisFunc</code>s. Each column represents  one orbital of the input basis function(s). If <code>splitGaussFunc</code> is <code>true</code>, then each column  consists of the <code>BasisFunc</code>s each with only 1 <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L921-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.basisSize" href="#Quiqbox.basisSize"><code>Quiqbox.basisSize</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basisSize(subshell::Union{String, Array{String, 1}}) -&gt; Tuple</code></pre><p>Return the size (number of orbitals) of each subshell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L958-L963">source</a></section><section><div><pre><code class="nohighlight hljs">basisSize(basisFunctions) -&gt; Tuple</code></pre><p>Return the numbers of orbitals of the input basis function(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L967-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText" href="#Quiqbox.genBasisFuncText"><code>Quiqbox.genBasisFuncText</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bf::FloatingGTBasisFuncs; norm=1.0, printCenter=true) -&gt; String</code></pre><p>Generate a <code>String</code> of the text of the input <code>FloatingGTBasisFuncs</code>. <code>norm</code> is the  additional normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate  will be added on the first line of the <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L986-L993">source</a></section><section><div><pre><code class="nohighlight hljs">genBasisFuncText(bs::Array{&lt;:FloatingGTBasisFuncs, 1}; 
                 norm=1.0, printCenter=true, groupCenters::Bool=true) -&gt; 
String</code></pre><p>Generate a <code>String</code> of the text of the input basis set. <code>norm</code> is the additional  normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate will be added  on the first line of the <code>String</code>. <code>groupCenters</code> determines whether the function will  group the basis functions with same center together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1005-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBFuncsFromText" href="#Quiqbox.genBFuncsFromText"><code>Quiqbox.genBFuncsFromText</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBFuncsFromText(content::String; adjustContent::Bool=false, 
                  adjustFunction::F=sciNotReplace, 
                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, 
                  center::Union{AbstractArray, 
                                Tuple{N, ParamBox}, 
                                Missing}=missing) where {N, F&lt;:Function} -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 1}</code></pre><p>Generate the basis set from a <code>String</code> of basis set in Gaussian format or the String output  from <code>genBasisFuncText</code>. For the former, <code>adjustContent</code> needs to be set to <code>true</code>.  <code>adjustFunction</code> is only applied when <code>adjustContent=true</code>, which in default is a  <code>function</code> used to detect and convert the format of the scientific notation in the String.</p><p><code>excludeFirstNlines</code> and <code>excludeLastNlines</code> are used to exclude first or last few lines of  the <code>String</code> if intent. <code>center</code> is used to assign a coordinate for all the basis functions  from the String; it can be a <code>Vector</code>, a <code>Tuple</code> of the positional <code>ParamBox</code>s; when it&#39;s  set to <code>missing</code>, it will try to read the center information from the input string, and  leave the center as <code>[NaN, NaN, Nan]</code> if it can&#39;t find one for the corresponding  <code>BasisFunc</code>. The coordinate information, if included, should be right above the subshell  information for the <code>BasisFunc</code>. E.g.:</p><pre><code class="nohighlight hljs">    &quot;&quot;&quot;
    X    1.0                 0.0                 0.0
    S    1   1.0
          2.0                 1.0
    &quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1041-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.assignCenter!" href="#Quiqbox.assignCenter!"><code>Quiqbox.assignCenter!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assignCenter!(center::AbstractArray, b::FloatingGTBasisFuncs) -&gt; NTuple{3, ParamBox}</code></pre><p>Assign a new coordinate to the center of the input <code>FloatingGTBasisFuncs</code>. Also return the  altered center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1110-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getParams" href="#Quiqbox.getParams"><code>Quiqbox.getParams</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParams(pbc::ParamBox, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Union{ParamBox, Nothing}

getParams(pbc::StructSpatialBasis, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}

getParams(pbc::Array, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}</code></pre><p>Return the parameter(s) stored in the input container. If keyword argument <code>symbol</code> is set  to <code>nothing</code>, then return all the different parameters; if it&#39;s set to the <code>Symbol</code> of a  parameter (e.g. the symbol of <code>ParamBox{T, V}</code> would be <code>V</code>), return only that type of  parameters (which might still have different indices). <code>onlyDifferentiable</code> determines  whether ignore non-differentiable parameters. If the 1st argument is an <code>Array</code>, the  entries must be <code>ParamBox</code> containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1141-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.copyBasis" href="#Quiqbox.copyBasis"><code>Quiqbox.copyBasis</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyBasis(b::GaussFunc, copyOutVal::Bool=true) -&gt; GaussFunc

copyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -&gt; CompositeGTBasisFuncs</code></pre><p>Return a copy of the input basis. If <code>copyOutVal</code> is set to <code>true</code>, then only the value(s)  of mapped data will be copied, i.e., <code>outValCopy</code> is used to copy the <code>ParamBox</code>s,  otherwise <code>inVarCopy</code> is used.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; e = Exponent(3.0, x-&gt;x^2)
ParamBox{Float64, :Œ±, :f_Œ±‚ÇÅ}(3.0)[‚àÇ][x_Œ±]

julia&gt; c = Contraction(2.0)
ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d]

julia&gt; gf1 = GaussFunc(e, c);

julia&gt; gf2 = copyBasis(gf1)
GaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(9.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])

julia&gt; gf1.xpn() == gf2.xpn()
true

julia&gt; (gf1.xpn[] |&gt; gf1.xpn.map) == gf2.xpn[]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1200-L1230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.uniqueParams!" href="#Quiqbox.uniqueParams!"><code>Quiqbox.uniqueParams!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniqueParams!(bs; filterMapping::Bool=false) -&gt; Array{&lt;:ParamBox, 1}</code></pre><p>Mark the parameters (<code>ParamBox</code>) in input bs which can a <code>Vector</code> of <code>GaussFunc</code> or  <code>FloatingGTBasisFuncs</code>. The identical parameters will be marked with same index.  <code>filterMapping</code>determines wether return the <code>ParamBox</code>s with identical fields except the  <code>map</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1301-L1309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVar" href="#Quiqbox.getVar"><code>Quiqbox.getVar</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVar(pb::ParamBox) -&gt; Symbolics.Num

getVar(container::StructSpatialBasis) -&gt; Array{Symbolics.Num, 1}</code></pre><p>Return the independent variable(s) of the input parameter container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1345-L1352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVarDict" href="#Quiqbox.getVarDict"><code>Quiqbox.getVarDict</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVarDict(obj::Union{ParamBox, StructSpatialBasis, Array}; 
           includeMapping::Bool=false) -&gt; 
Dict{Symbolics.Num, &lt;:Number}</code></pre><p>Return a <code>Dict</code> that stores the independent variable(s) of the parameter container(s) and  its(their) corresponding value(s). If <code>includeMapping = true</code>, then the dictionary will  also include the mapping relations between the mapped variables and the independent  variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1367-L1377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.expressionOf" href="#Quiqbox.expressionOf"><code>Quiqbox.expressionOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expressionOf(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; 
Array{&lt;:Symbolics.Num, 2}</code></pre><p>Return the expression(s) of a given <code>CompositeGTBasisFuncs</code> (e.g. <code>BasisFuncMix</code> or  <code>FloatingGTBasisFuncs</code>) as a <code>Matrix{&lt;:Symbolics.Num}</code>of which the column(s) corresponds to  different orbitals. If <code>splitGaussFunc</code> is <code>true</code>, the column(s) will be expanded  vertically such that the entries are <code>GaussFunc</code> inside the corresponding orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1474-L1483">source</a></section><section><div><pre><code class="nohighlight hljs">expressionOf(gf::GaussFunc) -&gt; Symbolics.Num</code></pre><p>Return the expression of a given <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1487-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.makeCenter" href="#Quiqbox.makeCenter"><code>Quiqbox.makeCenter</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeCenter(coord::Array{&lt;:Real, 1}; roundDigits::Int=-1) -&gt; NTuple{3, ParamBox}</code></pre><p>Generate a <code>Tuple</code> of coordinate <code>ParamBox</code>s for a basis function center coordinate given a  <code>Vector</code>. If <code>roundDigits &lt; 0</code> then there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Basis.jl#L1125-L1131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gridCoords" href="#Quiqbox.gridCoords"><code>Quiqbox.gridCoords</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gridCoords(gb::GridBox) -&gt; Array{Array{Float64, 1}, 1}</code></pre><p>Return the grid-point coordinates in <code>Vector</code>s given the <code>GriBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Box.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHF" href="#Quiqbox.runHF"><code>Quiqbox.runHF</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHF(bs::Union{BasisSetData, Array{&lt;:AbstractGTBasisFuncs, 1}}, 
      nuc::Array{String, 1}, 
      nucCoords::Array{&lt;:AbstractArray, 1}, 
      N::Union{NTuple{2, Int}, Int}=getCharge(nuc); 
      initialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=:GWH, 
      HFtype::Symbol=:RHF, 
      scfConfig::SCFconfig=defaultSCFconfig, 
      earlyTermination::Bool=true, 
      printInfo::Bool=true, 
      maxSteps::Int=1000) where {Float64&lt;:T&lt;:Float64} -&gt; HFfinalVars</code></pre><p>Main function to run Hartree-Fock in Quiqbox.</p><p>=== Positional argument(s) ===</p><p><code>bs::Union{BasisSetData, Array{&lt;:AbstractGTBasisFuncs, 1}}</code>: Basis set.</p><p><code>nuc::Array{String, 1}</code>: The element symbols of the nuclei for the Molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: The coordinates of the nuclei.</p><p><code>N::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p>=== Keyword argument(s) ===</p><p><code>initialC::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}</code>: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>scfConfig::SCFconfig</code>: SCF iteration configuration.</p><p><code>earlyTermination::Bool</code>: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the SCF converges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/HartreeFock.jl#L376-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHFcore" href="#Quiqbox.runHFcore"><code>Quiqbox.runHFcore</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHFcore(N::Union{NTuple{2, Int}, Int}, 
          Hcore::Array{T1, 2}, 
          HeeI::Array{T2, 4}, 
          S::Array{T3, 2}, 
          X::Array{T4, 2}=getX(S), 
          C::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}=guessC(S, Hcore; X);
          HFtype::Symbol=:RHF,  
          scfConfig::SCFconfig{L}, 
          earlyTermination::Bool=true, 
          printInfo::Bool=true, 
          maxSteps::Int=1000) where {Float64&lt;:T1&lt;:Float64, 
          Float64&lt;:T2&lt;:Float64, 
          Float64&lt;:T3&lt;:Float64, 
          Float64&lt;:T4&lt;:Float64, 
          Float64&lt;:T5&lt;:Float64, L}</code></pre><p>The core function of <code>runHF</code>.</p><p>=== Positional argument(s) ===</p><p><code>N::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p><code>Hcore::Array{T1, 2}</code>: Core Hamiltonian of electronic Hamiltonian.</p><p><code>HeeI::Array{T2, 4}</code>: The electron-electron interaction Hamiltonian which includes both the  Coulomb interactions and the Exchange Correlations.</p><p><code>S::Array{T3, 2}</code>: Overlap matrix of the corresponding basis set.</p><p><code>X::Array{T4, 2}</code>: Orthogonal transformation matrix of S. Default value is S^(-0.5).</p><p><code>C::Union{Array{T, 2}, NTuple{2, Array{T, 2}}, Symbol}</code>: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.</p><p>=== Keyword argument(s) ===</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>scfConfig::SCFconfig</code>: SCF iteration configuration.</p><p><code>earlyTermination::Bool</code>: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the SCF converges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/HartreeFock.jl#L454-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getMolOrbitals" href="#Quiqbox.getMolOrbitals"><code>Quiqbox.getMolOrbitals</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMolOrbitals(ens::Array{Float64, 1}, occus::Array{&lt;:Real, 1}, C::Matrix{Float64}, 
               spins::Array{String, 1}, 
               symms::Array{String, 1}=repeat([&quot;A&quot;], length(occus))) -&gt; 
Tuple{Vararg{getMolOrbitals}}</code></pre><p>A function that returns the molecular orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Molecule.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nnRepulsions" href="#Quiqbox.nnRepulsions"><code>Quiqbox.nnRepulsions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nnRepulsions(nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; Float64</code></pre><p>Calculate the nuclear-nuclear repulsion energy given the nuclei and their coordinates of a  molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Molecule.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.optimizeParams!" href="#Quiqbox.optimizeParams!"><code>Quiqbox.optimizeParams!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimizeParams!(bs::Array{&lt;:FloatingGTBasisFuncs, 1}, pbs::Array{&lt;:ParamBox, 1},
                nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}, 
                Ne::Union{NTuple{2, Int}, Int}=getCharge(nuc);
                Etarget::Float64=NaN, threshold::Float64=1e-4, maxSteps::Int=2000, 
                printInfo::Bool=true, GDmethod::F1=gradDescent!, HFtype::Symbol=:RHF, 
                ECmethod::F2=Quiqbox.defaultECmethod) where 
               {F1&lt;:Function, F2&lt;:Function} -&gt; 
Es::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}</code></pre><p>The main function to optimize the parameters of a given basis set.</p><p>=== Positional argument(s) ===</p><p><code>bs::Array{&lt;:FloatingGTBasisFuncs, 1}</code>: Basis set.</p><p><code>pbs::Array{&lt;:ParamBox, 1}</code>: The parameters to be optimized that are extracted from the  basis set.</p><p><code>nuc::Array{String, 1}</code>: The nuclei of the molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: The nuclei coordinates.</p><p><code>Ne::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively.</p><p>=== Keyword argument(s) ===</p><p><code>Etarget::Float64</code>: The target Hartree-Hock energy intent to achieve.</p><p><code>threshold::Float64</code>: The threshold for the convergence when evaluating difference between  the latest two energies.</p><p><code>maxSteps::Int</code>: Maximum allowed iteration steps regardless of whether the optimization  iteration converges.</p><p><code>printInfo::Bool</code>: Whether print out the information of each iteration step.</p><p><code>GDmethod::F1</code>: Applied gradient descent <code>Function</code>.</p><p><code>HFtype::Symbol</code>: Hartree-Fock type. Available values are <code>:RHF</code> and <code>:UHF</code>.</p><p><code>ECmethod::F2</code>: The <code>Function</code> used to update Hartree-Fock energy and coefficient matrix(s)  during the optimization iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Optimization.jl#L53-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.updateParams!" href="#Quiqbox.updateParams!"><code>Quiqbox.updateParams!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateParams!(pbs::Array{&lt;:ParamBox, 1}, grads::Array{&lt;:Real, 1}; 
              method::F=gradDescent!) where {F&lt;:Function} -&gt; Array{&lt;:ParamBox, 1}</code></pre><p>Given a <code>Vector</code> of parameters::<code>ParamBox</code> and its gradients with respect to each  parameter, update the <code>ParamBox</code>s and return the updated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Optimization.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradDescent!" href="#Quiqbox.gradDescent!"><code>Quiqbox.gradDescent!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradDescent!(pars::Vector{&lt;:Real}, grads::Vector{&lt;:Real}, Œ∑=0.001) -&gt; 
pars::Vector{&lt;:Real}</code></pre><p>Default gradient descent method in used in Quiqbox.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Optimization.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlap" href="#Quiqbox.overlap"><code>Quiqbox.overlap</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlap(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlaps" href="#Quiqbox.overlaps"><code>Quiqbox.overlaps</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlaps(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttraction" href="#Quiqbox.nucAttraction"><code>Quiqbox.nucAttraction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttraction(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, 
              nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions, and the nuclei with their coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttractions" href="#Quiqbox.nucAttractions"><code>Quiqbox.nucAttractions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, 
               nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>, and the nuclei with their  coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L134-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetic" href="#Quiqbox.elecKinetic"><code>Quiqbox.elecKinetic</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetic(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetics" href="#Quiqbox.elecKinetics"><code>Quiqbox.elecKinetics</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetics(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreHij" href="#Quiqbox.coreHij"><code>Quiqbox.coreHij</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreHij(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return a matrix element or block of the core Hamiltonian (an N√óN <code>Matrix</code> where N is the  number of spatial orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreH" href="#Quiqbox.coreH"><code>Quiqbox.coreH</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreH(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the core Hamiltonian matrix (an N√óN <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L200-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteraction" href="#Quiqbox.eeInteraction"><code>Quiqbox.eeInteraction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteraction(bf1::AbstractGTBasisFuncs, 
              bf2::AbstractGTBasisFuncs, 
              bf3::AbstractGTBasisFuncs, 
              bf4::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N√óN√óN√óN Tensor where N is the number of  spatial orbitals) given 4 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/TwoBody.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractions" href="#Quiqbox.eeInteractions"><code>Quiqbox.eeInteractions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N√óN√óN√óN Tensor where N is the number  of spatial orbitals) given a basis set in the form of an <code>Array</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/TwoBody.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractionsCore" href="#Quiqbox.eeInteractionsCore"><code>Quiqbox.eeInteractionsCore</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteractionsCore(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}; 
                   outputUniqueIndices::Bool=false) -&gt; 
Array{Float64, 5}, [Array{&lt;:Array{Int, 1}, 1}]</code></pre><p>Return the electron-electron interaction tensor (an N√óN√óN√óN√ó1 Tensor where N is the number  of spatial orbitals) given a basis set in the form of an <code>Array</code>.</p><p>If <code>outputUniqueIndices=true</code>, additionally return the indices for all the unique integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/TwoBody.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.oneBodyBFTensor" href="#Quiqbox.oneBodyBFTensor"><code>Quiqbox.oneBodyBFTensor</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oneBodyBFTensor(libcinFunc::Symbol, b1::AbstractGTBasisFuncs, 
                b2::AbstractGTBasisFuncs, nuclei::Array{String, 1}=String[], 
                nucleiCoords::Array{&lt;:AbstractArray, 1}=Array[]; 
                isGradient::Bool=false) -&gt; 
Array{Float64, 3}</code></pre><p>Core function for one-electron integrals.</p><p><code>libcinFunc::Symbol</code> specifies the backend <a href="https://github.com/sunqm/libcint">libcint</a>  function name, e.g. <code>&quot;int1e_nuc_cart&quot;</code> should be converted to <code>:int1e_nuc_cart</code> as the  input argument. If the integral does not need the information of nuclei and their  coordinates, those 2 arguments can be omitted. If the integral is a spacial gradient,  <code>isGradient</code> should be set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/OneBody.jl#L31-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.twoBodyBFTensor" href="#Quiqbox.twoBodyBFTensor"><code>Quiqbox.twoBodyBFTensor</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">twoBodyBFTensor(libcinFunc::Symbol, 
                b1::AbstractGTBasisFuncs, b2::AbstractGTBasisFuncs, 
                b3::AbstractGTBasisFuncs, b4::AbstractGTBasisFuncs; 
                isGradient::Bool=false) -&gt; 
Array{Float64, 5}</code></pre><p>Core function for one-electron integrals.</p><p><code>libcinFunc::Symbol</code> specifies the backend <a href="https://github.com/sunqm/libcint">libcint</a>  function name, e.g. <code>&quot;cint2e_cart&quot;</code> should be converted to <code>:cint2e_cart</code> as the input  argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/33a192d972fe2064ba68d765b664994958c9e65b/src/Integration/TwoBody.jl#L24-L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">¬´ Parameter Optimization</a><a class="docs-footer-nextpage" href="../coreType/">Core Types ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 28 October 2021 03:02">Thursday 28 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
