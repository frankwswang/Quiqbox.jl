<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions · Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/master/docs/src/coreFunction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent" href="#Quiqbox.genExponent"><code>Quiqbox.genExponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genExponent(e::Real, mapFunction::Function; canDiff::Bool=true, 
            roundDigits::Int=15, dataName::Symbol=:undef) -&gt; 
ParamBox{Float64, :α}

genExponent(e::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, 
            dataName::Symbol=:undef) where {T&lt;:Real} -&gt; 
ParamBox{Float64, :α}</code></pre><p>Construct a <code>ParamBox</code> for an exponent coefficient given a value. Keywords <code>mapFunction</code>  and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>. If  <code>roundDigits &lt; 0</code>, there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L54-L67">source</a></section><section><div><pre><code class="nohighlight hljs">genExponent(e::Real; roundDigits::Int=15) -&gt; ParamBox{Float64, :α}

genExponent(e::Array{Float64, 0}) -&gt; ParamBox{Float64, :α}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L79-L85">source</a></section><section><div><pre><code class="nohighlight hljs">genExponent(pb::ParamBox{Float64}) -&gt; ParamBox{Float64, :α}</code></pre><p>Convert a <code>ParamBox</code> to an exponent coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction" href="#Quiqbox.genContraction"><code>Quiqbox.genContraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genContraction(c::Real, mapFunction::Function; canDiff::Bool=true, 
            roundDigits::Int=15, dataName::Symbol=:undef) -&gt; 
ParamBox{Float64, :d}

genContraction(c::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, 
            dataName::Symbol=:undef) where {T&lt;:Real} -&gt; 
ParamBox{Float64, :d}</code></pre><p>Construct a <code>ParamBox</code> for an contraction coefficient given a value. Keywords <code>mapFunction</code>  and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>. If  <code>roundDigits &lt; 0</code>, there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L101-L114">source</a></section><section><div><pre><code class="nohighlight hljs">genContraction(c::Real; roundDigits::Int=15) -&gt; ParamBox{Float64, :d}

genContraction(c::Array{Float64, 0}) -&gt; ParamBox{Float64, :d}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L124-L130">source</a></section><section><div><pre><code class="nohighlight hljs">genContraction(pb::ParamBox{Float64}) -&gt; ParamBox{Float64, :d}</code></pre><p>Convert a <code>ParamBox</code> to an exponent coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint" href="#Quiqbox.genSpatialPoint"><code>Quiqbox.genSpatialPoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(point::Union{Tuple, Vector}, mapFunction::F=itself; canDiff::Bool=true, 
                roundDigits::Int=15, dataName::Symbol=:undef)</code></pre><p>Return the parameter(s) of a spatial coordinate in terms of <code>ParamBox</code>. Keywords  <code>mapFunction</code> and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>.  If <code>roundDigits &lt; 0</code> or the input <code>c</code> is a 0-d <code>Array</code>, there won&#39;t be rounding for input  data.</p><p>≡≡≡ Method 1 ≡≡≡</p><pre><code class="nohighlight hljs">genSpatialPoint(point::Vector, mapFunction::F=itself; canDiff::Bool=true, 
                roundDigits::Int=15, dataName::Symbol=:undef) -&gt; 
Tuple{ParamBox{Float64, :X}, 
      ParamBox{Float64, :Y}, 
      ParamBox{Float64, :Z}}</code></pre><p>Return the parameters that represent a spatial point. The entry of input <code>Vector</code> can  be either a <code>Real</code> number or a <code>Array{Float64, 0}</code>.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; v1 = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; genSpatialPoint(v1)
(ParamBox{Float64, :X, Quiqbox.FLevel{1, 0}}(1.0)[∂][X], ParamBox{Float64, :Y, Quiqbox.FLevel{1, 0}}(2.0)[∂][Y], ParamBox{Float64, :Z, Quiqbox.FLevel{1, 0}}(3.0)[∂][Z])

julia&gt; v2 = [fill(1.0), 2, 3]
3-element Vector{Any}:
  fill(1.0)
 2
 3

julia&gt; p2 = genSpatialPoint(v2); p2[1]
ParamBox{Float64, :X, Quiqbox.FLevel{1, 0}}(1.0)[∂][X]

julia&gt; v2[1][] = 1.2
1.2

julia&gt; p2[1]
ParamBox{Float64, :X, Quiqbox.FLevel{1, 0}}(1.2)[∂][X]</code></pre><p>≡≡≡ Method 2 ≡≡≡</p><pre><code class="nohighlight hljs">genSpatialPoint(point::Tuple{Union{Real, Array{Float64, 0}}, Int}, 
                mapFunction::F=itself; canDiff::Bool=true, roundDigits::Int=15, 
                dataName::Symbol=:undef) -&gt; 
ParamBox{Float64}</code></pre><p>Return the component of a spatial point given its value (or 0-D container) and index.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; genSpatialPoint((1.2, 1))
ParamBox{Float64, :X, Quiqbox.FLevel{1, 0}}(1.2)[∂][X]

julia&gt; pointY1 = fill(2.0)
0-dimensional Array{Float64, 0}:
2.0

julia&gt; Y1 = genSpatialPoint((pointY1, 2))
ParamBox{Float64, :Y, Quiqbox.FLevel{1, 0}}(2.0)[∂][Y]

julia&gt; pointY1[] = 1.5
1.5

julia&gt; Y1
ParamBox{Float64, :Y, Quiqbox.FLevel{1, 0}}(1.5)[∂][Y]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L150-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inValOf" href="#Quiqbox.inValOf"><code>Quiqbox.inValOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of stored data (independent variable) of the input <code>ParamBox</code>. Equivalent  to <code>pb[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymOf" href="#Quiqbox.inSymOf"><code>Quiqbox.inSymOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inSymOf(pb::ParamBox) -&gt; Symbolics.Num</code></pre><p>Return the variable<code>::Symbolics.Num</code> of stored data (independent variable) of the input  <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymValOf" href="#Quiqbox.inSymValOf"><code>Quiqbox.inSymValOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inSymValOf(pb::ParamBox{T}) where {T} -&gt; ::Pair{Symbolics.Num, T}</code></pre><p>Return a <code>Pair</code> of the stored independent variable of the input <code>ParamBox</code> and its  corresponding value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValOf" href="#Quiqbox.outValOf"><code>Quiqbox.outValOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of mapped data (dependent variable) of the input <code>ParamBox</code>. Equivalent to  <code>pb()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L188-L194">source</a></section></article><pre><code class="language- hljs">outSymOf</code></pre><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dataOf" href="#Quiqbox.dataOf"><code>Quiqbox.dataOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dataOf(pb::ParamBox{T}) where {T} -&gt; Array{T, 0}</code></pre><p>Return the 0-D <code>Array</code> of the data stored in the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mapOf" href="#Quiqbox.mapOf"><code>Quiqbox.mapOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapOf(pb::ParamBox) -&gt; Function</code></pre><p>Return the mapping function of the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValCopy" href="#Quiqbox.outValCopy"><code>Quiqbox.outValCopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outValCopy(pb::ParamBox{T, V}) where {T} -&gt; ParamBox{T, V, Quiqbox.FLevel{1, 0}}</code></pre><p>Return a new <code>ParamBox</code> of which the stored data is a <strong>deep copy</strong> of the mapped data from  the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inVarCopy" href="#Quiqbox.inVarCopy"><code>Quiqbox.inVarCopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inVarCopy(pb::ParamBox) -&gt; ParamBox{&lt;:Number, &lt;:Any, Quiqbox.FLevel{1, 0}}</code></pre><p>Return a new <code>ParamBox</code> of which the stored data is a <strong>shallow copy</strong> of the stored data  from the input <code>ParamBox</code>.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; pb1 = ParamBox(-2.0, :a, abs)
ParamBox{Float64, :a, Quiqbox.FLevel{2, 0}}(-2.0)[∂][x_a]

julia&gt; pb2 = inVarCopy(pb1)
ParamBox{Float64, :x_a, Quiqbox.FLevel{1, 0}}(-2.0)[∂][x_a]

julia&gt; pb1[] == pb2[] == -2.0
true

julia&gt; pb1[] = 1.1
1.1

julia&gt; pb2[]
1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L267-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.enableDiff!" href="#Quiqbox.enableDiff!"><code>Quiqbox.enableDiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the input <code>ParamBox</code> as &quot;differentiable&quot; and return the marked <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.disableDiff!" href="#Quiqbox.disableDiff!"><code>Quiqbox.disableDiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the input <code>ParamBox</code> as &quot;non-differentiable&quot; and return the marked <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L312-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isDiffParam" href="#Quiqbox.isDiffParam"><code>Quiqbox.isDiffParam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isDiffParam(pb::ParamBox) -&gt; Bool</code></pre><p>Return the Boolean value of if the input <code>ParamBox</code> is &quot;differentiable&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.toggleDiff!" href="#Quiqbox.toggleDiff!"><code>Quiqbox.toggleDiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toggleDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Toggle the differentiability (<code>pb.canDiff[]</code>) of the input <code>ParamBox</code> and return the  altered result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeMapping" href="#Quiqbox.changeMapping"><code>Quiqbox.changeMapping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">changeMapping(pb::ParamBox{T, V}, mapFunction::F, dataName::Symbol=:undef; 
          index::Union{Int, Nothing}=nothing, canDiff::Bool=true) where 
         {T, V, F&lt;:Function} -&gt; 
ParamBox{T, V}</code></pre><p>Return a <code>ParamBox</code> that contains the input <code>ParamBox</code>&#39;s <code>data::Array{T, 0}</code> with the  newly assigned mapping function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Parameters.jl#L343-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFunc" href="#Quiqbox.genBasisFunc"><code>Quiqbox.genBasisFunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFunc(center::Union{AbstractArray, NTuple{3, ParamBox}, Missing}, 
             args..., kws...) -&gt; 
B where {B&lt;:Union{FloatingGTBasisFuncs, Array{&lt;:FloatingGTBasisFuncs}}}</code></pre><p>Constructor of <code>BasisFunc</code> and <code>BasisFuncs</code>, but it also returns different kinds of  collections of them based on the applied methods. The first argument <code>center</code> can be a 3-D  coordinate (e.g. <code>Array{Float64, 1}</code>), a <code>NTuple{3}</code> of spatial points (e.g. generated by  <code>genSpatialPoint</code>), or simply set to <code>missing</code> for later assignment.</p><p>≡≡≡ Method 1 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(center, gs::Array{GaussFunc, 1}, 
             ijkOrijks::Union{T, Array{T, 1}, NTuple{&lt;:Any, T}}; 
             normalizeGTO::Bool=false) where {T &lt;: NTuple{3, Int}}</code></pre><p><code>ijkOrijks</code> is the Array of the pseudo-quantum number(s) to specify the angular  momentum(s). E.g., s is (0,0,0) and p is ((1,0,0), (0,1,0), (0,0,1)).</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), (0,1,0))
BasisFunc{1, 1}(center, gauss)[X⁰Y¹Z⁰][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 2 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(center, gExpsANDgCons::NTuple{2, Array{&lt;:Real, 1}}, subshell=&quot;S&quot;; kw...)</code></pre><p>Instead of directly inputting <code>GaussFunc</code>, one can also input a 2-element <code>Tuple</code> of the  exponent(s) and contraction coefficient(s) corresponding to the same <code>GaussFunc</code>(s).</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], (2, 1), &quot;P&quot;)
BasisFuncs{1, 1, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], ([2, 1.5], [1, 0.5]), &quot;P&quot;)
BasisFuncs{1, 2, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 3 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(center, gs::Union{GaussFunc, Array{GaussFunc, 1}}, subshell::String=&quot;S&quot;, 
             ijkFilter::NTuple{N, Bool}=fill(true, SubshellSizeList[subshell])|&gt;Tuple; 
             normalizeGTO::Bool=false) where {N}</code></pre><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;S&quot;)
BasisFunc{0, 1}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], GaussFunc(2,1), &quot;P&quot;)
BasisFuncs{1, 1, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]</code></pre><p>≡≡≡ Method 4 ≡≡≡</p><pre><code class="nohighlight hljs">genBasisFunc(center, BSKeyANDnuc::Array{Tuple{String, String}, 1})</code></pre><p>If the user wants to construct existed atomic basis set(s), they can use the (<code>Array</code> of)  <code>(BS_name, Atom_name)</code> as the second input. If the atom is omitted, then basis set for H  is used.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0,0,0], (&quot;STO-3G&quot;, &quot;Li&quot;))
3-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], &quot;STO-3G&quot;)
1-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [&quot;STO-2G&quot;, &quot;STO-3G&quot;])
2-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 2}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0,0,0], [(&quot;STO-2G&quot;, &quot;He&quot;), (&quot;STO-3G&quot;, &quot;O&quot;)])
4-element Vector{Quiqbox.FloatingGTBasisFuncs}:
 BasisFunc{0, 2}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][0.0, 0.0, 0.0]
 BasisFuncs{1, 3, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L349-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs" href="#Quiqbox.sortBasisFuncs"><code>Quiqbox.sortBasisFuncs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::Array{&lt;:FloatingGTBasisFuncs}; groupCenters::Bool=false) -&gt; Array</code></pre><p>Sort basis functions. If <code>groupCenters = true</code>, Then the function will return an  <code>Array{&lt;:Array{&lt;:FloatingGTBasisFuncs, 1}, 1}</code> in which the arrays are grouped basis  functions with same center coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L611-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerOf" href="#Quiqbox.centerOf"><code>Quiqbox.centerOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centerOf(bf::FloatingGTBasisFuncs) -&gt; 
Tuple{ParamBox{Float64, X}, 
      ParamBox{Float64, Y}, 
      ParamBox{Float64, Z}}</code></pre><p>Return the center of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L644-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerCoordOf" href="#Quiqbox.centerCoordOf"><code>Quiqbox.centerCoordOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centerCoordOf(bf::FloatingGTBasisFuncs) -&gt; Vector{Float64}</code></pre><p>Return the center coordinate of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L656-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.add-Union{Tuple{BasisFuncs{𝑙, GN, 1}}, Tuple{GN}, Tuple{𝑙}} where {𝑙, GN}" href="#Quiqbox.add-Union{Tuple{BasisFuncs{𝑙, GN, 1}}, Tuple{GN}, Tuple{𝑙}} where {𝑙, GN}"><code>Quiqbox.add</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(b::CompositeGTBasisFuncs{&lt;:Any, 1}) -&gt; CompositeGTBasisFuncs{&lt;:Any, 1}

add(b1::CompositeGTBasisFuncs{&lt;:Any, 1}, b2::CompositeGTBasisFuncs{&lt;:Any, 1}) -&gt;
CompositeGTBasisFuncs{&lt;:Any, 1}</code></pre><p>Addition between <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code> such as <code>BasisFunc</code> and  <code>Quiqbox.BasisFuncMix</code>. It can be called using <code>+</code> syntax.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1,1,1], (2,1))
BasisFunc{0, 1}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; bf2 = genBasisFunc([1,1,1], (2,2))
BasisFunc{0, 1}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; bf3 = bf1 + bf2
BasisFunc{0, 1}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; bf3.gauss[1].con[]
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L795-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Tuple{GaussFunc, Real}" href="#Quiqbox.mul-Tuple{GaussFunc, Real}"><code>Quiqbox.mul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(gf::GaussFunc, coeff::Real) -&gt; GaussFunc

mul(coeff::Real, gf::GaussFunc) -&gt; GaussFunc

mul(gf1::GaussFunc, gf2::GaussFunc) -&gt; GaussFunc</code></pre><p>Multiplication between <code>GaussFunc</code>s or contraction coefficient multiplication between a  <code>Real</code> number and a <code>GaussFunc</code>. It can be called using <code>*</code> syntax.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; gf1 = GaussFunc(3,1)
GaussFunc(xpn=ParamBox{Float64, :α, Quiqbox.FLevel{1, 0}}(3.0)[∂][α], con=ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(1.0)[∂][d])

julia&gt; gf1 * 2
GaussFunc(xpn=ParamBox{Float64, :α, Quiqbox.FLevel{1, 0}}(3.0)[∂][α], con=ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(2.0)[∂][d])

julia&gt; gf1 * gf1
GaussFunc(xpn=ParamBox{Float64, :α, Quiqbox.FLevel{1, 0}}(6.0)[∂][α], con=ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(1.0)[∂][d])

julia&gt; gf1 * 2 * gf1
GaussFunc(xpn=ParamBox{Float64, :α, Quiqbox.FLevel{1, 0}}(6.0)[∂][α], con=ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(2.0)[∂][d])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L894-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{𝑙2}, Tuple{𝑙1}, Tuple{BasisFunc{𝑙1, 1}, BasisFunc{𝑙2, 1}}} where {𝑙1, 𝑙2}" href="#Quiqbox.mul-Union{Tuple{𝑙2}, Tuple{𝑙1}, Tuple{BasisFunc{𝑙1, 1}, BasisFunc{𝑙2, 1}}} where {𝑙1, 𝑙2}"><code>Quiqbox.mul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(sgf1::BasisFunc{𝑙1, 1}, sgf2::BasisFunc{𝑙2, 1}; 
         normalizeGTO::Union{Bool, Missing}=missing)::BasisFunc{𝑙1+𝑙2, 1} where {𝑙1, 𝑙2}

mul(a1::Real, a2::CompositeGTBasisFuncs{&lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing) -&gt; 
CompositeGTBasisFuncs{&lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{&lt;:Any, 1}, a2::CompositeGTBasisFuncs{&lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing) -&gt; 
CompositeGTBasisFuncs{&lt;:Any, 1}</code></pre><p>Multiplication between <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code>s such as <code>BasisFunc</code> and  <code>Quiqbox.BasisFuncMix</code>, or contraction coefficient multiplication between a <code>Real</code> number  and a <code>CompositeGTBasisFuncs{&lt;:Any, 1}</code>. If <code>normalizeGTO</code> is set to <code>missing</code> (in  default), The <code>GaussFunc</code> in the output result will be normalized only if all the input  bases have <code>normalizeGTO = true</code>. The function can be called using <code>*</code> syntax.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1,1,1], ([2,1], [0.1, 0.2]))
BasisFunc{0, 2}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; bf2 = bf1 * 2
BasisFunc{0, 2}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; getindex.(getfield.(bf2.gauss, :con))
(0.2, 0.4)

julia&gt; bf3 = bf1 * bf2
BasisFunc{0, 3}(center, gauss)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L947-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.shift-Union{Tuple{GN}, Tuple{𝑙}, Tuple{Quiqbox.FloatingGTBasisFuncs{𝑙, GN, 1}, AbstractArray{var&quot;#s47&quot;, N} where {var&quot;#s47&quot;&lt;:Real, N}}} where {𝑙, GN}" href="#Quiqbox.shift-Union{Tuple{GN}, Tuple{𝑙}, Tuple{Quiqbox.FloatingGTBasisFuncs{𝑙, GN, 1}, AbstractArray{var&quot;#s47&quot;, N} where {var&quot;#s47&quot;&lt;:Real, N}}} where {𝑙, GN}"><code>Quiqbox.shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(bf::FloatingGTBasisFuncs{𝑙, GN, 1}, 
      didjdk::Union{Vector{&lt;:Real}, NTuple{3, Int}}) where {𝑙, GN} -&gt; 
BasisFunc</code></pre><p>Shift (add) the angular momentum (Cartesian representation) given the a vector that  specifies the change of each pseudo-quantum number 𝑑i, 𝑑j, 𝑑k.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1136-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.decompose" href="#Quiqbox.decompose"><code>Quiqbox.decompose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; Matrix{&lt;:BasisFunc}</code></pre><p>Decompose a <code>FloatingGTBasisFuncs</code> into an <code>Array</code> of <code>BasisFunc</code>s. Each column represents  one orbital of the input basis function(s). If <code>splitGaussFunc</code> is <code>true</code>, then each column  consists of the <code>BasisFunc</code>s each with only 1 <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1155-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.basisSize" href="#Quiqbox.basisSize"><code>Quiqbox.basisSize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basisSize(subshell::String) -&gt; Int</code></pre><p>Return the size (number of orbitals) of each subshell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1200-L1205">source</a></section><section><div><pre><code class="nohighlight hljs">basisSize(b::CompositeGTBasisFuncs) -&gt; Int</code></pre><p>Return the numbers of orbitals of the input basis function(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1208-L1213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText" href="#Quiqbox.genBasisFuncText"><code>Quiqbox.genBasisFuncText</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bf::FloatingGTBasisFuncs; norm=1.0, printCenter=true) -&gt; String</code></pre><p>Generate a <code>String</code> of the text of the input <code>FloatingGTBasisFuncs</code>. <code>norm</code> is the  additional normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate  will be added on the first line of the <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1227-L1234">source</a></section><section><div><pre><code class="nohighlight hljs">genBasisFuncText(bs::Array{&lt;:FloatingGTBasisFuncs, 1}; 
                 norm=1.0, printCenter=true, groupCenters::Bool=true) -&gt; 
String</code></pre><p>Generate a <code>String</code> of the text of the input basis set. <code>norm</code> is the additional  normalization factor. If <code>printCenter</code> is <code>true</code>, the center coordinate will be added  on the first line of the <code>String</code>. <code>groupCenters</code> determines whether the function will  group the basis functions with same center together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1244-L1254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBFuncsFromText" href="#Quiqbox.genBFuncsFromText"><code>Quiqbox.genBFuncsFromText</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genBFuncsFromText(content::String; adjustContent::Bool=false, 
                  adjustFunction::F=sciNotReplace, 
                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, 
                  center::Union{AbstractArray, 
                                Tuple{N, ParamBox}, 
                                Missing}=missing, 
                  unlinkCenter::Bool=false) where {N, F&lt;:Function} -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 1}</code></pre><p>Generate the basis set from a <code>String</code> of basis set in Gaussian format or the String output  from <code>genBasisFuncText</code>. For the former, <code>adjustContent</code> needs to be set to <code>true</code>.  <code>adjustFunction</code> is only applied when <code>adjustContent=true</code>, which in default is a  <code>function</code> used to detect and convert the format of the scientific notation in the String.</p><p><code>excludeFirstNlines</code> and <code>excludeLastNlines</code> are used to exclude first or last few lines of  the <code>String</code> if intent. <code>center</code> is used to assign a coordinate for all the basis functions  from the String; it can be a <code>Vector</code>, a <code>Tuple</code> of the positional <code>ParamBox</code>s; when it&#39;s  set to <code>missing</code>, it will try to read the center information from the input string, and  leave the center as <code>[NaN, NaN, Nan]</code> if it can&#39;t find one for the corresponding  <code>BasisFunc</code>. If <code>unlinkCenter = true</code>, the center of each basis function is a <code>deepcopy</code> of  the input <code>center</code>. The coordinate information, if included, should be right above the  subshell information for the <code>BasisFunc</code>. E.g.:</p><pre><code class="nohighlight hljs">    &quot;&quot;&quot;
    X        1.0                           0.0                           0.0                    
    S    1   1.0
             2.0                           1.0
    &quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1283-L1314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.assignCenter!" href="#Quiqbox.assignCenter!"><code>Quiqbox.assignCenter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assignCenter!(center::AbstractArray, b::FloatingGTBasisFuncs) -&gt; NTuple{3, ParamBox}</code></pre><p>Assign a new coordinate to the center of the input <code>FloatingGTBasisFuncs</code>. Also return the  altered center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1356-L1362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getParams" href="#Quiqbox.getParams"><code>Quiqbox.getParams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParams(pbc::ParamBox, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Union{ParamBox, Nothing}

getParams(pbc::Quiqbox.StructSpatialBasis, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}

getParams(pbc::Array, symbol::Union{Symbol, Nothing}=nothing; 
          onlyDifferentiable::Bool=false) -&gt; 
Array{&lt;:ParamBox, 1}</code></pre><p>Return the parameter(s) stored in the input container. If keyword argument <code>symbol</code> is set  to <code>nothing</code>, then return all the different parameters; if it&#39;s set to the <code>Symbol</code> of a  parameter (e.g. the symbol of <code>ParamBox{T, V}</code> would be <code>V</code>), return only that type of  parameters (which might still have different indices). <code>onlyDifferentiable</code> determines  whether ignore non-differentiable parameters. If the 1st argument is an <code>Array</code>, the  entries must be <code>ParamBox</code> containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1387-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.copyBasis" href="#Quiqbox.copyBasis"><code>Quiqbox.copyBasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyBasis(b::GaussFunc, copyOutVal::Bool=true) -&gt; GaussFunc

copyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -&gt; CompositeGTBasisFuncs</code></pre><p>Return a copy of the input basis. If <code>copyOutVal</code> is set to <code>true</code>, then only the value(s)  of mapped data will be copied, i.e., <code>outValCopy</code> is used to copy the <code>ParamBox</code>s,  otherwise <code>inVarCopy</code> is used.</p><p>≡≡≡ Example(s) ≡≡≡</p><pre><code class="language-julia-repl hljs">julia&gt; e = genExponent(3.0, x-&gt;x^2)
ParamBox{Float64, :α, Quiqbox.FLevel{2, 0}}(3.0)[∂][x_α]

julia&gt; c = genContraction(2.0)
ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(2.0)[∂][d]

julia&gt; gf1 = GaussFunc(e, c);

julia&gt; gf2 = copyBasis(gf1)
GaussFunc(xpn=ParamBox{Float64, :α, Quiqbox.FLevel{1, 0}}(9.0)[∂][α], con=ParamBox{Float64, :d, Quiqbox.FLevel{1, 0}}(2.0)[∂][d])

julia&gt; gf1.xpn() == gf2.xpn()
true

julia&gt; (gf1.xpn[] |&gt; gf1.xpn.map) == gf2.xpn[]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1444-L1474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.markParams!" href="#Quiqbox.markParams!"><code>Quiqbox.markParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">markParams!(b::Union{Array{T}, T}, filterMapping::Bool=false)  where 
           {T&lt;:Quiqbox.StructSpatialBasis} -&gt; 
Array{&lt;:ParamBox, 1}</code></pre><p>Mark the parameters (<code>ParamBox</code>) in input bs which can a <code>Vector</code> of <code>GaussFunc</code> or  <code>FloatingGTBasisFuncs</code>. The identical parameters will be marked with same index.  <code>filterMapping</code>determines weather filter out (i.e. not return) <code>ParamBox</code>s that have same  independent variables despite they may have different mapping functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1507-L1517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVar" href="#Quiqbox.getVar"><code>Quiqbox.getVar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVar(pb::ParamBox) -&gt; Symbolics.Num

getVar(container::Quiqbox.StructSpatialBasis) -&gt; Array{Symbolics.Num, 1}</code></pre><p>Return the independent variable(s) of the input parameter container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1580-L1587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVarDict" href="#Quiqbox.getVarDict"><code>Quiqbox.getVarDict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVarDict(obj::Union{ParamBox, Quiqbox.StructSpatialBasis, Array}; 
           includeMapping::Bool=false) -&gt; 
Dict{Symbolics.Num, &lt;:Number}</code></pre><p>Return a <code>Dict</code> that stores the independent variable(s) of the parameter container(s) and  its(their) corresponding value(s). If <code>includeMapping = true</code>, then the dictionary will  also include the mapping relations between the mapped variables and the independent  variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1602-L1612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.expressionOf" href="#Quiqbox.expressionOf"><code>Quiqbox.expressionOf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expressionOf(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -&gt; 
Array{&lt;:Symbolics.Num, 2}</code></pre><p>Return the expression(s) of a given <code>CompositeGTBasisFuncs</code> (e.g. <code>BasisFuncMix</code> or  <code>FloatingGTBasisFuncs</code>) as a <code>Matrix{&lt;:Symbolics.Num}</code>of which the column(s) corresponds to  different orbitals. If <code>splitGaussFunc</code> is <code>true</code>, the column(s) will be expanded  vertically such that the entries are <code>GaussFunc</code> inside the corresponding orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1694-L1703">source</a></section><section><div><pre><code class="nohighlight hljs">expressionOf(gf::GaussFunc) -&gt; Symbolics.Num</code></pre><p>Return the expression of a given <code>GaussFunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1707-L1712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.makeCenter" href="#Quiqbox.makeCenter"><code>Quiqbox.makeCenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeCenter(coord::Array{&lt;:Real, 1}; roundDigits::Int=-1) -&gt; NTuple{3, ParamBox}</code></pre><p>Generate a <code>Tuple</code> of coordinate <code>ParamBox</code>s for a basis function center coordinate given a  <code>Vector</code>. If <code>roundDigits &lt; 0</code> then there won&#39;t be rounding for input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Basis.jl#L1371-L1377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gridCoords" href="#Quiqbox.gridCoords"><code>Quiqbox.gridCoords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gridCoords(gb::GridBox) -&gt; Array{Array{Float64, 1}, 1}</code></pre><p>Return the grid-point coordinates in <code>Vector</code>s given the <code>GriBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Box.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHF" href="#Quiqbox.runHF"><code>Quiqbox.runHF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHF(gtb::Union{BasisSetData, Vector{&lt;:AbstractGTBasisFuncs}}, 
      nuc::Vector{String}, 
      nucCoords::Vector{&lt;:AbstractArray{&lt;:Real}}, 
      N::Int=getCharge(nuc), 
      config::HFconfig{HFT}=HFconfig();
      printInfo::Bool=true) where {HFT} -&gt; 
HFfinalVars{HFT}</code></pre><p>Main function to run Hartree-Fock in Quiqbox.</p><p>=== Positional argument(s) ===</p><p><code>bs::Union{BasisSetData, Array{&lt;:AbstractGTBasisFuncs, 1}}</code>: Basis set.</p><p><code>nuc::Array{String, 1}</code>: The element symbols of the nuclei for the Molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: Nuclei coordinates.</p><p><code>N::Int</code>: Total number of electrons.</p><p><code>config::HFconfig</code>: The Configuration of selected Hartree-Fock method. For more information  please refer to <code>HFconfig</code>.</p><p>=== Keyword argument(s) ===</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/HartreeFock.jl#L495-L522">source</a></section><section><div><pre><code class="nohighlight hljs">runHF(gtb::Union{BasisSetData, Vector{&lt;:AbstractGTBasisFuncs}}, 
      nuc::Vector{String}, 
      nucCoords::Vector{&lt;:AbstractArray{&lt;:Real}}, 
      config::HFconfig{HFT}=HFconfig(), 
      N::Int=getCharge(nuc);
      printInfo::Bool=true) where {HFT} -&gt; 
HFfinalVars{HFT}</code></pre><p>Another method of <code>runHF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/HartreeFock.jl#L544-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHFcore" href="#Quiqbox.runHFcore"><code>Quiqbox.runHFcore</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runHFcore(scfConfig::SCFconfig, 
          N::Union{NTuple{2, Int}, Int}, 
          Hcore::Array{Float64, 2}, 
          HeeI::Array{Float64, 4}, 
          S::Array{Float64, 2}, 
          X::Array{Float64, 2}, 
          C0::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}, 
          printInfo::Bool=false, 
          maxStep::Int=1000, 
          earlyTermination::Bool=true) -&gt; 
HFfinalVars</code></pre><p>The core function of <code>runHF</code>.</p><p>=== Positional argument(s) ===</p><p><code>scfConfig::SCFconfig</code>: SCF iteration configuration.</p><p><code>N::Union{NTuple{2, Int}, Int}</code>: The total number of electrons or the numbers of electrons  with different spins respectively. When the latter is input, an UHF is performed.</p><p><code>Hcore::Array{Float64, 2}</code>: Core Hamiltonian of electronic Hamiltonian.</p><p><code>HeeI::Array{Float64, 4}</code>: The electron-electron interaction Hamiltonian which includes both the  Coulomb interactions and the Exchange Correlations.</p><p><code>S::Array{Float64, 2}</code>: Overlap matrix of the corresponding basis set.</p><p><code>X::Array{Float64, 2}</code>: Orthogonal transformation matrix of S. Default value is S^(-0.5).</p><p><code>C0::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}</code>: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps.</p><p><code>maxStep::Int</code>: Maximum allowed iteration steps regardless of whether the SCF converges.</p><p><code>earlyTermination::Bool</code>: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/HartreeFock.jl#L564-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getMolOrbitals" href="#Quiqbox.getMolOrbitals"><code>Quiqbox.getMolOrbitals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMolOrbitals(ens::Array{Float64, 1}, occus::Array{&lt;:Real, 1}, C::Matrix{Float64}, 
               spins::Array{String, 1}, 
               symms::Array{String, 1}=repeat([&quot;A&quot;], length(occus))) -&gt; 
Tuple{Vararg{getMolOrbitals}}</code></pre><p>A function that returns the molecular orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Molecule.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nnRepulsions" href="#Quiqbox.nnRepulsions"><code>Quiqbox.nnRepulsions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nnRepulsions(nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; Float64</code></pre><p>Calculate the nuclear-nuclear repulsion energy given the nuclei and their coordinates of a  molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Molecule.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.optimizeParams!" href="#Quiqbox.optimizeParams!"><code>Quiqbox.optimizeParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimizeParams!(pbs::Array{&lt;:ParamBox, 1}, 
                bs::Array{&lt;:AbstractGTBasisFuncs, 1}, 
                nuc::Array{String, 1}, 
                nucCoords::Array{&lt;:AbstractArray, 1}, 
                N::Int=getCharge(nuc), 
                config::POconfig{M, T, F}=POconfig(); 
                printInfo::Bool=true
Es::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}</code></pre><p>The main function to optimize the parameters of a given basis set.</p><p>=== Positional argument(s) ===</p><p><code>pbs::Array{&lt;:ParamBox, 1}</code>: The parameters to be optimized that are extracted from the  basis set.</p><p><code>bs::Array{&lt;:AbstractGTBasisFuncs, 1}</code>: Basis set.</p><p><code>nuc::Array{String, 1}</code>: The element symbols of the nuclei for the Molecule.</p><p><code>nucCoords::Array{&lt;:AbstractArray, 1}</code>: Nuclei coordinates.</p><p><code>N::Int</code>: Total number of electrons.</p><p><code>config::POconfig</code>: The Configuration of selected parameter optimization method. For more  information please refer to <code>POconfig</code>.</p><p>=== Keyword argument(s) ===</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Optimization.jl#L135-L167">source</a></section><section><div><pre><code class="nohighlight hljs">optimizeParams!(pbs::Array{&lt;:ParamBox, 1}, 
                bs::Array{&lt;:AbstractGTBasisFuncs, 1}, 
                nuc::Array{String, 1}, 
                nucCoords::Array{&lt;:AbstractArray, 1}, 
                config::POconfig{M, T, F}=POconfig(), 
                N::Int=getCharge(nuc); 
                printInfo::Bool=true
Es::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}</code></pre><p>Another method of <code>optimizeParams!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Optimization.jl#L242-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.updateParams!" href="#Quiqbox.updateParams!"><code>Quiqbox.updateParams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateParams!(pbs::Array{&lt;:ParamBox, 1}, grads::Array{&lt;:Real, 1}, 
              method::F=gradDescent!) where {F&lt;:Function} -&gt; Array{&lt;:ParamBox, 1}</code></pre><p>Given a <code>Vector</code> of parameters::<code>ParamBox</code> and its gradients with respect to each  parameter, update the <code>ParamBox</code>s and return the updated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Optimization.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradDescent!" href="#Quiqbox.gradDescent!"><code>Quiqbox.gradDescent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gradDescent!(pars::Vector{&lt;:Real}, grads::Vector{&lt;:Real}, 
             η=0.001, clipThreshold=0.08*sqrt(length(grad))/norm(η)) -&gt; 
pars::Vector{&lt;:Real}</code></pre><p>Default gradient descent method in used in Quiqbox.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Optimization.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genOFmethod" href="#Quiqbox.genOFmethod"><code>Quiqbox.genOFmethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genOFmethod(POmethod::Val{:HF}, config::HFconfig=HFconfig()) -&gt; NTuple{2, Function}</code></pre><p>Generate the functions to calculate the value and gradient respectively of the desired  objective function. Default method is HF energy. To implement your own method for parameter  optimization, you can import <code>genOFmethod</code> and add new methods with different <code>POmethod</code>  which should have the same value with the field <code>method</code> in the corresponding <code>POconfig</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Optimization.jl#L117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlap" href="#Quiqbox.overlap"><code>Quiqbox.overlap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlap(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlaps" href="#Quiqbox.overlaps"><code>Quiqbox.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlaps(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the orbital overlap matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttraction" href="#Quiqbox.nucAttraction"><code>Quiqbox.nucAttraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttraction(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, 
              nuc::Array{String, 1}, nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions, and the nuclei with their coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nucAttractions" href="#Quiqbox.nucAttractions"><code>Quiqbox.nucAttractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nucAttractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, 
               nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return the nuclear attraction matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>, and the nuclei with their  coordinates (in atomic unit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetic" href="#Quiqbox.elecKinetic"><code>Quiqbox.elecKinetic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetic(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.elecKinetics" href="#Quiqbox.elecKinetics"><code>Quiqbox.elecKinetics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elecKinetics(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the electron kinetic energy matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreHij" href="#Quiqbox.coreHij"><code>Quiqbox.coreHij</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreHij(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, nuc::Array{String, 1}, 
        nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; 
Array{Float64, 2}</code></pre><p>Return a matrix element or block of the core Hamiltonian (an N×N <code>Matrix</code> where N is the  number of spatial orbitals) given 2 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L81-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreH" href="#Quiqbox.coreH"><code>Quiqbox.coreH</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coreH(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, 
      nucCoords::Array{&lt;:AbstractArray, 1}) -&gt; Array{Float64, 2}</code></pre><p>Return the core Hamiltonian matrix (an N×N <code>Matrix</code> where N is the number of spatial  orbitals) given a basis set in the form of an <code>Array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/OneBody.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteraction" href="#Quiqbox.eeInteraction"><code>Quiqbox.eeInteraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteraction(bf1::AbstractGTBasisFuncs, 
              bf2::AbstractGTBasisFuncs, 
              bf3::AbstractGTBasisFuncs, 
              bf4::AbstractGTBasisFuncs) -&gt; 
Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number of  spatial orbitals) given 4 basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/TwoBody.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractions" href="#Quiqbox.eeInteractions"><code>Quiqbox.eeInteractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eeInteractions(BSet::Array{&lt;:AbstractGTBasisFuncs, 1}) -&gt; Array{Float64, 4}</code></pre><p>Return the electron-electron interaction tensor (an N×N×N×N Tensor where N is the number  of spatial orbitals) given a basis set in the form of an <code>Array</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/4b9e0d983dcd08c1df86f93b111fb4cd56a15236/src/Integrals/TwoBody.jl#L20-L26">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">« Parameter Optimization</a><a class="docs-footer-nextpage" href="../coreType/">Core Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 6 April 2022 13:28">Wednesday 6 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
