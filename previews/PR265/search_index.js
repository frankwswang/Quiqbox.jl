var documenterSearchIndex = {"docs":
[{"location":"coreType/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Modules = [Quiqbox]\nPages   = [\"Parameters.jl\", \"OrbitalBases.jl\", \"FieldFunctions.jl\", \"HartreeFock.jl\", \n           \"Particles.jl\", \"Integration/Interface.jl\"]\nOrder   = [:type]","category":"page"},{"location":"coreType/#Quiqbox.ParamFreeFunc","page":"Core Types","title":"Quiqbox.ParamFreeFunc","text":"ParamFreeFunc{F<:Function} <: CompositeFunction\n\nA direct wrapper struct for f::F that does not have reachable Quiqbox.ParamBox through  reflection functions.\n\nâ‰¡â‰¡â‰¡ Property/Properties â‰¡â‰¡â‰¡\n\nf::F: Stored function. noStoredParam(f) must return true when it is used to  construct a instance of ParamFreeFunc{F}.\n\nâ‰¡â‰¡â‰¡ Initialization Method(s) â‰¡â‰¡â‰¡\n\nParamFreeFunc(f::F) where {F<:Function} -> ParamFreeFunc{T}\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.HFconfig","page":"Core Types","title":"Quiqbox.HFconfig","text":"HFconfig{R<:Real, T<:Union{Complex{R}, R}, HFT<:Union{RCHartreeFock, UOHartreeFock}, \n         CM<:Quiqbox.OrbCoeffInitialConfig{T, HFT}, SCFM<:SCFconfig, S} <: Quiqbox.ConfigBox\n\nThe container of a Hartreeâ€“Fock method's configuration.\n\nâ‰¡â‰¡â‰¡ Property/Properties â‰¡â‰¡â‰¡\n\ntype::HFT: Hartreeâ€“Fock method type. Available types are (RCHartreeFock, UOHartreeFock)  (\"Restricted closed-shell (RHF)\", \"Unrestricted open-shell (UHF)\").\n\ninitial::CM: Initial guess of the orbital coefficient matrix/matrices of the canonical  orbitals. When initial is as an argument of HFconfig's constructor, it can be set  to sym::Symbol where available values of sym are  (:Direct, :CoreH, :GWH, :SAD).\n\nstrategy::SCFM: SCF iteration strategy. For more information please refer to  SCFconfig.\n\nmaxStep::Int: Maximum iteration steps allowed regardless if the iteration converges.\n\nearlyStop::Bool: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.\n\nsaveTrace::NTuple{4, Bool}: Determine whether saving (by pushing) the intermediate  information from all the iterations steps to the field .temp of the output  HFfinalInfo of runHartreeFock. The types of relevant information are:\n\nSequence Information Corresponding field in HFtempInfo (subject to CHANGES)\n1 orbital coefficient matrix/matrices .Cs\n2 density matrix/matrices .Ds, .shared.Dtots\n3 Fock matrix/matrices .Fs\n4 unconverged Hartreeâ€“Fock energy(s) .Es, .shared.Etots\n\nâ‰¡â‰¡â‰¡ Initialization Method(s) â‰¡â‰¡â‰¡\n\nHFconfig(::Type{T}, type::HFT=RCHartreeFock(); \n         initial::Union{Quiqbox.OrbCoeffInitialConfig{T}, Symbol}=:SAD, \n         strategy::SCFconfig=SCFconfig(), \n         maxStep::Int=200, earlyStop::Bool=true, \n         saveTrace::NTuple{4, Bool}=(false, false, false, true)) where \n        {R<:Real, T<:Union{Complex{R}, R}, HFT<:Union{RCHartreeFock, UOHartreeFock}} -> \nHFconfig{R, T, HFT}\n\nâ‰¡â‰¡â‰¡ Initialization Example(s) â‰¡â‰¡â‰¡\n\njulia> HFconfig(Float64, UOHartreeFock());\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.HFfinalInfo","page":"Core Types","title":"Quiqbox.HFfinalInfo","text":"HFfinalInfo{R<:Real, D, T<:Union{Complex{R}, R}, HFT<:Union{RCHartreeFock, UOHartreeFock}, \n            HFTS, B<:Quiqbox.MultiOrbitalData{R, D, T}} <: StateBox{T}\n\nThe container of the final values after a Hartreeâ€“Fock SCF procedure. HFTS specifies the  number of distinct data sectors corresponding to the specified spin configurations. For  restricted closed-shell Hartreeâ€“Fock (RHF), HFTS is 1.\n\nâ‰¡â‰¡â‰¡ Property/Properties â‰¡â‰¡â‰¡\n\nsystem::@NamedTuple{spin::OccupationState{2}, geometry::NuclearCluster{R, D}}: The  specification of the target system. Its property .spin::OccupationState  specifies numbers of electrons in two orthonormal spin configurations (e.g., spin-up vs.  spin-down); .geometry::NuclearCluster specifies the nuclear geometry.\n\nenergy::NTuple{2, R}: The electronic and nuclear (repulsion potential) parts of the  target system's ground-state energy under the Hartreeâ€“Fock and the Bornâ€“Oppenheimer  approximation.\n\ncoeff::NTuple{HFTS, MatrixMemory{T}}: Distinct orbital coefficient matrix/matrices.\n\ndensity::NTuple{HFTS, MatrixMemory{T}}: Distinct one-electron density matrix/matrices.\n\nfock::NTuple{HFTS, MatrixMemory{T}}: Distinct Fock matrix/matrices.\n\noccu::NTuple{HFTS, Quiqbox.MemoryPair{ R, NTuple{2, Bool} }}: The spin occupations of distinct  canonical (spatial) orbitals and their corresponding orbital energies.\n\nmemory::NTuple{HFTS, Quiqbox.HFtempInfo{R, T, HFT}}: the intermediate data stored during the  Hartreeâ€“Fock SCF (self-consistent field) interactions. (NOTE: The interface of  Quiqbox.HFtempInfo is internal and subject to BREAKING CHANGES.)\n\nconverged::Union{Bool, Missing}: Whether the SCF iteration is converged in the end.  When convergence detection is off (see SCFconfig), it is set to missing.\n\nbasis::B: The orbital basis-set data used for the Hartreeâ€“Fock SCF computation.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.SCFconfig","page":"Core Types","title":"Quiqbox.SCFconfig","text":"SCFconfig{T<:Real, L, MS<:NTuple{L, Val}} <: Quiqbox.ConfigBox\n\nThe conatiner to configure the self-consistent field (SCF) iteration strategy for  Hartreeâ€“Fock computation.\n\nâ‰¡â‰¡â‰¡ Property/Properties â‰¡â‰¡â‰¡\n\nmethod::MS: The applied convergence methods. The parameters S::Symbol in each Val{S}  specifies a SCF ietration method. The available methods their corresponding supported  keyword arguments are:\n\nConvergence Method(s) Configuration(s) Keyword(s) Range(s)/Option(s) Default(s)\n:DD damping strength dampStrength [0, 1] 0.75\n:DIIS, :EDIIS, :ADIIS subspace size; DIIS-Method solver; reset thresholdÂ¹ DIISsize; solver; resetThreshold 1,2...; :LBFGS...; 1e-14... 15; :LBFGS; N/A\n\nÂ¹ The reset threshold (resetThreshold::Real) determines when to clear the memory of the  DIIS-based method's subspace and reset the second-to-latest residual vector as the first  reference. The reset is executed when the latest computed energy increases an amount above  the threshold compared to the second-to-latest computed energy. In default, the threshold  is slightly larger than the machine epsilon of the numerical data type applied to the SCF  computation.\n\nConvergence Methods\n\n:DD: Direct diagonalization of the Fock matrix.\n:DIIS: Direct inversion in the iterative subspace.\n:EDIIS: Energy-DIIS.\n:ADIIS: DIIS based on the augmented Roothaanâ€“Hall (ARH) energy function.\n\nDIIS-Method Solvers\n\n:LBFGS: Limited-memory BFGS with box constraints.\n:LCM: Lagrange multiplier solver.\n:SPGB: Spectral Projected Gradient Method with box constraints.\n\ninterval::NTuple{L, T}: The stopping (or skipping) thresholds for required methods. The  last threshold will be the convergence threshold for the SCF procedure. When the last  threshold is set to NaN, there will be no convergence detection.\n\nmethodConfig::NTuple{L, Memory{ <:Pair{Symbol} }}: The additional keywords arguments for  each method stored as Tuples of Pairs.\n\nsecondaryConvRatio::NTuple{2, T}: The ratios of the secondary convergence criteria to the  primary convergence indicator, i.e., the change of the energy (Î”E):\n\nOrder Symbols Meaning Default\n1 RMS(FDS-SDF) root mean square of the error matrix defined in DIIS 1000\n2 RMS(Î”D) root mean square of the change of the density matrix 1000\n\noscillateThreshold::T: The threshold for oscillatory convergence.\n\nâ‰¡â‰¡â‰¡ Initialization Method(s) â‰¡â‰¡â‰¡\n\nSCFconfig(methods::NTuple{L, Symbol}, intervals::NTuple{L, T}, \n          config::AbstractDict{Int64, <:AbstractVector{<:Pair{Symbol}}}=Quiqbox.EmptyDict{Int, Vector{ Pair{Symbol} }}(); \n          secondaryConvRatio::Union{Real, NTuple{2, Real}}=\n          T.((1000, 1000)), oscillateThreshold::Real=\n          T(5.0e-6)) where {L, T<:AbstractFloat} -> \nSCFconfig{T, L}\n\nmethods and intervals are the convergence methods to be applied and their stopping  (or skipping) thresholds respectively. config specifies additional keyword argument(s)  for each methods by a Pair{Symbol} of which the key i::Int is for ith method and the  pointed AbstractVector{<:Pair} is the pairs of keyword arguments and their values  respectively. If secondaryConvRatio is AbstractFloat, it will be assigned as the value  for all the secondary convergence ratios.\n\nSCFconfig(;threshold::AbstractFloat=1.0e-9, \n          secondaryConvRatio::Union{Real, NTuple{2, Real}}=(1000, 1000), \n          oscillateThreshold::Real=5.0e-6) -> \nSCFconfig{Float64, 3}\n\nthreshold will replace the stopping threshold of the default SCF configuration with a new  value.\n\nâ‰¡â‰¡â‰¡ Initialization Example(s) â‰¡â‰¡â‰¡\n\njulia> SCFconfig((:DD, :ADIIS, :DIIS), (1e-4, 1e-12, 1e-13), Dict(2=>[:solver=>:LCM]));\n\njulia> SCFconfig(threshold=1e-8, oscillateThreshold=1e-5)\nSCFconfig{Float64, 3, Tuple{Val{:DD}, Val{:ADIIS}, Val{:DIIS}}}((Val{:DD}(), Val{:ADIIS}(), Val{:DIIS}()), (0.005, 0.0001, 1.0e-8), (Pair{Symbol}[], Pair{Symbol}[], Pair{Symbol}[]), (1000.0, 1000.0), 1.0e-5)\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.NuclearCluster","page":"Core Types","title":"Quiqbox.NuclearCluster","text":"NuclearCluster{T, D} <: Quiqbox.QueryBox{Pair{ Symbol, NTuple{D, T} }}\n\nA container for storing information about a cluster of nuclei, including their symbols and respective Cartesian coordinates (of dimension D).\n\nâ‰¡â‰¡â‰¡ Initialization Method(s) â‰¡â‰¡â‰¡\n\nNuclearCluster(nucSyms::AbstractVector{Symbol}, nucCoords::Union{AbstractVector{<:AbstractVector{T}}, AbstractArray{Tuple{T, Vararg{T, D}}, 1} where D} where T<:Real;\n               pairwiseSort::Bool=true) -> NuclearCluster\n\nnucSyms specifies the symbols of the nuclei, while nucCoords provides their Cartesian  coordinates. pairwiseSort determines whether to sort the nuclei based on their atomic  numbers and coordinates.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Quiqbox.OccupationState","page":"Core Types","title":"Quiqbox.OccupationState","text":"OccupationState{N} <: Quiqbox.StateBox{UInt}\n\nA container for storing the occupation numbers (non-negative integers) of multiple modes.\n\nâ‰¡â‰¡â‰¡ Initialization Method(s) â‰¡â‰¡â‰¡\n\nOccupationState(layout::Union{AbstractVector{T}, Tuple{T, Vararg{T, NMO}} where NMO}) where {T<:Integer} -> \nOccupationState\n\n\n\n\n\n","category":"type"},{"location":"SCF/#Self-Consistent-Field-Methods","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"","category":"section"},{"location":"SCF/#Hartreeâ€“Fock-methods","page":"Self-Consistent Field Methods","title":"Hartreeâ€“Fock methods","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox supports basic Hartreeâ€“Fock methods with various configurations: ","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Items Options\nHF Types restricted closed-shell (RHF), unrestricted open-shell (UHF)\nInitial Guesses core Hamiltonian, generalized Wolfsberg-Helmholtz, superposition of atomic densities (SAD), pre-defined coefficient matrix\nConverging Methods direct diagonalization, direct inversion in the iterative subspace (DIIS), E-DIIS, A-DIIS, combinations of multiple methods\nDIIS-type Method Solvers Lagrange multiplier solver, L-BFGS solver","category":"page"},{"location":"SCF/#Basic-Hartreeâ€“Fock","page":"Self-Consistent Field Methods","title":"Basic Hartreeâ€“Fock","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"To run a Hartreeâ€“Fock method, the lines of code required in Quiqbox are as simple as below:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"    push!(LOAD_PATH,\"../../src/\")\n    using Quiqbox","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nuc = [:H, :H];\n\nnucCoords = [(-0.7, 0.0, 0.0), (0.7, 0.0, 0.0)];\n\nbs = reduce(vcat, genGaussTypeOrbSeq.(nucCoords, nuc, \"STO-3G\"));\n\nresRHF = runHartreeFock(NuclearCluster(nuc, nucCoords), bs);\n\n@show resRHF.energy resRHF.coeff resRHF.occu;","category":"page"},{"location":"SCF/#Flexible-core-functions","page":"Self-Consistent Field Methods","title":"Flexible core functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"If the user wants to fine-tune the SCF iteration to achieve better performance, Quiqbox has provided various core types and functions that allow the user to customize the HF methods:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"HFconfig","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"SCFconfig","category":"page"},{"location":"SCF/#Stand-alone-integral-functions","page":"Self-Consistent Field Methods","title":"Stand-alone integral functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox also provides efficient native functions for one-electron and two-electron integral calculations.","category":"page"},{"location":"SCF/#One-electron-functions","page":"Self-Consistent Field Methods","title":"One-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlap","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlaps","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetic","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetics","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttractions","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"coreHamiltonian","category":"page"},{"location":"SCF/#Two-electron-functions","page":"Self-Consistent Field Methods","title":"Two-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecRepulsion","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecRepulsions","category":"page"},{"location":"coreFunction/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nPages   = [\"Parameters.jl\", \"OrbitalBases.jl\", \"HartreeFock.jl\", \"Particles.jl\", \n           \"Integration/Interface.jl\"]\nOrder   = [:function]","category":"page"},{"location":"coreFunction/#Quiqbox.noStoredParam-Tuple{T} where T","page":"Core Functions","title":"Quiqbox.noStoredParam","text":"noStoredParam(source) -> Bool\n\nDetect if source has no reachable Quiqbox.ParamBox by reflection-type functions, getfieldand  getindex. It returns true if uniqueParams(source) returns an empty collection. It  is still possible for noStoredParam to return true if source is a generic  function that indirectly references global variables being/storing Quiqbox.ParamBox.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.sever","page":"Core Functions","title":"Quiqbox.sever","text":"sever(param::Quiqbox.ParamBox, screenSource::Bool=false) -> ParamBox\n\nReturns a copy of param with severable connection(s) eliminated. For param::SpanParam,  sever returns a PrimitiveParam of which the output value is the same as param when  called by obtain; for any param being nested ParamBox, it recursively severs every  ParamBox inside param that is a SpanParam. screenSource determines whether the  returned (or ints inside) ParamBox will be screened.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/#Quiqbox.genGaussTypeOrb-Union{Tuple{D}, Tuple{C}, Tuple{T}, Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s92\", var\"#s92\"}, var\"#s92\"} where var\"#s92\"<:Real, Vararg{Union{Quiqbox.ParamBox{var\"#s92\", var\"#s92\"}, var\"#s92\"} where var\"#s92\"<:Real, D}}, AbstractVector{<:Union{Quiqbox.ParamBox{T, T}, T}}, Union{AbstractVector{<:Union{Quiqbox.ParamBox{C, C}, C}}, Quiqbox.ParamBox{C, Quiqbox.PackedMemory{C, C, 1}}}}, Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, Vararg{Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, D}}, AbstractVector{<:Union{Quiqbox.ParamBox{T, T}, T}}, Union{AbstractVector{<:Union{Quiqbox.ParamBox{C, C}, C}}, Quiqbox.ParamBox{C, Quiqbox.PackedMemory{C, C, 1}}}, Tuple{Int64, Vararg{Int64, D}}}} where {T<:Real, C<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.genGaussTypeOrb","text":"genGaussTypeOrb(center::NTuple{D, T}, xpns::AbstractVector{T}, cons::AbstractVector{C}, \n                ijk::NonEmptyTuple{Int, D}=ntuple(_->0, Val(D)); \n                innerRenormalize::Bool=false, outerRenormalize::Bool=false) where \n               {T<:Real, C<:Union{Complex{T}, T}, D} -> \nCompositeOrb{T, D, C}\n\nGenerate a D-dimensional contracted Gaussian-type orbital (GTO) with Cartesian angular  momentum specified by ijk, as a linear combination of con-centric primitive GTOs located  at center, with exponent coefficients specified by xpns and contraction coefficients  specified by cons. innerRenormalize and outerRenormalize determine whether the  primitive GTOs and the contracted GTO should be renormalized, respectively.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genGaussTypeOrb-Union{Tuple{D}, Tuple{T}, Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s92\", var\"#s92\"}, var\"#s92\"} where var\"#s92\"<:Real, Vararg{Union{Quiqbox.ParamBox{var\"#s92\", var\"#s92\"}, var\"#s92\"} where var\"#s92\"<:Real, D}}, Union{Quiqbox.ParamBox{T, T}, T}}, Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, Vararg{Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, D}}, Union{Quiqbox.ParamBox{T, T}, T}, Tuple{Int64, Vararg{Int64, D}}}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.genGaussTypeOrb","text":"genGaussTypeOrb(center::NTuple{D, T}, xpn::T, ijk::NTuple{D, Int}=ntuple(_->0, Val(D)); \n                renormalize::Bool=false) where {T<:Real, D} -> \nPrimitiveOrb{T, D, T}\n\nGenerate a D-dimensional primitive Gaussian-type orbital (GTO) located at center with  exponent coefficients specified by xpn and Cartesian angular momentum specified by ijk.  renormalize determines whether the generated orbital should be renormalized.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genGaussTypeOrbSeq-Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real, Union{Quiqbox.ParamBox{var\"#s91\", var\"#s91\"}, var\"#s91\"} where var\"#s91\"<:Real}, AbstractString}","page":"Core Functions","title":"Quiqbox.genGaussTypeOrbSeq","text":"genGaussTypeOrbSeq(center::NTuple{3, T}, content::AbstractString; \n                   innerRenormalize::Bool=false, outerRenormalize::Bool=false, \n                   unlinkCenter::Bool=false) where {T<:Real} -> \nVector{<:CompositeOrb{T, 3, T}}\n\nGenerate a sequence of Gaussian-type orbitals (GTOs) located at center based on the basis set information provided in content, which should the text of an atomic Gaussian  basis set in the Gaussian (software) format. innerRenormalize and outerRenormalize  determine whether the primitive GTOs and the contracted GTOs should be renormalized,  respectively. unlinkCenter determines whether the center parameters of the generated GTOs  should be unlinked from each other.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.genGaussTypeOrbSeq-Tuple{Tuple{Union{Quiqbox.ParamBox{var\"#s95\", var\"#s95\"}, var\"#s95\"} where var\"#s95\"<:Real, Union{Quiqbox.ParamBox{var\"#s95\", var\"#s95\"}, var\"#s95\"} where var\"#s95\"<:Real, Union{Quiqbox.ParamBox{var\"#s95\", var\"#s95\"}, var\"#s95\"} where var\"#s95\"<:Real}, Symbol, String}","page":"Core Functions","title":"Quiqbox.genGaussTypeOrbSeq","text":"genGaussTypeOrbSeq(center::NTuple{3, UnitOrVal{T}}, atm::Symbol, basisKey::String; \n                   innerRenormalize::Bool=false, outerRenormalize::Bool=false, \n                   unlinkCenter::Bool=false) where {T<:Real} -> \nVector{<:CompositeOrb{T, 3, T}}\n\nGenerate a sequence of Gaussian-type orbitals (GTOs) located at center based on the input  atomic basis set specified by the atomic symbol atm and the basis-set name basisKey. \n\nAtomic symbol options: [:H, :He, :Li, :Be, :B, :C, :N, :O, :F, :Ne, :Na, :Mg, :Al, :Si, :P, :S, :Cl, :Ar, :K, :Ca].\nBasis-set name options: [\"STO-2G\", \"STO-3G\", \"STO-6G\", \"3-21G\", \"6-31G\", \"cc-pVDZ\", \"cc-pVTZ\", \"cc-pVQZ\"].\n\ninnerRenormalize and outerRenormalize determine whether the primitive GTOs and the  contracted GTOs should be renormalized, respectively. unlinkCenter determines whether the  center parameters of the generated GTOs should be unlinked from each other.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.runHartreeFock-Union{Tuple{D}, Tuple{R}, Tuple{NuclearCluster{R, D}, Union{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{R}, R}, D}}, Quiqbox.MultiOrbitalData{R, D, C, F, P} where {C<:Union{Complex{R}, R}, F<:(Quiqbox.StashedField{R, D, C, F} where {C<:Union{Complex{R}, R}, F<:(Quiqbox.ParamPipeFunc{F, R1} where {F<:Quiqbox.AbstractParamFunc, R1<:(Quiqbox.ParamCombiner{Quiqbox.TypedBinary{NTuple{D, R}, Base.Broadcast.BroadcastFunction{typeof(-)}, NTuple{D, R}, NTuple{D, R}}, Tuple{Quiqbox.InputConverter{Quiqbox.CartesianHeader{D, TypedReturn{NTuple{D, R}, typeof(itself)}}}, Quiqbox.ParamFormatter{M}}} where M<:(Quiqbox.ChainMapper{<:NTuple{D, Function}}))})}), P<:Union{GenericMemory{:not_atomic, Quiqbox.OrbCorePointer{D, C}, Core.AddrSpace{Core}(0x00)}, Tuple{Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}, Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}, Tuple{Quiqbox.OrbCorePointer{D, C}, Quiqbox.OrbCorePointer{D, C}}, NTuple{4, Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}, NTuple{4, Quiqbox.OrbCorePointer{D, C}}, Memory{<:Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}}}}}, Tuple{NuclearCluster{R, D}, Union{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{R}, R}, D}}, Quiqbox.MultiOrbitalData{R, D, C, F, P} where {C<:Union{Complex{R}, R}, F<:(Quiqbox.StashedField{R, D, C, F} where {C<:Union{Complex{R}, R}, F<:(Quiqbox.ParamPipeFunc{F, R1} where {F<:Quiqbox.AbstractParamFunc, R1<:(Quiqbox.ParamCombiner{Quiqbox.TypedBinary{NTuple{D, R}, Base.Broadcast.BroadcastFunction{typeof(-)}, NTuple{D, R}, NTuple{D, R}}, Tuple{Quiqbox.InputConverter{Quiqbox.CartesianHeader{D, TypedReturn{NTuple{D, R}, typeof(itself)}}}, Quiqbox.ParamFormatter{M}}} where M<:(Quiqbox.ChainMapper{<:NTuple{D, Function}}))})}), P<:Union{GenericMemory{:not_atomic, Quiqbox.OrbCorePointer{D, C}, Core.AddrSpace{Core}(0x00)}, Tuple{Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}, Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}, Tuple{Quiqbox.OrbCorePointer{D, C}, Quiqbox.OrbCorePointer{D, C}}, NTuple{4, Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}, NTuple{4, Quiqbox.OrbCorePointer{D, C}}, Memory{<:Union{Quiqbox.CompOrbPointer{D, C}, Quiqbox.PrimOrbPointer{D, C}}}}}}, Union{Missing, HFconfig{R, T, HFT, CM} where {T<:Union{Complex{R}, R}, HFT<:Union{RCHartreeFock, UOHartreeFock}, CM<:(Quiqbox.OrbCoeffInitialConfig{T, HFT, M, P} where {M, P<:Union{Tuple{AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}}})}}}} where {R<:Real, D}","page":"Core Functions","title":"Quiqbox.runHartreeFock","text":"runHartreeFock(nucInfo::NuclearCluster{R, D}, basis::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{R}, R}, D}}, \n               config::MissingOr{HFconfig{R}}=missing; \n               printInfo::Bool=true, infoLevel::Int=2) where \n              {R<:Real, D} -> \nHFfinalInfo{R, D}\n\nrunHartreeFock(systemInfo::Pair{<:Union{Tuple{Int64, Int64}, OccupationState{2}}, NuclearCluster{R, D}}, \n               basis::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{R}, R}, D}}, \n               config::MissingOr{HFconfig{R}}=missing; \n               printInfo::Bool=true, infoLevel::Int=2) where \n              {R<:Real, D} -> \nHFfinalInfo{R, D}\n\nMain function to run a Hartreeâ€“Fock method in Quiqbox. The returned result and relevant  information is stored in a Quiqbox.HFfinalInfo.\n\nâ‰¡â‰¡â‰¡ Positional argument(s) â‰¡â‰¡â‰¡\n\nnucInfo::NuclearCluster{R, D}: the nuclear geometry of the system. When nucInfo is the  first argument the spin configuration is automatically set such that the target system is  charge neutral and maximizing pairing electron spins.\n\nsystemInfoPair{<:Union{Tuple{Int64, Int64}, OccupationState{2}}, NuclearCluster{R, D}}: A Pair information used  to specify both the spin and nuclear-geometry configuration of the target system.\n\nbasis::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{R}, R}, D}}: The input orbital basis set.\n\nconfig::HFconfig: The Configuration of the Hartreeâ€“Fock method. For more information  please refer to HFconfig.\n\nâ‰¡â‰¡â‰¡ Keyword argument(s) â‰¡â‰¡â‰¡\n\nprintInfo::Bool: Whether print out the information of iteration steps and result.\n\ninfoLevel::Int: Printed info's level of details when printInfo=true. The higher  (the absolute value of) infoLevel is, more intermediate steps will be printed. Once  infoLevel reaches 5, every step will be printed.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.getCharge-Tuple{Symbol}","page":"Core Functions","title":"Quiqbox.getCharge","text":"getCharge(nuc::Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}) -> Int\n\nReturn the total electric charge (in ð‘’) of the input nucleus/nuclei.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeOrbitalBasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Core Functions","title":"Quiqbox.changeOrbitalBasis","text":"changeOrbitalBasis(twoBodyInt::AbstractArray{T, 4}, \n                   C1::AbstractMatrix{T}, C2::AbstractMatrix{T}) where {T} -> \nAbstractArray{T, 4}\n\nChange the orbital basis of the input two-body integrals twoBodyInt based on two orbital  coefficient matrices C1 and C2 for different spin configurations (e.g., the  unrestricted case). The output is a 3-element Tuple of which the first 2 elements are the  spatial integrals of each spin configurations respectively, while the last element is the  Coulomb interactions between orbitals with different spins.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.changeOrbitalBasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Core Functions","title":"Quiqbox.changeOrbitalBasis","text":"changeOrbitalBasis(DbodyInt::AbstractArray{T, D}, C::AbstractMatrix{T}) where {T} -> \nAbstractArray{T, D}\n\nChange the orbital basis of the input one-body / two-body integrals DbodyInt based on the  orbital coefficient matrix.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.coreHamiltonian-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector{Symbol}, AbstractArray{NTuple{D, T}, 1}, AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}, Tuple{AbstractVector{Symbol}, AbstractArray{NTuple{D, T}, 1}, AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}, Quiqbox.KineticEnergySampler{T, D}}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.coreHamiltonian","text":"coreHamiltonian(nucs::AbstractVector{Symbol}, nucCoords::AbstractVector{NTuple{D, T}}, \n                basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n                lazyCompute::Bool=true\n                ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\ncoreHamiltonian(nucInfo::NuclearCluster{T, D}, \n                basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n                lazyCompute::Bool=true\n                ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nCompute the core-Hamiltonian integrals for all pairs of orbital basis functions in  basisSet, which is the matrix addition of the electronic kinetic-energy integrals and the  nuclear-electron attraction integrals. If lazyCompute is set to true, the integrals  will be computed in a lazy manner to avoid repetitive primitive integration.\n\nâ‰¡â‰¡â‰¡ Positional argument(s) â‰¡â‰¡â‰¡\n\nnucs::AbstractVector{Symbol}: A list of nuclear species.\n\nnucCoords::AbstractVector{NTuple{D, T}}: The list of Cartesian nuclear coordinates in  the order respective to nucs.\n\nnucInfo::NuclearCluster{T, D}: A container storing the nuclear species and their  respective coordinates.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.elecKinetic-Union{Tuple{D}, Tuple{CR}, Tuple{CL}, Tuple{T}, Tuple{Quiqbox.OrbitalBasis{CL, D}, Quiqbox.OrbitalBasis{CR, D}}, Tuple{Quiqbox.OrbitalBasis{CL, D}, Quiqbox.OrbitalBasis{CR, D}, Quiqbox.KineticEnergySampler{T, D}}} where {T<:Real, CL<:Union{Complex{T}, T}, CR<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.elecKinetic","text":"elecKinetic(orbL::Quiqbox.OrbitalBasis{CL, D}, orbR::Quiqbox.OrbitalBasis{CR, D}; \n            lazyCompute::Bool=true\n            ) where {T<:Real, CL<:Union{Complex{T}, T}, \n                              CR<:Union{Complex{T}, T}, D} -> \nUnion{Complex{T}, T}\n\nCompute the electronic kinetic-energy integral between two orbital basis functions orbL  and orbR. If lazyCompute is set to true, the integral will be computed in a lazy  manner to avoid repetitive primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.elecKinetics-Union{Tuple{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}, Quiqbox.KineticEnergySampler{T, D}}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.elecKinetics","text":"elecKinetics(basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n             lazyCompute::Bool=true\n             ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nCompute the electronic kinetic-energy integrals for all pairs of orbital basis functions in  basisSet. If lazyCompute is set to true, the integrals will be computed in a lazy  manner to avoid repetitive primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.elecRepulsion-Union{Tuple{D}, Tuple{CR2}, Tuple{CL2}, Tuple{CR1}, Tuple{CL1}, Tuple{T}, Tuple{Quiqbox.OrbitalBasis{CL1, D}, Quiqbox.OrbitalBasis{CR1, D}, Quiqbox.OrbitalBasis{CL2, D}, Quiqbox.OrbitalBasis{CR2, D}}} where {T<:Real, CL1<:Union{Complex{T}, T}, CR1<:Union{Complex{T}, T}, CL2<:Union{Complex{T}, T}, CR2<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.elecRepulsion","text":"elecRepulsion(orbL1::Quiqbox.OrbitalBasis{CL1, D}, orbR1::Quiqbox.OrbitalBasis{CR1, D}, \n              orbL2::Quiqbox.OrbitalBasis{CL2, D}, orbR2::Quiqbox.OrbitalBasis{CR2, D}; \n              lazyCompute::Bool=true\n              ) where {T<:Real, CL1<:Union{Complex{T}, T}, \n                                CR1<:Union{Complex{T}, T}, \n                                CL2<:Union{Complex{T}, T}, \n                                CR2<:Union{Complex{T}, T}, D} -> \nUnion{Complex{T}, T}\n\nCompute the electron-repulsion integral between two pairs of orbital basis functions (orbL1, orbR1) and (orbL2, orbR2) (ordered by the chemists' notation). If lazyCompute  is set to true, the integral will be computed in a lazy manner to avoid repetitive  primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.elecRepulsions-Union{Tuple{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}, Tuple{D}, Tuple{T}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.elecRepulsions","text":"elecRepulsions(basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n               lazyCompute::Bool=true\n               ) where {T<:Real, D} -> \nAbstractArray{<:Union{Complex{T}, T}, 4}\n\nCompute the electron-repulsion integrals for all double pairs of orbital basis functions  in basisSet (tensor indices are ordered by the chemists' notation). If lazyCompute is  set to true, the integrals will be computed in a lazy manner to avoid repetitive  primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.multipoleMoment-Union{Tuple{D}, Tuple{CR}, Tuple{CL}, Tuple{T}, Tuple{NTuple{D, Real}, NTuple{D, Int64}, Quiqbox.OrbitalBasis{CL, D}, Quiqbox.OrbitalBasis{CR, D}}} where {T<:Real, CL<:Union{Complex{T}, T}, CR<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.multipoleMoment","text":"multipoleMoment(center::NTuple{D, Real}, degrees::NTuple{D, Int}, \n                orbL::Quiqbox.OrbitalBasis{CL, D}, orbR::Quiqbox.OrbitalBasis{CR, D}; \n                lazyCompute::Bool=true\n                ) where {T<:Real, CL<:Union{Complex{T}, T}, \n                                  CR<:Union{Complex{T}, T}, D} -> \nUnion{Complex{T}, T}\n\nCompute the multipole-moment integral between two orbital basis functions orbL and orbR  at the D-dimensional center with degrees specified for its axes. If lazyCompute is  set to true, the integral will be computed in a lazy manner to avoid repetitive primitive  integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.multipoleMoments-Union{Tuple{D}, Tuple{T}, Tuple{NTuple{D, Real}, NTuple{D, Int64}, AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.multipoleMoments","text":"multipoleMoments(center::NTuple{D, Real}, degrees::NTuple{D, Int}, \n                 basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n                 lazyCompute::Bool=true\n                 ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nCompute the multipole-moment integrals for all pairs of orbital basis functions in  basisSet at the D-dimensional center with degrees specified for its axes. If  lazyCompute is set to true, the integrals will be computed in a lazy manner to avoid  repetitive primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.nucAttraction-Union{Tuple{D}, Tuple{CR}, Tuple{CL}, Tuple{T}, Tuple{AbstractVector{Symbol}, AbstractArray{NTuple{D, T}, 1}, Quiqbox.OrbitalBasis{CL, D}, Quiqbox.OrbitalBasis{CR, D}}} where {T<:Real, CL<:Union{Complex{T}, T}, CR<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.nucAttraction","text":"nucAttraction(nucs::AbstractVector{Symbol}, nucCoords::AbstractVector{NTuple{D, T}}, \n              orbL::Quiqbox.OrbitalBasis{CL, D}, orbR::Quiqbox.OrbitalBasis{CR, D}; \n              lazyCompute::Bool=true\n              ) where {T<:Real, CL<:Union{Complex{T}, T}, \n                                CR<:Union{Complex{T}, T}, D} ->\nUnion{Complex{T}, T}\n\nnucAttraction(nucInfo::NuclearCluster{T, D}, \n              orbL::Quiqbox.OrbitalBasis{CL, D}, orbR::Quiqbox.OrbitalBasis{CR, D}; \n              lazyCompute::Bool=true\n              ) where {T<:Real, CL<:Union{Complex{T}, T}, \n                                CR<:Union{Complex{T}, T}, D} ->\nUnion{Complex{T}, T}\n\nCompute the nuclear-attraction integral between two orbital basis functions orbL and  orbR. If lazyCompute is set to true, the integral will be computed in a lazy manner  to avoid repetitive primitive integration.\n\nâ‰¡â‰¡â‰¡ Positional argument(s) â‰¡â‰¡â‰¡\n\nnucs::AbstractVector{Symbol}: A list of nuclear species.\n\nnucCoords::AbstractVector{NTuple{D, T}}: The list of Cartesian nuclear coordinates in  the order respective to nucs.\n\nnucInfo::NuclearCluster{T, D}: A container storing the nuclear species and their  respective coordinates.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.nucAttractions-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector{Symbol}, AbstractArray{NTuple{D, T}, 1}, AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.nucAttractions","text":"nucAttractions(nucs::AbstractVector{Symbol}, nucCoords::AbstractVector{NTuple{D, T}}, \n               basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n               lazyCompute::Bool=true\n               ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nnucAttractions(nucInfo::NuclearCluster{T, D}, \n               basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n               lazyCompute::Bool=true\n               ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nCompute the nuclear-attraction integrals for all pairs of orbital basis functions in  basisSet. If lazyCompute is set to true, the integrals will be computed in a lazy  manner to avoid repetitive primitive integration.\n\nâ‰¡â‰¡â‰¡ Positional argument(s) â‰¡â‰¡â‰¡\n\nnucs::AbstractVector{Symbol}: A list of nuclear species.\n\nnucCoords::AbstractVector{NTuple{D, T}}: The list of Cartesian nuclear coordinates in  the order respective to nucs.\n\nnucInfo::NuclearCluster{T, D}: A container storing the nuclear species and their  respective coordinates.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.overlap-Union{Tuple{D}, Tuple{CR}, Tuple{CL}, Tuple{T}, Tuple{Quiqbox.OrbitalBasis{CL, D}, Quiqbox.OrbitalBasis{CR, D}}} where {T<:Real, CL<:Union{Complex{T}, T}, CR<:Union{Complex{T}, T}, D}","page":"Core Functions","title":"Quiqbox.overlap","text":"overlap(orbL::Quiqbox.OrbitalBasis{CL, D}, orbR::Quiqbox.OrbitalBasis{CR, D}; \n        lazyCompute::Bool=true\n        ) where {T<:Real, CL<:Union{Complex{T}, T}, \n                          CR<:Union{Complex{T}, T}, D} -> \nUnion{Complex{T}, T}\n\nCompute the overlap integral between two orbital basis functions orbL and orbR. If  lazyCompute is set to true, the integral will be computed in a lazy manner to avoid  repetitive primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.overlaps-Union{Tuple{AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}}, Tuple{D}, Tuple{T}} where {T<:Real, D}","page":"Core Functions","title":"Quiqbox.overlaps","text":"overlaps(basisSet::AbstractVector{<:Quiqbox.OrbitalBasis{<:Union{Complex{T}, T}, D}}; \n         lazyCompute::Bool=true\n         ) where {T<:Real, D} -> \nAbstractMatrix{<:Union{Complex{T}, T}}\n\nCompute the overlap integrals for all pairs of orbital basis functions in basisSet. If  lazyCompute is set to true, the integrals will be computed in a lazy manner to avoid  repetitive primitive integration.\n\n\n\n\n\n","category":"method"},{"location":"list/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"Below are the links to all the docstrings (e.g., types, functions) included in the documentation.","category":"page"},{"location":"list/","page":"Index","title":"Index","text":"order = [:type]","category":"page"},{"location":"#Quiqbox.jl","page":"Home","title":"Quiqbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quiqbox is a quantum chemistry and quantum physics software package that starts around Gaussian basis set optimization for electronic structure problems. Quiqbox is written in pure Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support constructing floating and fixed-position contracted orbitals.\nSupport constructing mixed-contracted Gaussian-type orbitals and building hybrid basis sets.\nProvide native one-electron and two-electron integral functions.\nProvide restricted (closed-shell) and unrestricted (open-shell) Hartreeâ€“Fock methods (RHF & UHF).\nProvide dynamic computation-graph based function generation and variational optimization.","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"#OS-and-hardware-platform-support","page":"Home","title":"OS and hardware platform support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Windows (x86-64)\nGeneric Linux (x86-64)\nmacOS (x86-64 and Apple silicon)","category":"page"},{"location":"#Julia-(64-bit)-compatibility","page":"Home","title":"Julia (64-bit) compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, Quiqbox tries to support the latest stable release of 64-bit Julia as soon as possible. Backward compatibility with previous versions is not guaranteed but can be checked here.","category":"page"},{"location":"#Installation-in-Julia-[REPL](https://docs.julialang.org/en/v1/stdlib/REPL/)","page":"Home","title":"Installation in Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type ] in the default Julian mode to switch to the Pkg mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type the following command and hit Enter key to install Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg> add Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the installation completes, hit the Backspace key to go back to the Julian mode and use using to load Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more basic usage of the programming language behind Quiqbox, Julia, please refer to the official documentation.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Quiqbox in your research, please cite the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Wang, W., & Whitfield, J. D. (2023). Basis set generation and optimization in the NISQ era with Quiqbox.jl. Journal of Chemical Theory and Computation, 19(22), 8032-8052.][JCTC-url]","category":"page"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"SCF.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"[JCTC-url]: https://pubs.acs.org/doi/10.1021/acs.jctc.3c00011","category":"page"}]
}
