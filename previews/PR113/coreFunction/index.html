<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions ¬∑ Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/main/docs/src/coreFunction.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getCharge-Tuple{Union{Tuple{Vararg{String, N}}, AbstractVector{&lt;:String}} where N}" href="#Quiqbox.getCharge-Tuple{Union{Tuple{Vararg{String, N}}, AbstractVector{&lt;:String}} where N}"><code>Quiqbox.getCharge</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCharge(nucs::Union{AbstractVector{String}, Tuple{Vararg{String}}}) -&gt; Int</code></pre><p>Return the total electric charge (in ùëí) of the input nuclei.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Library.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalLin" href="#Quiqbox.orbitalLin"><code>Quiqbox.orbitalLin</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbitalLin(subshell::String, D::Int=3) -&gt; Tuple{Vararg{NTuple{3, Int}}}</code></pre><p>Return all the possible angular momentum configuration(s) within the input <code>subshell</code> of  <code>D</code> dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Library.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeMapping-Union{Tuple{ParamBox{T, V}}, Tuple{V}, Tuple{T}, Tuple{ParamBox{T, V}, Function}, Tuple{ParamBox{T, V}, Function, Symbol}} where {T, V}" href="#Quiqbox.changeMapping-Union{Tuple{ParamBox{T, V}}, Tuple{V}, Tuple{T}, Tuple{ParamBox{T, V}, Function}, Tuple{ParamBox{T, V}, Function, Symbol}} where {T, V}"><code>Quiqbox.changeMapping</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeMapping(pb::ParamBox{T, V}, mapFunction::Function=itself, outSym::Symbol=V; 
              canDiff::Union{Bool, Array{Bool, 0}}=isDiffParam(pb)) where {T, V} -&gt; 
ParamBox{T, outSym}</code></pre><p>Change the mapping function of <code>pb</code>. The symbol of the output variable of the returned  <code>ParamBox</code> can be specified by <code>outSym</code>, and its differentiability is determined by  <code>canDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L317-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dataOf-Tuple{ParamBox}" href="#Quiqbox.dataOf-Tuple{ParamBox}"><code>Quiqbox.dataOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dataOf(pb::ParamBox{T}) where {T} -&gt; Pair{Array{T, 0}, Symbol}</code></pre><p>Return the <code>Pair</code> of the input variable and its symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.disableDiff!-Tuple{ParamBox}" href="#Quiqbox.disableDiff!-Tuple{ParamBox}"><code>Quiqbox.disableDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disableDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Mark <code>pb</code> as &quot;non-differentiable&quot; and then return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.enableDiff!-Tuple{ParamBox}" href="#Quiqbox.enableDiff!-Tuple{ParamBox}"><code>Quiqbox.enableDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enableDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Mark <code>pb</code> as &quot;differentiable&quot; and then return <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L273-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.fullVarCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V" href="#Quiqbox.fullVarCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>Quiqbox.fullVarCopy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fullVarCopy(pb::T) where {T&lt;:ParamBox} -&gt; T</code></pre><p>A shallow copy of the input <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymOf-Tuple{ParamBox}" href="#Quiqbox.inSymOf-Tuple{ParamBox}"><code>Quiqbox.inSymOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the symbol of the input variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inValOf-Tuple{ParamBox}" href="#Quiqbox.inValOf-Tuple{ParamBox}"><code>Quiqbox.inValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inValOf(pb::ParamBox{T}) where {T} -&gt; T</code></pre><p>Return the value of the input variable of <code>pb</code>. Equivalent to <code>pb[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.indVarOf-Tuple{ParamBox}" href="#Quiqbox.indVarOf-Tuple{ParamBox}"><code>Quiqbox.indVarOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indVarOf(pb::ParamBox{T}) -&gt; Pair{}</code></pre><p>Return (the name and the value of) the independent variable tied to <code>pb</code>. Specifically,  return the input variable stored in <code>pb</code> when <code>pb</code> is marked as differentiable; return the  output variable of <code>pb</code> when <code>pb</code> is marked as non-differentiable. Thus, it is the variable  <code>pb</code> represents to differentiate any (differentiable) function of <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L191-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isDiffParam-Tuple{ParamBox}" href="#Quiqbox.isDiffParam-Tuple{ParamBox}"><code>Quiqbox.isDiffParam</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isDiffParam(pb::ParamBox) -&gt; Bool</code></pre><p>Return the Boolean value of whether <code>pb</code> is differentiable with respect to its input  variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L263-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isInSymEqual-Tuple{ParamBox, Symbol}" href="#Quiqbox.isInSymEqual-Tuple{ParamBox, Symbol}"><code>Quiqbox.isInSymEqual</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isInSymEqual(pb::ParamBox, sym::Symbol) -&gt; Bool</code></pre><p>Return the Boolean value of whether the symbol of  <code>pb</code>&#39;s input variable equals <code>sym</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isOutSymEqual-Union{Tuple{V}, Tuple{ParamBox{&lt;:Any, V}, Symbol}} where V" href="#Quiqbox.isOutSymEqual-Union{Tuple{V}, Tuple{ParamBox{&lt;:Any, V}, Symbol}} where V"><code>Quiqbox.isOutSymEqual</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isOutSymEqual(::ParamBox, sym::Symbol) -&gt; Bool</code></pre><p>Return the Boolean value of whether the symbol of  <code>pb</code>&#39;s output variable equals <code>sym</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mapOf-Tuple{ParamBox}" href="#Quiqbox.mapOf-Tuple{ParamBox}"><code>Quiqbox.mapOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapOf(pb::ParamBox) -&gt; Function</code></pre><p>Return the mapping function of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outSymOf-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V" href="#Quiqbox.outSymOf-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>Quiqbox.outSymOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the symbol of the output variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V" href="#Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>Quiqbox.outValCopy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outValCopy(pb::ParamBox{T, V}) where {T} -&gt; ParamBox{T, V, typeof(itself)}</code></pre><p>Return a new <code>ParamBox</code> of which the input variable&#39;s value is equal to the output  variable&#39;s value of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValOf-Tuple{ParamBox}" href="#Quiqbox.outValOf-Tuple{ParamBox}"><code>Quiqbox.outValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of the output variable of <code>pb</code>. Equivalent to <code>pb()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.toggleDiff!-Tuple{ParamBox}" href="#Quiqbox.toggleDiff!-Tuple{ParamBox}"><code>Quiqbox.toggleDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">toggleDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Toggle the differentiability of the input <code>pb</code> and then return the updated boolean value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Parameters.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.absorbNormFactor-Tuple{BasisFunc{&lt;:Any, 3}}" href="#Quiqbox.absorbNormFactor-Tuple{BasisFunc{&lt;:Any, 3}}"><code>Quiqbox.absorbNormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorbNormFactor(b::BasisFunc{T, 3, ùëô, GN, PT}) where {T, ùëô, GN, PT} -&gt; 
FloatingGTBasisFuncs{T, 3, ùëô, GN, PT}

absorbNormFactor(b::BasisFuncs{T, 3, ùëô, GN, PT}) where {T, ùëô, GN, PT} -&gt; 
Vector{&lt;:FloatingGTBasisFuncs{T, 3, ùëô, GN, PT}}</code></pre><p>If <code>hasNormFactor(</code>b<code>) == true</code>, absorb the normalization factor of each Gaussian-type  orbital inside <code>b</code> into the orbital&#39;s corresponding contraction coefficient and then set  <code>.normalizeGTO</code> of <code>b</code> to <code>false</code>. Otherwise, directly return <code>b</code> when it&#39;s a <code>BasisFunc</code>,  or <code>[b]</code> when it&#39;s a <code>BasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L2002-L2014">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.absorbNormFactor-Tuple{Quiqbox.BasisFuncMix{var&quot;#s59&quot;, 3, BN, BFT} where {var&quot;#s59&quot;, BN, BFT&lt;:(BasisFunc{var&quot;#s59&quot;, 3})}}" href="#Quiqbox.absorbNormFactor-Tuple{Quiqbox.BasisFuncMix{var&quot;#s59&quot;, 3, BN, BFT} where {var&quot;#s59&quot;, BN, BFT&lt;:(BasisFunc{var&quot;#s59&quot;, 3})}}"><code>Quiqbox.absorbNormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorbNormFactor(bfm::BasisFuncMix{T, 3}) where {T} -&gt; GTBasisFuncs{T, 3}</code></pre><p>Apply <code>absorbNormFactor</code> to every one of the <code>BasisFunc</code> inside <code>bfm</code> and them sum them  over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L2034-L2040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.absorbNormFactor-Union{Tuple{AbstractVector{&lt;:GTBasisFuncs{T, 3}}}, Tuple{T}} where T" href="#Quiqbox.absorbNormFactor-Union{Tuple{AbstractVector{&lt;:GTBasisFuncs{T, 3}}}, Tuple{T}} where T"><code>Quiqbox.absorbNormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorbNormFactor(bs::AbstractVector{&lt;:GTBasisFuncs{T, 3}}) where {T} -&gt; 
AbstractVector{&lt;:GTBasisFuncs{T, 3}}

absorbNormFactor(bs::Tuple{Vararg{GTBasisFuncs{T, 3}}}) where {T} -&gt; 
Tuple{Vararg{GTBasisFuncs{T, 3}}}</code></pre><p>Apply <code>absorbNormFactor</code> to every element inside <code>bs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L2044-L2053">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.add-Tuple{BasisFuncs{T, D, ùëô, GN, PT, 1} where {T, D, ùëô, GN, PT}}" href="#Quiqbox.add-Tuple{BasisFuncs{T, D, ùëô, GN, PT, 1} where {T, D, ùëô, GN, PT}}"><code>Quiqbox.add</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(b1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, 
    b2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; 
    roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code></pre><p>Addition between two <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code> such as <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a>  and <a href="../coreType/#Quiqbox.BasisFuncMix"><code>BasisFuncMix</code></a>. <code>roundAtol</code> specifies the absolute approximation tolerance of  comparing parameters stored in each <code>CompositeGTBasisFuncs</code> to determine whether they are  treated as &quot;equal&quot;; each parameter in the returned <code>CompositeGTBasisFuncs</code> is set to the  nearest exact multiple of <code>0.5atol</code>. When <code>roundAtol</code> is set to <code>NaN</code>, there will be no  approximation nor rounding. This function can be called using <code>+</code> syntax with the keyword  argument set to it default value. </p><p><strong>NOTE:</strong> For the <code>ParamBox</code> (stored in the input  arguments) that are marked as non-differentiable, they will be fused together if possible  to generate new <code>ParamBox</code>(s) no longer linked to the input variable stored in them.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1.,1.,1.], (2.,1.));

julia&gt; bf2 = genBasisFunc([1.,1.,1.], (2.,2.));

julia&gt; bf3 = bf1 + bf2;

julia&gt; bf3.gauss[1].con() == bf1.gauss[1].con() + bf2.gauss[1].con()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L995-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.assignCenInVal!-Tuple{FloatingGTBasisFuncs, AbstractVector{&lt;:Real}}" href="#Quiqbox.assignCenInVal!-Tuple{FloatingGTBasisFuncs, AbstractVector{&lt;:Real}}"><code>Quiqbox.assignCenInVal!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assignCenInVal!(b::FloatingGTBasisFuncs{T, D}, center::AbstractVector{&lt;:Real}) -&gt; 
SpatialPoint{T, D}</code></pre><p>Change the input value of the <code>ParamBox</code> stored in <code>b.center</code> (meaning the output value  will also change according to the mapping function). Then, return the altered center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1768-L1775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerCoordOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.centerCoordOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.centerCoordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centerCoordOf(bf::FloatingGTBasisFuncs{T}) where {T} -&gt; Vector{T}</code></pre><p>Return the center coordinate of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L728-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.centerOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.centerOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centerOf(bf::FloatingGTBasisFuncs{T, D}) where {T, D} -&gt; SpatialPoint{T, D}</code></pre><p>Return the center of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L719-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coordOf-Union{Tuple{SpatialPoint{T}}, Tuple{T}} where T" href="#Quiqbox.coordOf-Union{Tuple{SpatialPoint{T}}, Tuple{T}} where T"><code>Quiqbox.coordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordOf(sp::SpatialPoint{T}) where {T} -&gt; Vector{T}</code></pre><p>Get the coordinate represented by the input <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L286-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.copyBasis" href="#Quiqbox.copyBasis"><code>Quiqbox.copyBasis</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyBasis(b::GaussFunc, copyOutVal::Bool=true) -&gt; GaussFunc

copyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -&gt; CompositeGTBasisFuncs</code></pre><p>Return a copy of the input basis. If <code>copyOutVal</code> is set to <code>true</code>, then only the output  value(s) of the <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>(s) stored in <code>b</code> will be copied, i.e.,  <a href="#Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>outValCopy</code></a> is used, otherwise <a href="#Quiqbox.fullVarCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>fullVarCopy</code></a> is used.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; f(x)=x^2; e = genExponent(3.0, f)
ParamBox{Float64, :Œ±, typeof(f)}(3.0)[ùõõ][x_Œ±]

julia&gt; c = genContraction(2.0)
ParamBox{Float64, :d, iT}(2.0)[‚àÇ][d]

julia&gt; gf1 = GaussFunc(e, c);

julia&gt; gf2 = copyBasis(gf1)
GaussFunc{Float64, iT, iT}(xpn()=9.0, con()=2.0, param)[‚àÇ][‚àÇ]

julia&gt; gf1.xpn() == gf2.xpn()
true

julia&gt; (gf1.xpn[] |&gt; gf1.xpn.map) == gf2.xpn[]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1854-L1884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.decompose" href="#Quiqbox.decompose"><code>Quiqbox.decompose</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(bf::CompositeGTBasisFuncs{T, D}, splitGaussFunc::Bool=false) -&gt; 
Matrix{&lt;:BasisFunc{T, D}}</code></pre><p>Decompose a <code>CompositeGTBasisFuncs</code> into a <code>Matrix</code> of <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a>s. The sum of  each column represents one orbital of the input basis function(s). If <code>splitGaussFunc</code> is  <code>true</code>, then each column consists of the <code>BasisFunc</code>s with only 1 <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1518-L1526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dimOf-Union{Tuple{Quiqbox.DimensionalParamContainer{&lt;:Any, D}}, Tuple{D}} where D" href="#Quiqbox.dimOf-Union{Tuple{Quiqbox.DimensionalParamContainer{&lt;:Any, D}}, Tuple{D}} where D"><code>Quiqbox.dimOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimOf(::DimensionalParamContainer) -&gt; Int</code></pre><p>Return the spatial dimension of the input parameterized container such as  <code>AbstractSpatialPoint</code> and <code>QuiqboxBasis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L816-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gaussCoeffOf-Union{Tuple{FloatingGTBasisFuncs{T, &lt;:Any, &lt;:Any, GN}}, Tuple{GN}, Tuple{T}} where {T, GN}" href="#Quiqbox.gaussCoeffOf-Union{Tuple{FloatingGTBasisFuncs{T, &lt;:Any, &lt;:Any, GN}}, Tuple{GN}, Tuple{T}} where {T, GN}"><code>Quiqbox.gaussCoeffOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussCoeffOf(b::FloatingGTBasisFuncs{T}) -&gt; Matrix{T}</code></pre><p>Return the exponent and contraction coefficients of each <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a> (in each row  of the returned <code>Matrix</code>) inside <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L745-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gaussCoeffOf-Union{Tuple{GaussFunc{T}}, Tuple{T}} where T" href="#Quiqbox.gaussCoeffOf-Union{Tuple{GaussFunc{T}}, Tuple{T}} where T"><code>Quiqbox.gaussCoeffOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussCoeffOf(gf::GaussFunc{T}) -&gt; Matrix{T}</code></pre><p>Return the exponent and contraction coefficients of <code>gf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L737-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T&lt;:AbstractFloat}" href="#Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T&lt;:AbstractFloat}"><code>Quiqbox.genBFuncsFromText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBFuncsFromText(content::String; 
                  adjustContent::Bool=false, 
                  adjustFunction::Function=sciNotReplace, 
                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, 
                  center::Union{AbstractArray{T}, 
                                NTuple{D, T}, 
                                NTuple{D, ParamBox{T}}, 
                                SpatialPoint{T, D}, 
                                Missing}=(NaN, NaN, NaN), 
                  unlinkCenter::Bool=false, 
                  normalizeGTO::Union{Bool, Missing}=
                                ifelse(adjustContent, true, missing)) where 
                 {D, T&lt;:AbstractFloat} -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 1}</code></pre><p>Generate a basis set from <code>content</code> which is either a basis set <code>String</code> in Gaussian format  or the output from <code>genBasisFuncText</code>. For the former, <code>adjustContent</code> needs to be set to  <code>true</code>. <code>adjustFunction</code> is only applied when <code>adjustContent=true</code>, which in default is a  <code>function</code> used to detect and convert the format of the scientific notation in <code>content</code>.</p><p><code>excludeFirstNlines</code> and <code>excludeLastNlines</code> are used to exclude first or last few lines of  <code>content</code> if intended. <code>center</code> is used to assign a center coordinate for all the basis  functions from <code>content</code>; when it&#39;s set to <code>missing</code>, it will try to read the center  information in <code>content</code>, and leave the center as <code>[NaN, NaN, Nan]</code> if one cannot be found  for each corresponding <code>FloatingGTBasisFuncs</code>. If <code>unlinkCenter = true</code>, the center of each  <code>FloatingGTBasisFuncs</code> is a <code>Base.deepcopy</code> of the input <code>center</code>. Otherwise, they share  the same underlying data so changing the value of one will affect others. If the center  coordinate is included in <code>content</code>, it should be right above the subshell information for  the <code>FloatingGTBasisFuncs</code>. E.g.:</p><pre><code class="nohighlight hljs">&quot;&quot;&quot;
X        1.0                       0.0                       0.0                
S    1   1.0   false
         2.0                       1.0
&quot;&quot;&quot;</code></pre><p>Finally, <code>normalizeGTO</code> specifies the field <code>.normalizeGTO</code> of the generated  <code>FloatingGTBasisFuncs</code>. If it&#39;s set to <code>missing</code> (in default), the normalization  configuration of each <code>FloatingGTBasisFuncs</code> will depend on <code>content</code>, so different basis  functions may have different normalization configurations. However, when it&#39;s set to a  <code>Bool</code> value, <code>.normalizeGTO</code> of all the generated basis functions will be set to that  value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1652-L1693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFunc-Union{Tuple{ùëô}, Tuple{GN}, Tuple{T}, Tuple{D}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}, LTuple{D, ùëô}}} where {D, T, GN, ùëô}" href="#Quiqbox.genBasisFunc-Union{Tuple{ùëô}, Tuple{GN}, Tuple{T}, Tuple{D}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}, LTuple{D, ùëô}}} where {D, T, GN, ùëô}"><code>Quiqbox.genBasisFunc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFunc(center::Union{AbstractVector{T}, Tuple{Vararg{T}}, SpatialPoint, Missing}, 
             args..., kws...) where {T&lt;:Union{AbstractFloat, ParamBox}} -&gt; 
Union{FloatingGTBasisFuncs{T}, Vector{&lt;:FloatingGTBasisFuncs{T}}}</code></pre><p>The constructor of <code>FloatingGTBasisFuncs</code>, but it also returns different kinds of  collections (<code>Vector</code>) of them based on the input arguments. The first argument <code>center</code>  specifies the center coordinate of the generated <code>FloatingGTBasisFuncs</code>, and can be left as  <code>missing</code> for later assignment.</p><p>‚â°‚â°‚â° Method 1 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, GsOrCoeffs, Ls; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs</code></pre><p>=== Positional argument(s) ===</p><p><code>GsOrCoeffs::Union{     AbstractGaussFunc{T1},      AbstractVector{&lt;:AbstractGaussFunc{T1}},      Tuple{Vararg{AbstractGaussFunc{T1}}},      NTuple{2, T1},      NTuple{2, AbstractVector{T1}} } where {T1&lt;:AbstractFloat}</code>: A collection of concentric <code>GaussFunc</code> that will be used to  construct the basis function. To simplify the procedure, it can also be in the form of a  <code>NTuple{2}</code> of the exponent coefficient(s)<code>::Union{AbstractFloat,  AbstractVector{&lt;:AbstractFloat}}</code> and contraction coefficients<code>::Union{AbstractFloat,  AbstractVector{&lt;:AbstractFloat}}</code> of the <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a>(s) to be input.</p><p><code>Ls::Union{     T2,      AbstractVector{T2},      NTuple{&lt;:Any, T2} } where {T2&lt;:Union{Tuple{Vararg{Int}}, LTuple}}</code>: A collection of angular momentum(s)  within the same subshell, in the Cartesian coordinate representation. E.g., for p shell it  can be set to <code>((1,0,0), (0,1,0))</code>. This will determine the number of spatial orbitals and  their angular momentum respectively to be stored in the output <code>FloatingGTBasisFuncs</code>.</p><p>=== Keyword argument(s) ===</p><p><code>normalizeGTO::Bool</code>: Determine whether the inside <code>GaussFunc</code>(s) will be normalized in the  during the calculation. </p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], GaussFunc(2.,1.), (0,1,0))
BasisFunc{Float64, 3, 1, 1}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y¬πZ‚Å∞][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 2 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, GsOrCoeffs, subshell=&quot;s&quot;; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs

genBasisFunc(center, GsOrCoeffs, subshell, lFilter; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs</code></pre><p>=== Positional argument(s) ===</p><p><code>subshell::String</code>: The third argument of the constructor can also be the name of a  subshell, which will make sure the output is a <code>BasisFuncs</code> that contains the spatial  orbitals that fully occupy the subshell.</p><p><code>lFilter::Tuple{Vararg{Bool}}</code>: When this 4th argument is provided, it can determine the  orbital(s) to be included based on the given <code>subshell</code>. The order of the corresponding  orbital angular momentum(s) can be inspected using function <code>orbitalLin</code>.</p><p>=== Keyword argument(s) ===</p><p><code>normalizeGTO::Bool</code>: Same as the one defined in method 1.</p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], (2., 1.), &quot;p&quot;)
BasisFuncs{Float64, 3, 1, 1, P3D{Float64, iT, iT, iT}, 3}(center, gauss, l, normalizeGTO, param)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0.,0.,0.], (2., 1.5), &quot;p&quot;, (true, false, true))
BasisFuncs{Float64, 3, 1, 1, P3D{Float64, iT, iT, iT}, 2}(center, gauss, l, normalizeGTO, param)[2/3][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 3 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, BSkey, atm=&quot;H&quot;; unlinkCenter=false) -&gt; 
Vector{&lt;:FloatingGTBasisFuncs}</code></pre><p>=== Positional argument(s) ===</p><p><code>BSkey::String</code>: The name of an existed atomic basis set. The supported options are in  <code>[&quot;STO-2G&quot;, &quot;STO-3G&quot;, &quot;STO-6G&quot;, &quot;3-21G&quot;, &quot;6-31G&quot;, &quot;cc-pVDZ&quot;, &quot;cc-pVTZ&quot;, &quot;cc-pVQZ&quot;]</code>.</p><p><code>atm::String</code>: The name of the atom corresponding to the chosen basis set. The supported  options are in <code>[&quot;H&quot;, &quot;He&quot;, &quot;Li&quot;, &quot;Be&quot;, &quot;B&quot;, &quot;C&quot;, &quot;N&quot;, &quot;O&quot;, &quot;F&quot;, &quot;Ne&quot;, &quot;Na&quot;, &quot;Mg&quot;, &quot;Al&quot;, &quot;Si&quot;, &quot;P&quot;, &quot;S&quot;, &quot;Cl&quot;, &quot;Ar&quot;, &quot;K&quot;, &quot;Ca&quot;]</code>.</p><p>=== Keyword argument(s) ===</p><p><code>unlinkCenter::Bool</code>: Determine whether the centers of constructed <code>FloatingGTBasisFuncs</code>  are linked to each other. If set to <code>true</code>, the center of each <code>FloatingGTBasisFuncs</code> is a  <code>Base.deepcopy</code> of each other. Otherwise, they share the same underlying data so changing  the value of one will affect others.</p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], &quot;6-31G&quot;);

julia&gt; genBasisFunc([0.,0.,0.], &quot;STO-3G&quot;, &quot;Li&quot;);</code></pre><p>‚â°‚â°‚â° Method 4 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(b::FloatingGTBasisFuncs{T, D}, newFieldVal) where {T, D} -&gt; 
FloatingGTBasisFuncs{T, D}</code></pre><p>=== Positional argument(s) ===</p><p><code>field::Union{     SpatialPoint{T, D},      Tuple{Vararg{AbstractGaussFunc{T}}},      Tuple{Vararg{LTuple{D, ùëô}}} where ùëô,      Bool } where {T&lt;:AbstractFloat, D}</code>: Any one of the fields inside a <code>FloatingGTBasisFuncs</code>  except <code>param</code>.</p><p>This method outputs a <code>FloatingGTBasisFuncs</code> that has identical fields as the input one  except the field that can be replaced by <code>newFieldVal</code> (and <code>param</code> if the replaced field  contains <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L411-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText-Union{Tuple{FloatingGTBasisFuncs{T, D}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.genBasisFuncText-Union{Tuple{FloatingGTBasisFuncs{T, D}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.genBasisFuncText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bf::FloatingGTBasisFuncs; 
                 norm::Real=1.0, printCenter::Bool=true, roundDigits::Int=-1) -&gt; String</code></pre><p>Generate the text of input <code>FloatingGTBasisFuncs</code>. <code>norm</code> is the additional normalization  factor. If <code>printCenter</code> is <code>true</code>, the center coordinate will be added to the first line  of the output <code>String</code>. <code>roundDigits</code> specifies the rounding digits for the parameters  inside <code>bf</code>; when set to negative, no rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1589-L1598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText-Union{Tuple{Union{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.genBasisFuncText-Union{Tuple{Union{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.genBasisFuncText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bs::Union{AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}, 
                           Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}; 
                 norm::Real=1.0, printCenter::Bool=true, 
                 groupCenters::Bool=true, roundDigits::Int=-1) where {T, D} -&gt; 
String</code></pre><p>Generate the text of input basis set (consisting of <code>FloatingGTBasisFuncs</code>). <code>norm</code> is the  additional normalization factor. <code>groupCenters</code> determines whether the function will group  the basis functions with same center together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1611-L1622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction-Tuple{ParamBox}" href="#Quiqbox.genContraction-Tuple{ParamBox}"><code>Quiqbox.genContraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genContraction(pb::ParamBox{T}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :d}</code></pre><p>Convert a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> to an exponent coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T&lt;:AbstractFloat" href="#Quiqbox.genContraction-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T&lt;:AbstractFloat"><code>Quiqbox.genContraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genContraction(d::T, mapFunction::Function=itself; 
               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), 
               inSym::Symbol=x_d) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :d}

genContraction(d::Array{T, 0}, mapFunction::Function=itself; 
               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), 
               inSym::Symbol=x_d) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :d}

genContraction(dData::Pair{Array{T, 0}, Symbol}, 
               mapFunction::Function=itself; 
               canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true)) where 
              {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :d}</code></pre><p>Construct a contraction coefficient given a value or variable (with its symbol).  <code>mapFunction</code>, <code>canDiff</code>, and <code>inSym</code> work the same way as in a general constructor of a  <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L96-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent-Tuple{ParamBox}" href="#Quiqbox.genExponent-Tuple{ParamBox}"><code>Quiqbox.genExponent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genExponent(pb::ParamBox{T}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :Œ±}</code></pre><p>Convert a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> to the container of an exponent coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T&lt;:AbstractFloat" href="#Quiqbox.genExponent-Union{Tuple{Pair{Array{T, 0}, Symbol}}, Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Function}} where T&lt;:AbstractFloat"><code>Quiqbox.genExponent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genExponent(e::T, mapFunction::Function=itself; 
            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), 
            inSym::Symbol=x_Œ±) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :Œ±}

genExponent(e::Array{T, 0}, mapFunction::Function=itself; 
            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true), 
            inSym::Symbol=x_Œ±) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :Œ±}

genExponent(eData::Pair{Array{T, 0}, Symbol}, 
            mapFunction::Function=itself; 
            canDiff::Bool=ifelse(FLevel(mapFunction)==FLevel{0}, false, true)) where 
           {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :Œ±}</code></pre><p>Construct an exponent coefficient given a value or variable (with its symbol).  <code>mapFunction</code>, <code>canDiff</code>, and <code>inSym</code> work the same way as in a general constructor of a  <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L50-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Tuple{AbstractVector}" href="#Quiqbox.genSpatialPoint-Tuple{AbstractVector}"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(point::Union{NTuple{D, Union{T, Array{T, 0}}}, 
                             AbstractVector}) where {D, T&lt;:AbstractFloat} -&gt; 
SpatialPoint{T, D}</code></pre><p>Construct a <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a> from a collection of coordinate components. ‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; v1 = [1.0, 2.0, 3.0];

julia&gt; genSpatialPoint(v1)
SpatialPoint{Float64, 3}{PBFL{(0, 0, 0)}}(param)[1.0, 2.0, 3.0][‚àÇ][‚àÇ][‚àÇ]

julia&gt; v2 = [fill(1.0), 2.0, 3.0];

julia&gt; p2 = genSpatialPoint(v2); p2[1]
ParamBox{Float64, :X, iT}(1.0)[‚àÇ][X]

julia&gt; v2[1][] = 1.2
1.2

julia&gt; p2[1]
ParamBox{Float64, :X, iT}(1.2)[‚àÇ][X]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L173-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Union{Tuple{Tuple{Vararg{ParamBox{T}, D}}}, Tuple{T}, Tuple{D}} where {D, T}" href="#Quiqbox.genSpatialPoint-Union{Tuple{Tuple{Vararg{ParamBox{T}, D}}}, Tuple{T}, Tuple{D}} where {D, T}"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(point::Union{Tuple{Vararg{ParamBox{T}}}, 
                AbstractVector{&lt;:ParamBox{T}}}) where {T} -&gt; 
SpatialPoint{T}</code></pre><p>Convert a collection of <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>s to a <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L271-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Union{Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Int64}, Tuple{Pair{Array{T, 0}, Symbol}, Int64, Function}} where T&lt;:AbstractFloat" href="#Quiqbox.genSpatialPoint-Union{Tuple{T}, Tuple{Pair{Array{T, 0}, Symbol}, Int64}, Tuple{Pair{Array{T, 0}, Symbol}, Int64, Function}} where T&lt;:AbstractFloat"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(comp::T, compIndex::Int, 
                mapFunction::Function=itself; 
                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true), 
                inSym::Symbol=conIVsym) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T}

genSpatialPoint(comp::Array{T, 0}, compIndex::Int, 
                mapFunction::Function=itself; 
                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true), 
                inSym::Symbol=conIVsym) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T}

genSpatialPoint(compData::Pair{Array{T, 0}, Symbol}, compIndex::Int, 
                mapFunction::Function=itself; 
                canDiff::Bool=ifelse(FLevel(mapFunction)==IL, false, true)) -&gt; 
ParamBox{T}</code></pre><p>Construct a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> as the <code>compIndex</code> th component of a <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>  given a value or variable (with its symbol). <code>mapFunction</code>, <code>canDiff</code>, and <code>inSym</code> work  the same way as in a general constructor of a <code>ParamBox</code>.</p><pre><code class="nohighlight hljs">genSpatialPoint(point::ParamBox{T}, compIndex::Int) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T}</code></pre><p>Convert a <code>ParamBox</code> to the <code>compIndex</code> th component of a <code>SpatialPoint</code>.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genSpatialPoint(1.2, 1)
ParamBox{Float64, :X, iT}(1.2)[‚àÇ][X]

julia&gt; pointY1 = fill(2.0);

julia&gt; Y1 = genSpatialPoint(pointY1, 2)
ParamBox{Float64, :Y, iT}(2.0)[‚àÇ][Y]

julia&gt; pointY1[] = 1.5;

julia&gt; Y1
ParamBox{Float64, :Y, iT}(1.5)[‚àÇ][Y]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L204-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getNormFactor-Union{Tuple{FloatingGTBasisFuncs{T, 3, ùëô, GN, PT, 1} where PT}, Tuple{GN}, Tuple{ùëô}, Tuple{T}} where {T, ùëô, GN}" href="#Quiqbox.getNormFactor-Union{Tuple{FloatingGTBasisFuncs{T, 3, ùëô, GN, PT, 1} where PT}, Tuple{GN}, Tuple{ùëô}, Tuple{T}} where {T, ùëô, GN}"><code>Quiqbox.getNormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNormFactor(b::FloatingGTBasisFuncs{T, 3}) where {T} -&gt; Array{T}</code></pre><p>Return the normalization factors of the Gaussian-type orbitals (GTO) inside the input <code>b</code>.  Each column corresponds to one orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1988-L1994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getParams" href="#Quiqbox.getParams"><code>Quiqbox.getParams</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParams(pbc::ParamBox, symbol::Union{Symbol, Missing}=missing) -&gt; 
Union{ParamBox, Nothing}

getParams(pbc::ParameterizedContainer, symbol::Union{Symbol, Missing}=missing) -&gt; 
AbstractVector{&lt;:ParamBox}

getParams(pbc::Union{AbstractArray, Tuple}, symbol::Union{Symbol, Missing}=missing) -&gt; 
AbstractVector{&lt;:ParamBox}</code></pre><p>Return the parameter(s) stored in the input container. If <code>symbol</code> is set to <code>missing</code>,  then return all the parameter(s). If it&#39;s set to a <code>Symbol</code> tied to a parameter, for  example <code>:Œ±‚ÇÅ</code>, the function will match any <code>pb::</code><a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> such that  <a href="#Quiqbox.indVarOf-Tuple{ParamBox}"><code>indVarOf</code></a><code>(pb)[begin] == :Œ±‚ÇÅ</code>. If it&#39;s set to a <code>Symbol</code> without any subscript,  for example <code>:Œ±</code>, the function will match it with all the <code>pb</code>s such that  <code>string(indVarOf(pb)[begin])</code> contains <code>&#39;Œ±&#39;</code>. If the first argument is a collection, its  entries must be <code>ParamBox</code> containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1784-L1802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.hasNormFactor-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.hasNormFactor-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.hasNormFactor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasNormFactor(b::FloatingGTBasisFuncs) -&gt; Bool</code></pre><p>Indicate whether <code>b</code>&#39; is be treated as having additional normalization factor(s) which its  Gaussian-type orbital(s) will be multiplied by during any calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1966-L1972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.lOf-Union{Tuple{FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, ùëô}}, Tuple{ùëô}} where ùëô" href="#Quiqbox.lOf-Union{Tuple{FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, ùëô}}, Tuple{ùëô}} where ùëô"><code>Quiqbox.lOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lOf(::FloatingGTBasisFuncs) -&gt; Int</code></pre><p>Return the total orbital angular momentum quantum number (in Cartesian coordinate  representation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.markParams!-Union{Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}}, Tuple{T}, Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}, Bool}} where T&lt;:Quiqbox.ParameterizedContainer" href="#Quiqbox.markParams!-Union{Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}}, Tuple{T}, Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}, Bool}} where T&lt;:Quiqbox.ParameterizedContainer"><code>Quiqbox.markParams!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">markParams!(b::Union{AbstractVector{T}, T, Tuple{Vararg{T}}}, 
            filterMapping::Bool=false) where {T&lt;:ParameterizedContainer} -&gt; 
Vector{&lt;:ParamBox}</code></pre><p>Mark the parameters (<a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>) in <code>b</code>. The parameters that hold the same  independent variable (in other words, considered identical in the differentiation  procedure) will be marked with same index. <code>filterMapping</code> determines whether filtering out  (i.e. not return) the extra <code>ParamBox</code>es that hold the same independent variables but  represent different output variables. The independent variable held by a <code>ParamBox</code> can be  inspected using <a href="#Quiqbox.indVarOf-Tuple{ParamBox}"><code>indVarOf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1895-L1907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mergeBasisFuncsIn-Union{Tuple{Union{Tuple{Vararg{GTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.mergeBasisFuncsIn-Union{Tuple{Union{Tuple{Vararg{GTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.mergeBasisFuncsIn</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergeBasisFuncsIn(bs::Union{AbstractVector{&lt;:GTBasisFuncs{T, D}}, 
                            Tuple{Vararg{GTBasisFuncs{T, D}}}}; 
                  roundAtol::Real=NaN) where {T, D} -&gt; 
Vector{&lt;:GTBasisFuncs{T, D}}</code></pre><p>Try merging multiple <code>FloatingGTBasisFuncs</code> (if there&#39;s any) in <code>bs</code> into  <code>FloatingGTBasisFuncs{T, D, &lt;:Any, &lt;:Any, &lt;:Any, ON}</code> where <code>ON &gt; 1</code> if possible and then  return the resulted basis collection. If no merging is performed, then the returned  collection is same as (but not necessarily identical to) <code>bs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1159-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{ùëô2}, Tuple{ùëô1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, ùëô1, 1, PT1}, BasisFunc{T, D, ùëô2, 1, PT2}}} where {T, D, ùëô1, ùëô2, PT1, PT2}" href="#Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{ùëô2}, Tuple{ùëô1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, ùëô1, 1, PT1}, BasisFunc{T, D, ùëô2, 1, PT2}}} where {T, D, ùëô1, ùëô2, PT1, PT2}"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(a1::Real, a2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, a2::Real; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, 
    a2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code></pre><p>Multiplication between two <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code> (e.g.,   <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a> and <a href="../coreType/#Quiqbox.BasisFuncMix"><code>BasisFuncMix</code></a>), or a <code>Real</code> number and a  <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code>. If <code>normalizeGTO</code> is set to <code>missing</code> (in  default), The <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a> inside the output containers will be normalized only if  every input <code>FloatingGTBasisFuncs</code> (or inside the input <code>CompositeGTBasisFuncs</code>) holds  <code>hasNormFactor(ai) == true</code>. <code>roundAtol</code> specifies the absolute approximation tolerance of  comparing parameters stored in each <code>CompositeGTBasisFuncs</code> to determine whether they are  treated as &quot;equal&quot;; each parameter in the returned <code>CompositeGTBasisFuncs</code> is set to the  nearest exact multiple of <code>0.5atol</code>. When <code>roundAtol</code> is set to <code>NaN</code>, there will be no  approximation nor rounding. This function can be called using <code>*</code> syntax with the keyword  argument set to it default value.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1.0, 1.0, 1.0], ([2.0, 1.0], [0.1, 0.2]))
BasisFunc{Float64, 3, 0, 2}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf2 = bf1 * 2
BasisFunc{Float64, 3, 0, 2}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; getindex.(getproperty.(bf2.gauss, :con))
(0.2, 0.4)

julia&gt; bf3 = bf1 * bf2
BasisFunc{Float64, 3, 0, 3}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1237-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{T}, Tuple{GaussFunc{T}, Real}} where T" href="#Quiqbox.mul-Union{Tuple{T}, Tuple{GaussFunc{T}, Real}} where T"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(gf::GaussFunc{T}, coeff::Real; roundAtol::Real=getAtolVal(T)) where {T} -&gt; 
GaussFunc

mul(coeff::Real, gf::GaussFunc{T}; roundAtol::Real=getAtolVal(T)) where {T} -&gt; 
GaussFunc

mul(gf1::GaussFunc{T}, gf2::GaussFunc{T}; roundAtol::Real=getAtolVal(T)) where {T} -&gt; 
GaussFunc</code></pre><p>Multiplication between a <code>Real</code> number and a <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a> or two <code>GaussFunc</code>s.  <code>roundAtol</code> specifies the absolute approximation tolerance of comparing parameters stored  in each <code>GaussFunc</code> to determine whether they are treated as &quot;equal&quot;; each parameter in the  returned <code>GaussFunc</code> is set to the nearest exact multiple of <code>0.5atol</code>. When <code>roundAtol</code> is  set to <code>NaN</code>, there will be no approximation nor rounding. This function can be called  using <code>*</code> syntax with the keyword argument set to it default value. </p><p><strong>NOTE:</strong> For the <code>ParamBox</code> (stored in the input arguments) that are marked as  non-differentiable, they will be fused together if possible to generate new <code>ParamBox</code>(s)  no longer linked to the data (input variable) stored in them.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; gf1 = GaussFunc(3.0, 1.0)
GaussFunc{Float64, iT, iT}(xpn()=3.0, con()=1.0, param)[‚àÇ][‚àÇ]

julia&gt; gf1 * 2
GaussFunc{Float64, iT, iT}(xpn()=3.0, con()=2.0, param)[‚àÇ][‚àÇ]

julia&gt; gf1 * gf1
GaussFunc{Float64, iT, iT}(xpn()=6.0, con()=1.0, param)[‚àÇ][‚àÇ]

julia&gt; gf1 * 2 * gf1
GaussFunc{Float64, iT, iT}(xpn()=6.0, con()=2.0, param)[‚àÇ][‚àÇ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1182-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.normalizeBasis-Tuple{BasisFuncs}" href="#Quiqbox.normalizeBasis-Tuple{BasisFuncs}"><code>Quiqbox.normalizeBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalizeBasis(b::BasisFuncs{T, D}) where {T, D} -&gt; Vector{&lt;:FloatingGTBasisFuncs{T, D}}</code></pre><p>Normalize each <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a> inside <code>b</code> and try to merge them back to one  <a href="../coreType/#Quiqbox.BasisFuncs"><code>BasisFuncs</code></a>. If the all the <code>BasisFunc</code>(s) can be merged, the returned result will  be a 1-element <code>Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L2073-L2080">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.normalizeBasis-Union{Tuple{GTBasisFuncs{T}}, Tuple{T}} where T" href="#Quiqbox.normalizeBasis-Union{Tuple{GTBasisFuncs{T}}, Tuple{T}} where T"><code>Quiqbox.normalizeBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalizeBasis(b::GTBasisFuncs{T, D, 1}) where {T, D} -&gt; GTBasisFuncs{T, D, 1}</code></pre><p>Multiply the contraction coefficient(s) inside <code>b</code> by constant coefficient(s) to  normalizeBasis the <code>b</code>, and then return the normalized basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L2061-L2067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalNumOf" href="#Quiqbox.orbitalNumOf"><code>Quiqbox.orbitalNumOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbitalNumOf(subshell::String, D::Integer=3) -&gt; Int</code></pre><p>Return the size (number of orbitals) of each subshell in <code>D</code> dimensional real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1562-L1567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalNumOf-Union{Tuple{Quiqbox.QuiqboxBasis{&lt;:Any, &lt;:Any, ON}}, Tuple{ON}} where ON" href="#Quiqbox.orbitalNumOf-Union{Tuple{Quiqbox.QuiqboxBasis{&lt;:Any, &lt;:Any, ON}}, Tuple{ON}} where ON"><code>Quiqbox.orbitalNumOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orbitalNumOf(b::QuiqboxBasis) -&gt; Int</code></pre><p>Return the numbers of orbitals of the input basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1571-L1576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.shift-Union{Tuple{F}, Tuple{GN}, Tuple{ùëô}, Tuple{D}, Tuple{FloatingGTBasisFuncs{var&quot;#s58&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s58&quot;, PT}, AbstractArray{Int64}}, Tuple{FloatingGTBasisFuncs{var&quot;#s57&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s57&quot;, PT}, AbstractArray{Int64}, F}} where {D, ùëô, GN, F&lt;:Function}" href="#Quiqbox.shift-Union{Tuple{F}, Tuple{GN}, Tuple{ùëô}, Tuple{D}, Tuple{FloatingGTBasisFuncs{var&quot;#s58&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s58&quot;, PT}, AbstractArray{Int64}}, Tuple{FloatingGTBasisFuncs{var&quot;#s57&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s57&quot;, PT}, AbstractArray{Int64}, F}} where {D, ùëô, GN, F&lt;:Function}"><code>Quiqbox.shift</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(bf::FloatingGTBasisFuncs{T, D, ùëô, GN, PT, 1}, 
      dl::Union{Vector{Int}, NTuple{D, Int}, LTuple{D}}, op::Function=+) where 
     {T, D, ùëô, GN, PT} -&gt; 
BasisFunc{T, D, &lt;:Any, GN, PT}</code></pre><p>Shift (<code>+</code> as the default binary operator <code>op</code>) the angular momentum (in Cartesian  representation) of the input <code>FloatingGTBasisFuncs</code> given <code>dl</code> that specifies the change of  each component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L1477-L1487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(bs::Union{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}, 
                    Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}; 
          roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Vector{&lt;:CompositeGTBasisFuncs{T, D}}</code></pre><p>Sort basis functions. <code>roundAtol</code> specifies the absolute approximation tolerance of  comparing parameters stored in each <code>CompositeGTBasisFuncs</code> to determine whether they are  treated as &quot;equal&quot;; when set to <code>NaN</code>, no approximation will be made during the comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L871-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Union{Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}}}, Tuple{T}} where T" href="#Quiqbox.sortBasis-Union{Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}}}, Tuple{T}} where T"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(b::GTBasis{T, D}; roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
GTBasis{T, D}</code></pre><p>Reconstruct a <a href="../coreType/#Quiqbox.GTBasis"><code>GTBasis</code></a> by sorting the <code>GTBasisFuncs</code> stored in the input one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L911-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Union{Tuple{Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortBasis-Union{Tuple{Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(bs::Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}; 
          roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L900-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}" href="#Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}"><code>Quiqbox.sortBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, 
               groupCenters::Bool=false; roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Vector</code></pre><p>Sort <code>FloatingGTBasisFuncs</code>. If <code>groupCenters = true</code>, Then the function will return an  <code>Vector{&lt;:Vector{&lt;:FloatingGTBasisFuncs}}</code> in which the elements are grouped basis  functions with same center coordinates. <code>roundAtol</code> specifies the absolute approximation  tolerance of comparing the center coordinates to determine whether they are treated as  &quot;equal&quot;; when set to <code>NaN</code>, no approximation will be made during the comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L658-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs-Union{Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}, Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, Bool}} where {T, D}" href="#Quiqbox.sortBasisFuncs-Union{Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}, Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, Bool}} where {T, D}"><code>Quiqbox.sortBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, groupCenters::Bool=false; 
               roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Tuple</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L684-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortPermBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortPermBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortPermBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortPermBasis(bs::AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}; 
              roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Vector{Int}</code></pre><p>Return a <code>Vector</code> of indices <code>I</code> such that <code>bs[I] ==</code><a href="#Quiqbox.sortBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>sortBasis</code></a> <code>(bs; roundAtol)[I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L922-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortPermBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortPermBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortPermBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortPermBasisFuncs(bs::Union{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, 
                             Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}; 
                   roundAtol::Real=getAtolVal(T)) where {T, D} -&gt; 
Vector{Int}</code></pre><p>Return a <code>Vector</code> of indices <code>I</code> such that <code>bs[I] ==</code><a href="#Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}"><code>sortBasisFuncs</code></a> <code>(bs; roundAtol)[I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L696-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.subshellOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.subshellOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.subshellOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subshellOf(::FloatingGTBasisFuncs) -&gt; String</code></pre><p>Return the corresponding subshell of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L649-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.unpackBasis-Union{Tuple{Quiqbox.EmptyBasisFunc{T, D}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.unpackBasis-Union{Tuple{Quiqbox.EmptyBasisFunc{T, D}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.unpackBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unpackBasis(b::GTBasisFuncs{T, D}) -&gt; Vector{&lt;:BasisFunc{T, D}}</code></pre><p>Unpack <code>b</code> to return all the <code>BasisFunc</code> inside it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Basis.jl#L805-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHF-Union{Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Vararg{Any}}} where T" href="#Quiqbox.runHF-Union{Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {D, BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Vararg{Any}}} where T"><code>Quiqbox.runHF</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runHF(bs, nuc, nucCoords, config=HFconfig(), N=getCharge(nuc); printInfo=true) -&gt; 
HFfinalVars

runHF(bs, nuc, nucCoords, N=getCharge(nuc), config=HFconfig(); printInfo=true) -&gt; 
HFfinalVars</code></pre><p>Main function to run a Hartree-Fock method in Quiqbox. The returned result and relevant  information is stored in a <a href="../coreType/#Quiqbox.HFfinalVars"><code>HFfinalVars</code></a>.</p><pre><code class="nohighlight hljs">runHFcore(args...; printInfo=false) -&gt; Tuple{Tuple{Vararg{HFtempVars}}, Bool}</code></pre><p>The core function of <code>runHF</code> that accept the same positional arguments as <code>runHF</code>, except  it returns the data (<code>HFtempVars</code>) collected during the iteration and the boolean result of  whether the SCF procedure is converged.</p><p>‚â°‚â°‚â° Positional argument(s) ‚â°‚â°‚â°</p><p><code>bs::Union{     BasisSetData{T, D},      AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}},      Tuple{Vararg{AbstractGTBasisFuncs{T, D}}} } where {T, D}</code>: The basis set used for the Hartree-Fock approximation.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})} where {T, D, N}</code>: The coordinates of corresponding nuclei.</p><p><code>config::HFconfig</code>: The Configuration of selected Hartree-Fock method. For more information  please refer to <a href="../coreType/#Quiqbox.HFconfig"><code>HFconfig</code></a>.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p>‚â°‚â°‚â° Keyword argument(s) ‚â°‚â°‚â°</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps and result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/HartreeFock.jl#L589-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHFcore-Union{Tuple{T2}, Tuple{HFTS}, Tuple{L}, Tuple{T1}, Tuple{HFT}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64, Bool}} where {HFT, T1, L, HFTS, T2}" href="#Quiqbox.runHFcore-Union{Tuple{T2}, Tuple{HFTS}, Tuple{L}, Tuple{T1}, Tuple{HFT}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64, Bool}} where {HFT, T1, L, HFTS, T2}"><code>Quiqbox.runHFcore</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runHFcore(HTtype, scfConfig, N, Hcore, HeeI, S, X, C0, 
          printInfo=false, maxStep=1000, earlyStop=true) -&gt; 
Tuple{Tuple{Vararg{HFtempVars}}, Bool}</code></pre><p>Another method of <code>runHFcore</code> that has the same return value, but takes more underlying  data as arguments.</p><p>=== Positional argument(s) ===</p><p><code>HTtype::Val{HFT} where HFT</code>: Hartree-Fock method type. Available values of <code>HFT</code> are  :RHF, :UHF.</p><p><code>scfConfig::SCFconfig</code>: The SCF iteration configuration.</p><p><code>N::NTuple{HFTS, Int} where HFTS</code>: The numbers of electrons with same spin configurations. </p><p><code>Hcore::AbstractMatrix{T} where T</code>: The core Hamiltonian of the electronic Hamiltonian.</p><p><code>HeeI::AbstractArray{T, 4} where T</code>: The electron-electron interaction tensor (in the  chemists&#39; notation) which includes both the Coulomb interactions and the Exchange  Correlations.</p><p><code>S::AbstractMatrix{T} where T</code>: The overlap matrix of the used basis set.</p><p><code>X::AbstractMatrix{T} where T</code>: The transformation matrix of <code>S</code>.</p><p><code>C0::NTuple{HFTS, AbstractMatrix{T}} where {HFTS, T}</code>: Initial guess of the coefficient  matrix(s) of the canonical spin-orbitals.</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps and result.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>earlyStop::Bool</code>: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/HartreeFock.jl#L686-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradOfHFenergy-Union{Tuple{NN}, Tuple{HFTS}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, HFTS, NN}" href="#Quiqbox.gradOfHFenergy-Union{Tuple{NN}, Tuple{HFTS}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, HFTS, NN}"><code>Quiqbox.gradOfHFenergy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradOfHFenergy(par, basis, C, nuc, nucCoords, N=getCharge(nuc)) -&gt;
AbstractVector

gradOfHFenergy(par, bs, S, C, nuc, nucCoords, N=getCharge(nuc)) -&gt;
AbstractVector</code></pre><p>Two methods of <code>gradOfHFenergy</code>.</p><p>‚â°‚â°‚â° Positional argument(s) ‚â°‚â°‚â°</p><p><code>par::AbstractVector{&lt;:ParamBox}</code>: The parameters for differentiation.</p><p><code>basis::</code><a href="../coreType/#Quiqbox.GTBasis"><code>GTBasis</code></a><code>{T, D} where {T, D}</code>: Basis set information.</p><p><code>C::NTuple{&lt;:Any, AbstractMatrix{T}} where T</code>: The coefficient matrix(s) of the canonical  orbitals with respect to the selected basis set.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})} where {T, D, N}</code>: The coordinates of corresponding nuclei.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p><code>bs::Union{     NTuple{BN, GTBasisFuncs{T, D, 1}},      AbstractVector{&lt;:GTBasisFuncs{T, D, 1}} } where {T, D}</code>: A collection of basis functions.</p><p><code>S::AbstractMatrix{T} where T</code>: The overlap lap of the basis set when <code>bs</code> is provided as  the second argument.</p><p><strong>NOTE:</strong> If any of these two methods is applied, the user needs to make sure the row  orders as well as the colum orders of <code>C</code> and (or) <code>S</code> are consistent with the element  order of <code>bs</code> (<code>basis.basis</code>). ``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Differentiation.jl#L149-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gridCoordOf-Tuple{GridBox}" href="#Quiqbox.gridCoordOf-Tuple{GridBox}"><code>Quiqbox.gridCoordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridCoordOf(gb::GridBox{T}) where {T} -&gt; Tuple{Vararg{Vector{T}}}</code></pre><p>Return the coordinates of the grid points stored in <code>gb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Box.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NN, M, CBT, F}" href="#Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NN, M, CBT, F}"><code>Quiqbox.optimizeParams!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeParams!(pbs, bs, nuc, nucCoords, 
                config=POconfig(), N=getCharge(nuc); printInfo=true) -&gt; 
Tuple{Union{Vector{T}, Vector{&lt;:Array{T}}}, 
      Vector{T}, 
      Vector{&lt;:Array{T}}, 
      Union{Bool, Missing}} where {T}

optimizeParams!(pbs, bs, nuc, nucCoords, 
                N=getCharge(nuc), config=POconfig(); printInfo=true) -&gt; 
Tuple{Union{Vector{T}, Vector{&lt;:Array{T}}}, 
      Vector{T}, 
      Vector{&lt;:Array{T}}, 
      Union{Bool, Missing}} where {T}</code></pre><p>The main function to optimize the parameters of a given basis set. It returns a <code>Tuple</code> of  relevant information. The first three elements are the energies, the parameter values, and  the gradients from all the iteration steps respectively. The last element is the indicator  of whether the optimization is converged if the convergence detection is on (i.e.,  <code>config.threshold</code> is not <code>NaN</code>), or else it&#39;s set to <code>missing</code>.</p><p>=== Positional argument(s) ===</p><p><code>pbs::AbstractVector{&lt;:ParamBox{T}}</code>: The parameters to be optimized that are extracted  from the basis set. If the parameter is marked as &quot;differentiable&quot;, the value of its input  variable will be optimized.</p><p><code>bs::AbstractVector{&lt;:GTBasisFuncs{T, D}}</code>: The basis set to be optimized.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})} where {T, D, N}</code>: The coordinates of corresponding nuclei.</p><p><code>config::POconfig</code>: The Configuration of selected parameter optimization method. For more  information please refer to <a href="../coreType/#Quiqbox.POconfig"><code>POconfig</code></a>.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p>=== Keyword argument(s) ===</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Optimization.jl#L314-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Tuple{Quiqbox.HFfinalVars}" href="#Quiqbox.changeHbasis-Tuple{Quiqbox.HFfinalVars}"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(HFres::HFfinalVars) -&gt; NTuple{2, Any}</code></pre><p>Return the one-body and two-body integrals on the basis of the canonical orbitals  using the result of a Hartree-Fock method <code>HFres</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{String, NN}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractMatrix{T}}} where {T, D, NN}" href="#Quiqbox.changeHbasis-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{String, NN}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractMatrix{T}}} where {T, D, NN}"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(b::GTBasis{T, D}, 
             nuc::NTuple{NN, String}, nucCoords::NTuple{NN, NTuple{D, T}}, 
             C::Union{AbstractMatrix{T}, NTuple{2, AbstractMatrix{T}}}) where 
            {T, D, NN} -&gt; 
NTuple{2, Any}</code></pre><p>Return the one-body and two-body integrals after a change of basis based on the input <code>C</code>,  given the basis set information <code>b</code>. The type of each element in the returned <code>Tuple</code> is  consistent with the cases where the first argument of <code>changeHbasis</code> is an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L129-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Vararg{AbstractMatrix{T}, 2}}} where T" href="#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Vararg{AbstractMatrix{T}, 2}}} where T"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(twoBodyInt::AbstractArray{T, 4}, 
             C1::AbstractMatrix{T}, C2::AbstractMatrix{T}) where {T} -&gt; 
AbstractArray{T, 4}</code></pre><p>Change the basis of the input two-body integrals <code>twoBodyInt</code> based on two orbital  coefficient matrices <code>C1</code> and <code>C2</code> for different spin configurations (e.g., the  unrestricted case). The output is a 3-element <code>Tuple</code> of which the first 2 elements are the  spatial integrals of each spin configurations respectively, while the last element is the  Coulomb interactions between orbitals with different spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L114-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(DbodyInt::AbstractArray{T, D}, C::AbstractMatrix{T}) where {T} -&gt; 
AbstractArray{T, D}</code></pre><p>Change the basis of the input one-body / two-body integrals <code>DbodyInt</code> based on the orbital  coefficient matrix <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genCanOrbitals-Union{Tuple{Quiqbox.HFfinalVars{T}}, Tuple{T}} where T" href="#Quiqbox.genCanOrbitals-Union{Tuple{Quiqbox.HFfinalVars{T}}, Tuple{T}} where T"><code>Quiqbox.genCanOrbitals</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genCanOrbitals(fVars::HFfinalVars{T, D, &lt;:Any, NN}; 
               roundAtol::Real=getAtolVal(T)) where {T, D, NN} -&gt; 
NTuple{2, Vector{CanOrbital{T, D, NN}}}</code></pre><p>Generate the occupied and unoccupied canonical orbitals from the result of a Hartree-Fock  approximation <code>fVars</code>. Each parameter stored in the constructed <a href="../coreType/#Quiqbox.CanOrbital"><code>CanOrbital</code></a> will  be rounded to the nearest multiple of <code>roundAtol</code>; when <code>roundAtol</code> is set to <code>NaN</code>, no  rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nnRepulsions-Union{Tuple{T}, Tuple{NN}, Tuple{Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, var&quot;#s296&quot;}}, 1}, Tuple{Vararg{Tuple{Vararg{T, var&quot;#s296&quot;}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})} where var&quot;#s296&quot;}} where {NN, T}" href="#Quiqbox.nnRepulsions-Union{Tuple{T}, Tuple{NN}, Tuple{Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, var&quot;#s296&quot;}}, 1}, Tuple{Vararg{Tuple{Vararg{T, var&quot;#s296&quot;}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})} where var&quot;#s296&quot;}} where {NN, T}"><code>Quiqbox.nnRepulsions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nnRepulsions(nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}) where {NN, D, T} -&gt; 
T</code></pre><p>Return the nuclear repulsion energy given nuclei <code>nuc</code> and their coordinates <code>nucCoords</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Matter.jl#L260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreH-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}" href="#Quiqbox.coreH-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}"><code>Quiqbox.coreH</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coreH(bs::Union{GTBasis, Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, 
      nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
      nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}) where {T, D, NN} -&gt; 
Matrix{T}</code></pre><p>Return the core Hamiltonian given a basis set and the corresponding nuclei with their  coordinates (in atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L104-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreHij-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}" href="#Quiqbox.coreHij-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}"><code>Quiqbox.coreHij</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coreHij(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, 
        nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
        nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}) where {T, D, NN} -&gt; 
T</code></pre><p>Return a matrix element of the core Hamiltonian given two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eKinetic-Union{Tuple{T}, Tuple{D}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {D, T}" href="#Quiqbox.eKinetic-Union{Tuple{T}, Tuple{D}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {D, T}"><code>Quiqbox.eKinetic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eKinetic(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where 
        {T, D} -&gt; 
T</code></pre><p>Return the electron kinetic energy between two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eKinetics-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.eKinetics-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.eKinetics</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eKinetics(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                    AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) where {T, D} -&gt; 
Matrix{T}</code></pre><p>Return the electron kinetic energy matrix given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.neAttraction-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}" href="#Quiqbox.neAttraction-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}"><code>Quiqbox.neAttraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neAttraction(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, 
             nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}) where {T, D, NN} -&gt; 
T</code></pre><p>Return the nuclear attraction between two basis functions, provided with the nuclei and  their coordinates (in the atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.neAttractions-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}" href="#Quiqbox.neAttractions-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N, Union{Tuple{Vararg{String, NN}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, NN}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}}} where {T, D, NN}"><code>Quiqbox.neAttractions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neAttractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                        AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, 
              nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
              nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{Tuple{Vararg{T, D}}, N}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{Vararg{var&quot;#s43&quot;, N}} where var&quot;#s43&quot;&lt;:(AbstractVector{&lt;:T})}) where {T, D, NN} -&gt; 
Matrix{T}</code></pre><p>Return the nuclear attraction matrix given a basis set and the corresponding nuclei with  their coordinates (in atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlap-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}" href="#Quiqbox.overlap-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}"><code>Quiqbox.overlap</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where 
       {T, D, 1} -&gt; 
T</code></pre><p>Return the orbital overlap between two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlaps-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.overlaps-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.overlaps</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                   AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) where {T, D} -&gt; 
Matrix{T}</code></pre><p>Return the orbital overlap matrix given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/OneBody.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteraction-Union{Tuple{D}, Tuple{T}, NTuple{4, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}" href="#Quiqbox.eeInteraction-Union{Tuple{D}, Tuple{T}, NTuple{4, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}"><code>Quiqbox.eeInteraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeInteraction(bf1::AbstractGTBasisFuncs{T, D, 1}, 
              bf2::AbstractGTBasisFuncs{T, D, 1}, 
              bf3::AbstractGTBasisFuncs{T, D, 1}, 
              bf4::AbstractGTBasisFuncs{T, D, 1}) where {T, D} -&gt; 
T</code></pre><p>Return an electron-electron interaction tensor element given four basis functions (ordered  in the chemists&#39; notation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/TwoBody.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractions-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.eeInteractions-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}, N}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}} where N}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.eeInteractions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeInteractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                         AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) -&gt; 
Array{T, 4}</code></pre><p>Return the tensor of electron-electron interactions (in the chemists&#39; notation) given a  basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/TwoBody.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeIuniqueIndicesOf-Tuple{Int64}" href="#Quiqbox.eeIuniqueIndicesOf-Tuple{Int64}"><code>Quiqbox.eeIuniqueIndicesOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeIuniqueIndicesOf(basisSetSize::Int) -&gt; Vector{Vector{Int}}</code></pre><p>Return the unique matrix element indices (in the chemists&#39; notation) of electron-electron  interactions given the size of a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/35529a741ecc01aa2b7f640e40599c88d2a7e2d8/src/Integrals/Core.jl#L1131-L1137">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">¬´ Parameter Optimization</a><a class="docs-footer-nextpage" href="../coreType/">Core Types ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 1 October 2022 02:44">Saturday 1 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
