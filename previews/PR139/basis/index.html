<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basis Sets · Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Basis Sets</a><ul class="internal"><li><a class="tocitem" href="#Basis-set-construction"><span>Basis set construction</span></a></li><li><a class="tocitem" href="#Dependent-variable-as-a-parameter"><span>Dependent variable as a parameter</span></a></li><li><a class="tocitem" href="#Linear-combinations-of-basis-functions"><span>Linear combinations of basis functions</span></a></li></ul></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../coreFunction/">Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Basis Sets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basis Sets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/main/docs/src/basis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basis-Sets"><a class="docs-heading-anchor" href="#Basis-Sets">Basis Sets</a><a id="Basis-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Sets" title="Permalink"></a></h1><p>The procedure of constructing a Gaussian-type basis set can fundamentally break down into several basic steps: first, make primitive Gaussian-type orbitals (GTO) using a set of parameters, then construct the basis functions from the linear combinations of those orbitals, finally build the basis set.</p><p>The data structures defined by Quiqbox in each step, form levels of data complexity. They can be summarized in the following table.</p><table><tr><th style="text-align: center">level</th><th style="text-align: center">objective</th><th style="text-align: center">container type</th><th style="text-align: center">type examples</th></tr><tr><td style="text-align: center">4</td><td style="text-align: center">basis set</td><td style="text-align: center"><code>Array</code>, <code>Tuple</code>, <code>GTBasis</code></td><td style="text-align: center"><code>Vector{&lt;:BasisFunc{Float64, 3}}</code>, <code>GTBasis{Float64, 3, 2}</code>...</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">basis function</td><td style="text-align: center"><code>GTBasisFuncs</code></td><td style="text-align: center"><code>BasisFunc{Float64, 3, 0, 6}</code>, <code>Quiqbox.BasisFuncMix{Float64, 3, 2}</code>...</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">Gaussian-type function</td><td style="text-align: center"><code>AbstractGaussFunc</code></td><td style="text-align: center"><code>GaussFunc{Float64, iT, iT}</code>...</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">tunable parameter</td><td style="text-align: center"><code>ParamBox</code>, <code>SpatialPoint</code></td><td style="text-align: center"><code>ParamBox{Float64, :α, iT}</code>, <code>SpatialPoint{Float64, 3, P3D{Float64, iT, iT, iT}}</code>...</td></tr></table><p>Depending on how much control the user wants to have over each step, Quiqbox defines several <a href="https://docs.julialang.org/en/v1/manual/methods/">methods</a> of related functions to provide the freedom of balancing between efficiency and customizability.</p><p>Below are some examples from the simplest way to more flexible ways of constructing a basis set in Quiqbox. Hopefully, these use cases can also work as inspirations for more creative ways to customize basis sets.</p><h2 id="Basis-set-construction"><a class="docs-heading-anchor" href="#Basis-set-construction">Basis set construction</a><a id="Basis-set-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-set-construction" title="Permalink"></a></h2><h3 id="Constructing-basis-sets-from-existing-basis-sets"><a class="docs-heading-anchor" href="#Constructing-basis-sets-from-existing-basis-sets">Constructing basis sets from existing basis sets</a><a id="Constructing-basis-sets-from-existing-basis-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-from-existing-basis-sets" title="Permalink"></a></h3><p>First, you can construct an atomic basis set at one coordinate by inputting its center coordinate, the basis set name and the corresponding atom symbol.</p><pre><code class="language-julia-repl hljs">julia&gt; bsO = Quiqbox.genBasisFunc(fill(1.0, 3), &quot;STO-3G&quot;, &quot;O&quot;);

julia&gt; bsO[begin]
BasisFunc{Float64, 3, 0, 3}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]

julia&gt; bsO[end]
BasisFuncs{Float64, 3, 1, 3, P3D{Float64, iT, iT, iT}, 3}(center, gauss, l, normalizeGTO, param)[3/3][1.0, 1.0, 1.0]</code></pre><p>Notice that in the returned <code>bsO</code> there are two types of elements: <code>BasisFunc</code> and <code>BasisFuncs</code>. <code>BasisFunc</code> is the most basic <code>DataType</code> to hold the data of a basis function; <code>BasisFuncs</code> is very similar except it may hold multiple orbitals with only the spherical harmonics <span>$Y_{ml}$</span> being different when the orbital angular momentum <span>$l&gt;0$</span>.</p><div class="admonition is-info"><header class="admonition-header">Unit system</header><div class="admonition-body"><p>Hartree atomic units are the unit system used in Quiqbox.</p></div></div><p>If you want to postpone the specification of the center, you can replace the first argument with <code>missing</code>, then use the function <code>assignCenInVal!</code> to assign the coordinates later.</p><pre><code class="language-julia-repl hljs">julia&gt; bsO = genBasisFunc(missing, &quot;STO-3G&quot;, &quot;O&quot;);

julia&gt; [assignCenInVal!(b, fill(1.0, 3)) for b in bsO]
3-element Vector{SpatialPoint{Float64, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:
 SpatialPoint{Float64, 3}{PBFL{(0, 0, 0)}}(param, marker)[1.0, 1.0, 1.0][∂][∂][∂]
 SpatialPoint{Float64, 3}{PBFL{(0, 0, 0)}}(param, marker)[1.0, 1.0, 1.0][∂][∂][∂]
 SpatialPoint{Float64, 3}{PBFL{(0, 0, 0)}}(param, marker)[1.0, 1.0, 1.0][∂][∂][∂]</code></pre><p>If you omit the atom in the arguments, <code>&quot;H&quot;</code> will be set in default. Notice that even though there&#39;s only one single basis function in H&#39;s STO-3G basis set, the returned value is still a <code>Vector</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; bsH_1 = genBasisFunc([-0.5, 0, 0], &quot;STO-3G&quot;)
1-element Vector{BasisFunc{Float64, 3, 0, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:
 BasisFunc{Float64, 3, 0, 3}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][-0.5, 0.0, 0.0]

julia&gt; bsH_2 = genBasisFunc([ 0.5, 0, 0], &quot;STO-3G&quot;)
1-element Vector{BasisFunc{Float64, 3, 0, 3, Tuple{ParamBox{Float64, :X, typeof(itself)}, ParamBox{Float64, :Y, typeof(itself)}, ParamBox{Float64, :Z, typeof(itself)}}}}:
 BasisFunc{Float64, 3, 0, 3}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][0.5, 0.0, 0.0]</code></pre><p>Finally, you can use Quiqbox&#39;s included tool function <a href="../toolFunction/#Quiqbox.flatten-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>flatten</code></a> to merge the three atomic basis sets into one molecular basis set:</p><pre><code class="language-julia-repl hljs">julia&gt; bsH2O = [bsO, bsH_1, bsH_2] |&gt; flatten;</code></pre><p>Not simple enough? Here&#39;s a more compact way of realizing the above steps if you are familiar with Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#man-dot-operators">vectorization syntactic sugars</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; cens = [fill(1.0,3), [-0.5,0,0], [0.5,0,0]];

julia&gt; bsH2O_2 = genBasisFunc.(cens, &quot;STO-3G&quot;, [&quot;O&quot;, &quot;H&quot;, &quot;H&quot;]) |&gt; flatten;</code></pre><p>In quiqbox, the user can often deal with several multi-layer containers (mainly <code>struct</code>s). It might be easy to get lost or unsure about whether the objects are created as intended. Quiqbox provides another tool function <a href="../toolFunction/#Quiqbox.hasEqual-Tuple{Any, Any, Vararg{Any}}"><code>hasEqual</code></a> that lets you verify if two objects hold the same-valued data and have the same structure. For example, if we want to see whether <code>bsH2O_2</code> created in the faster way is the same (not necessarily identical) as <code>bsH2O</code>, we can do as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; hasEqual(bsH2O, bsH2O_2)
true</code></pre><p>If the basis set you want to use is not pre-stored in Quiqbox, you can use <a href="../coreFunction/#Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T&lt;:AbstractFloat}"><code>genBFuncsFromText</code></a> to generate the basis set from a <strong>Gaussian</strong> format <code>String</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; genBasisFunc(missing, &quot;6-31G&quot;, &quot;Kr&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: KeyError: key &quot;Kr&quot; not found</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # Data from https://www.basissetexchange.org
       txt_Kr_631G = &quot;&quot;&quot;
       Kr     0
       S    6   1.00
             0.1205524000D+06       0.1714050000D-02
             0.1810225000D+05       0.1313805000D-01
             0.4124126000D+04       0.6490006000D-01
             0.1163472000D+04       0.2265185000D+00
             0.3734612000D+03       0.4764961000D+00
             0.1280897000D+03       0.3591952000D+00
       SP   6   1.00
             0.2634681000D+04       0.2225111000D-02       0.3761911000D-02
             0.6284533000D+03       0.2971122000D-01       0.2977531000D-01
             0.2047081000D+03       0.1253926000D+00       0.1311878000D+00
             0.7790827000D+02       0.1947058000D-02       0.3425019000D+00
             0.3213816000D+02      -0.5987388000D+00       0.4644938000D+00
             0.1341845000D+02      -0.4958972000D+00       0.2087284000D+00
       SP   6   1.00
             0.1175107000D+03      -0.6157662000D-02      -0.6922855000D-02
             0.4152553000D+02       0.5464841000D-01      -0.3069239000D-01
             0.1765290000D+02       0.2706994000D+00       0.4480260000D-01
             0.7818313000D+01      -0.1426136000D+00       0.3636775000D+00
             0.3571775000D+01      -0.7216781000D+00       0.4952412000D+00
             0.1623750000D+01      -0.3412008000D+00       0.2086340000D+00
       SP   3   1.00
             0.2374560000D+01       0.3251184000D+00      -0.3009554000D-01
             0.8691930000D+00      -0.2141533000D+00       0.3598893000D+00
             0.3474730000D+00      -0.9755083000D+00       0.7103098000D+00
       SP   1   1.00
             0.1264790000D+00       0.1000000000D+01       0.1000000000D+01
       D    3   1.00
             0.6853888000D+02       0.7530705000D-01
             0.1914333000D+02       0.3673551000D+00
             0.6251213000D+01       0.7120146000D+00
       D    1   1.00
             0.1979236000D+01       1.0000000
       &quot;&quot;&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; genBFuncsFromText(txt_Kr_631G, adjustContent=true);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="Constructing-basis-sets-from-GaussFunc"><a class="docs-heading-anchor" href="#Constructing-basis-sets-from-GaussFunc">Constructing basis sets from <code>GaussFunc</code></a><a id="Constructing-basis-sets-from-GaussFunc-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-from-GaussFunc" title="Permalink"></a></h3><p>If you want to specify the parameters of each basis function when constructing a basis set, you can first construct the container for primitive GTO: <code>GaussFunc</code>, and then construct the basis function from them:</p><pre><code class="language-julia-repl hljs">julia&gt; gf1 = GaussFunc(2.0, 1.0)
GaussFunc{Float64, iT, iT}(xpn()=2.0, con()=1.0, param)[∂][∂]

julia&gt; gf2 = GaussFunc(2.5, 0.75)
GaussFunc{Float64, iT, iT}(xpn()=2.5, con()=0.75, param)[∂][∂]

julia&gt; bf1 = genBasisFunc([1.0, 0, 0], [gf1, gf2])
BasisFunc{Float64, 3, 0, 2}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 0.0, 0.0]</code></pre><p>Unlike <code>BasisFunc</code>, there&#39;s no additional constructor function for <code>GaussFunc</code>. As for the method of <code>genBasisFunc</code> in this case, the subshell is set to &quot;s&quot; as the default option since the third argument is omitted. You can construct a <code>BasisFuncs</code> which contains all the orbitals within one specified subshell:</p><pre><code class="language-julia-repl hljs">julia&gt; bf2 = genBasisFunc([1.0, 0, 0], [gf1, gf2], &quot;p&quot;)
BasisFuncs{Float64, 3, 1, 2, P3D{Float64, iT, iT, iT}, 3}(center, gauss, l, normalizeGTO, param)[3/3][1.0, 0.0, 0.0]</code></pre><p>You can even select one or few orbitals to keep by specifying the corresponding orbital angular momentums in the Cartesian representation using <code>NTuple{3, Int}</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; bf3 = genBasisFunc([1.0, 0, 0], [gf1, gf2], (1,0,0))
BasisFunc{Float64, 3, 1, 2}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X¹Y⁰Z⁰][1.0, 0.0, 0.0]

julia&gt; bf4 = genBasisFunc([1.0, 0, 0], [gf1, gf2], [(1,0,0), (0,0,1)])
BasisFuncs{Float64, 3, 1, 2, P3D{Float64, iT, iT, iT}, 2}(center, gauss, l, normalizeGTO, param)[2/3][1.0, 0.0, 0.0]</code></pre><p>Again, if you want a faster solution, you can directly define the exponent coefficients and the contraction coefficients separately in a 2-element <code>Tuple</code> as the second argument of <code>genBasisFunc</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; bf5 = genBasisFunc([1.0, 0, 0], ([2.0, 2.5], [1.0, 0.75]), [(1,0,0), (0,0,1)]);

julia&gt; hasEqual(bf4, bf5)
true</code></pre><h3 id="Constructing-basis-sets-based-on-ParamBox"><a class="docs-heading-anchor" href="#Constructing-basis-sets-based-on-ParamBox">Constructing basis sets based on <code>ParamBox</code></a><a id="Constructing-basis-sets-based-on-ParamBox-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-basis-sets-based-on-ParamBox" title="Permalink"></a></h3><p>Sometimes you may want the parameters of basis functions (or <code>GaussFunc</code>) to be under some constraints (which can be crucial for the later basis set optimization), this is when you need a deeper level of control over the parameters, through its direct container: <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>. In fact, in the above example, we have already had a glimpse of it through the printed info in the REPL:</p><pre><code class="language-julia-repl hljs">julia&gt; gf1
GaussFunc{Float64, iT, iT}(xpn()=2.0, con()=1.0, param)[∂][∂]</code></pre><p>The two fields of a <code>GaussFunc</code>, <code>.xpn</code>, and <code>.con</code> are <code>ParamBox</code>, and their input value (i.e. the value of the input variable) can be accessed through syntax <code>[]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; gf1.xpn
ParamBox{Float64, :α, iT}(2.0)[∂][α]

julia&gt; gf1.con
ParamBox{Float64, :d, iT}(1.0)[∂][d]

julia&gt; gf1.xpn[]
2.0

julia&gt; gf1.con[]
1.0</code></pre><p>Since the data are not directly stored in primitive types but rather inside <code>ParamBox</code>, this allows the shallow copy of a <code>ParamBox</code> to share the same underlying data: </p><pre><code class="language-julia-repl hljs">julia&gt; gf3 = GaussFunc(1.1, 1.0);

julia&gt; gf3_2 = gf3; # Direct assignment

julia&gt; bf6 = genBasisFunc([1.0, 0, 0], fill(gf3, 2)); # Shallow copy is performed when using `fill`

julia&gt; bf6.gauss[1].xpn[] *= 2;

julia&gt; gf3_2.xpn[] == gf3.xpn[] == bf6.gauss[2].xpn[] == 2.2
true</code></pre><p>Based on such feature of <code>ParamBox</code>, the user can, for instance, create a basis set that enforces all the <code>GaussFunc</code>s to have <strong>identical</strong> gaussian function parameters:</p><pre><code class="language-julia-repl hljs">julia&gt; gf4 = GaussFunc(2.5, 0.5);

julia&gt; bs7 = genBasisFunc.([[0.0, 0.1, 0.0], [1.4, 0.3, 0.0]], Ref(gf4));

julia&gt; markParams!(bs7)
10-element Vector{ParamBox{Float64, V, typeof(itself)} where V}:
 ParamBox{Float64, :X, iT}(0.0)[∂][X₁]
 ParamBox{Float64, :Y, iT}(0.1)[∂][Y₁]
 ParamBox{Float64, :Z, iT}(0.0)[∂][Z₁]
 ParamBox{Float64, :α, iT}(2.5)[∂][α₁]
 ParamBox{Float64, :d, iT}(0.5)[∂][d₁]
 ParamBox{Float64, :X, iT}(1.4)[∂][X₂]
 ParamBox{Float64, :Y, iT}(0.3)[∂][Y₂]
 ParamBox{Float64, :Z, iT}(0.0)[∂][Z₂]
 ParamBox{Float64, :α, iT}(2.5)[∂][α₁]
 ParamBox{Float64, :d, iT}(0.5)[∂][d₁]</code></pre><p><code>markParams!</code> marks all the parameters of a given basis set. Even though <code>bs7</code> has two <code>GaussFunc</code>s as basis functions, overall it only has one unique coefficient exponent <span>$\alpha_1$</span> and one unique contraction coefficient <span>$d_1$</span> besides the center coordinates.</p><h2 id="Dependent-variable-as-a-parameter"><a class="docs-heading-anchor" href="#Dependent-variable-as-a-parameter">Dependent variable as a parameter</a><a id="Dependent-variable-as-a-parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Dependent-variable-as-a-parameter" title="Permalink"></a></h2><p>Another control the user have on the parameters in Quiqbox is through a <code>ParamBox</code> represent a variable equal to the returned value of a mapping function taking the data value stored in the <code>ParamBox</code> as the input argument. In other words, the data stored in the <code>ParamBox</code> is an &quot;input variable&quot;, while the represented variable is an &quot;output variable&quot;.</p><p>Such a mapping function is stored in the <code>map</code> field of the <code>ParamBox</code> (which normally is an <span>$R \to R$</span> mapping). The &quot;output value&quot; can be accessed through syntax <code>()</code>. In default, the input variable is mapped to an output variable that has the identical value:</p><pre><code class="language-julia-repl hljs">julia&gt; pb1 = gf4.xpn
ParamBox{Float64, :α, iT}(2.5)[∂][α₁]

julia&gt; pb1.map
itself (generic function with 1 method)

julia&gt; pb1[] === pb1()
true</code></pre><div class="admonition is-info"><header class="admonition-header">Parameter represented by `ParamBox`</header><div class="admonition-body"><p>The output variable of a <code>ParamBox</code> is always used in the construction of any basis function component. To optimize the input variable stored in an arbitrary <code>ParamBox</code> <code>pb</code>, <code>pb</code> needs to be marked as &quot;differentiable&quot; (i.e., <code>isDiffParam(pb)==true</code>). For more information on parameter optimization, please see the docstring of <a href="../coreFunction/#Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NNMO}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL&lt;:(AbstractVector{&lt;:T})}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, AbstractVector{&lt;:GTBasisFuncs{T, D}}, Union{Tuple{String, Vararg{String, NNMO}}, AbstractVector{&lt;:String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Tuple{Vararg{T, D}}, Vararg{Tuple{Vararg{T, D}}, NNMO}}, AbstractVector{&lt;:AbstractVector{&lt;:T}}, Tuple{TL, Vararg{TL, NNMO}} where TL&lt;:(AbstractVector{&lt;:T})}, POconfig{&lt;:Any, M, CBT, &lt;:Any, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NNMO, M, CBT, F}"><code>optimizeParams!</code></a> and section <a href="../optimization/#Parameter-Optimization">Parameter Optimization</a>.</p></div></div><h2 id="Linear-combinations-of-basis-functions"><a class="docs-heading-anchor" href="#Linear-combinations-of-basis-functions">Linear combinations of basis functions</a><a id="Linear-combinations-of-basis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-combinations-of-basis-functions" title="Permalink"></a></h2><p>Apart from the flexible control of basis function parameters, another major feature of Quiqbox is the ability to construct a basis function from the linear combination of other basis functions. Specifically, additional methods of <code>+</code> and <code>*</code> (operator syntax for <a href="../coreFunction/#Quiqbox.add-Tuple{BasisFuncs{T, D, 𝑙, GN, PT, 1} where {T, D, 𝑙, GN, PT}}"><code>add</code></a> and <a href="../coreFunction/#Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{𝑙2}, Tuple{𝑙1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, 𝑙1, 1, PT1}, BasisFunc{T, D, 𝑙2, 1, PT2}}} where {T, D, 𝑙1, 𝑙2, PT1, PT2}"><code>mul</code></a>) are implemented for <code>CompositeGTBasisFuncs</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; bf7 = genBasisFunc([1.0, 0.0, 1.0], (1.5, 3.0))
BasisFunc{Float64, 3, 0, 1}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 0.0, 1.0]

julia&gt; bf8 = genBasisFunc([1.0, 0.0, 1.0], (2.0, 4.0))
BasisFunc{Float64, 3, 0, 1}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 0.0, 1.0]

julia&gt; bf9 = bf7*0.5 + bf8
BasisFunc{Float64, 3, 0, 2}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 0.0, 1.0]

julia&gt; bf9.gauss[1].con() == 3 * 0.5
true</code></pre><p>As we can see, the type of <code>bf9</code> is still <code>BasisFunc</code>, hence all the GTO inside <code>bf9</code> have the same center coordinates as well. This is because <code>bf7</code> and <code>bf8</code> have the same center coordinates. What if the combined basis functions are multi-center?</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf10 = genBasisFunc(fill(1.0, 3), (1.2, 3.0))</code><code class="nohighlight hljs ansi" style="display:block;">BasisFunc{Float64, 3, 0, 1}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X⁰Y⁰Z⁰][1.0, 1.0, 1.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf11 = bf8 + bf10</code><code class="nohighlight hljs ansi" style="display:block;">Quiqbox.BasisFuncMix{Float64, 3, 2, BasisFunc{Float64, 3, 0, 1}{PBFL{(0, 0, 0)}}}(BasisFunc, param)</code></pre><p>The type of <code>bf11</code> is called <a href="../coreType/#Quiqbox.BasisFuncMix"><code>Quiqbox.BasisFuncMix</code></a>, which means it cannot be expressed as a single contracted Gaussian-type orbital (CGTO) as it is a <strong>mixed-contracted</strong> GTO (MCGTO).</p><p>There are other cases that can result in a <code>BasisFuncMix</code> as the returned object. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf12 = genBasisFunc(fill(1.0, 3), (1.2, 3.0), (1,1,0))</code><code class="nohighlight hljs ansi" style="display:block;">BasisFunc{Float64, 3, 2, 1}{PBFL{(0, 0, 0)}}(center, gauss, l, normalizeGTO, param)[X¹Y¹Z⁰][1.0, 1.0, 1.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bf10 + bf12</code><code class="nohighlight hljs ansi" style="display:block;">Quiqbox.BasisFuncMix{Float64, 3, 2, BasisFunc{Float64, 3, 𝑙, 1}{PBFL{(0, 0, 0)}} where 𝑙}(BasisFunc, param)</code></pre><p>In Quiqbox, <code>BasisFuncMix</code> is also accepted as a valid basis function and the user can use it to call functions that accept <code>CompositeGTBasisFuncs</code> as input argument(s):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; overlap(bf11, bf11)</code><code class="nohighlight hljs ansi" style="display:block;">35.643266036037474</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../SCF/">Self-Consistent Field Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 March 2023 22:20">Thursday 16 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
