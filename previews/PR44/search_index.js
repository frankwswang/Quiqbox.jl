var documenterSearchIndex = {"docs":
[{"location":"basis/#Basis-Sets","page":"Basis Sets","title":"Basis Sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The procedure to construct a basis set can be fundamentally broken down into several basic steps: first, choose a set of (tunable) parameters, and build the Gaussian functions around those parameters, then the basis functions around the Gaussian functions, finally the basis set.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"The data structure formularized by Quiqbox in each step, namely the level of data complexity, can be summarized in the following table.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"level objective product examples abstract type type instances\n4 basis set Array of basis functions (with reusable integrals) Array, GTBasis Array{<:BasisFunc, 1}...\n3 basis functions single or linear combination of Gaussian functions CompositeGTBasisFuncs BasisFunc{0, 1}, BasisFuncs{1, 3, 3}...\n2 Gaussian functions (primitive) Gaussian functions AbstractGaussFunc GaussFunc\n1 a pool of parameters center coordinates, function coefficients ParamBox ParamBox{Float64, :Œ±, :itself}...","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Depending on how much control the user wants to have over each step, Quiqbox provides several methods of related functions to leave the user with the freedom to balance between efficiency and customizability.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Below are some examples from the simplest way to relatively more flexible ways to construct a basis set in Quiqbox. Hopefully these use cases can also work as inspirations for more creative ways to manipulate basis sets.","category":"page"},{"location":"basis/#Basis-Set-Construction","page":"Basis Sets","title":"Basis Set Construction","text":"","category":"section"},{"location":"basis/#Constructing-basis-sets-from-existed-basis-sets","page":"Basis Sets","title":"Constructing basis sets from existed basis sets","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"First, you can create a basis set at one coordinate by input the Vector of its center coordinate and a Tuple of its name and corresponding atom in String.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nbsO = Quiqbox.genBasisFunc([0,0,0], (\"STO-3G\", \"O\"))","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Notice that in the above result there are 2 types of structs in the returned Vector: BasisFunc and BasisFuncs. BasisFunc is the most basic type to hold the data of a basis function; BasisFuncs is very similar except it may hold multiple orbitals with only the spherical harmonics Y_ml being different when the orbital angular momentum l0.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"info: Unit System\nHartree atomic units are the unit system used in Quiqbox.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to postpone the specification of the center, you can replace the 1st argument with missing, and then use function assignCenter! to assign the coordinates later.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsO = genBasisFunc(missing, (\"STO-3G\", \"O\"))\n\nassignCenter!([0,0,0], bsO[1]);\n\nbsO\n\nassignCenter!.(Ref([0,0,0]), bsO[2:end])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you omit the atom in the arguments, H will be set in default. Notice that even there's only 1 single basis function in H's STO-3G basis set, the returned value is still in Array type.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsH_1 = genBasisFunc([-0.5, 0, 0], \"STO-3G\")\n\nbsH_2 = genBasisFunc([ 0.5, 0, 0], \"STO-3G\")","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Finally, you can use Quiqbox's included tool function flatten to merge the three atomic basis set into one molecular basis set:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bsH20 = [bsO, bsH_1, bsH_2] |> flatten","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Not simple enough? Here's a more compact way of realizing the above steps if you are familiar with some syntactic sugars in Julia:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"cens = [[0,0,0], [-0.5,0,0], [0.5,0,0]]\n\nbsH20_2 = genBasisFunc.(cens, [(\"STO-3G\", \"O\"), fill(\"STO-3G\", 2)...]) |> flatten","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"In quiqbox, the user can often deal with several multi-layer containers (mainly structs), it might be easy to get lost or uncertain that whether we are creating the objects intended. Quiqbox provides another tool function hasEqual that lets you compare if two objects hold the same data and structure. For example, if we want to see whether bsH20_2 created in the faster way is same (not identical) as bsH20, we can verify it as follows:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"hasEqual(bsH20, bsH20_2)","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If the basis set you want to use doesn't exist in Quiqbox's library, you can use Function genBFuncsFromText to generate the basis set from a Gaussian formatted String:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"genBasisFunc(missing, (\"6-31G\", \"Kr\"))\n\n# Data from https://www.basissetexchange.org\ntxt_Kr_631G = \"\"\"\nKr     0\nS    6   1.00\n      0.1205524000D+06       0.1714050000D-02\n      0.1810225000D+05       0.1313805000D-01\n      0.4124126000D+04       0.6490006000D-01\n      0.1163472000D+04       0.2265185000D+00\n      0.3734612000D+03       0.4764961000D+00\n      0.1280897000D+03       0.3591952000D+00\nSP   6   1.00\n      0.2634681000D+04       0.2225111000D-02       0.3761911000D-02\n      0.6284533000D+03       0.2971122000D-01       0.2977531000D-01\n      0.2047081000D+03       0.1253926000D+00       0.1311878000D+00\n      0.7790827000D+02       0.1947058000D-02       0.3425019000D+00\n      0.3213816000D+02      -0.5987388000D+00       0.4644938000D+00\n      0.1341845000D+02      -0.4958972000D+00       0.2087284000D+00\nSP   6   1.00\n      0.1175107000D+03      -0.6157662000D-02      -0.6922855000D-02\n      0.4152553000D+02       0.5464841000D-01      -0.3069239000D-01\n      0.1765290000D+02       0.2706994000D+00       0.4480260000D-01\n      0.7818313000D+01      -0.1426136000D+00       0.3636775000D+00\n      0.3571775000D+01      -0.7216781000D+00       0.4952412000D+00\n      0.1623750000D+01      -0.3412008000D+00       0.2086340000D+00\nSP   3   1.00\n      0.2374560000D+01       0.3251184000D+00      -0.3009554000D-01\n      0.8691930000D+00      -0.2141533000D+00       0.3598893000D+00\n      0.3474730000D+00      -0.9755083000D+00       0.7103098000D+00\nSP   1   1.00\n      0.1264790000D+00       0.1000000000D+01       0.1000000000D+01\nD    3   1.00\n      0.6853888000D+02       0.7530705000D-01\n      0.1914333000D+02       0.3673551000D+00\n      0.6251213000D+01       0.7120146000D+00\nD    1   1.00\n      0.1979236000D+01       1.0000000\n\"\"\";\n\ngenBFuncsFromText(txt_Kr_631G, adjustContent=true)","category":"page"},{"location":"basis/#Constructing-basis-sets-from-GaussFunc","page":"Basis Sets","title":"Constructing basis sets from GaussFunc","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"If you want to specify the parameters of each Gaussian function when constructing a basis set, you can first construct the container for Gaussian functions: GaussFunc, and then build the basis function upon them:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"using Quiqbox # hide\n\ngf1 = GaussFunc(2.0, 1.0)\n\ngf2 = GaussFunc(2.5, 0.75)\n\nbf1 = genBasisFunc([1.0,0,0], [gf1, gf2])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Unlike BasisFunc there's no proprietary function for it, you simply input the exponent coefficient and the contraction coefficient as the 1st and 2nd arguments respectively to its default constructor. As for the method of genBasisFunc in this case, the default subshell is set to be \"S\" as the optional 3rd argument, but you can construct a BasisFuncs which contains all the orbitals within a specified one:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf2 = genBasisFunc([1.0,0,0], [gf1, gf2], \"P\")","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"You can even choose one or a few orbitals to keep by indicting them using a NTuple{3, Int} in the Cartesian representation:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf3 = genBasisFunc([1.0,0,0], [gf1, gf2], (1,0,0))\n\nbf4 = genBasisFunc([1.0,0,0], [gf1, gf2], [(1,0,0), (0,0,1)])","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Again, if you want a faster solution, you can also directly define the 2 GaussFunc parameter(s) in a 2-element Tuple as the 2nd argument for genBasisFunc:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"bf5 = genBasisFunc([1.0,0,0], ([2.0, 2.5], [1.0, 0.75]), [(1,0,0), (0,0,1)])\n\nhasEqual(bf4, bf5)","category":"page"},{"location":"basis/#Constructing-basis-sets-based-on-ParamBox","page":"Basis Sets","title":"Constructing basis sets based on ParamBox","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Sometimes you may want the parameters of basis functions (or GaussFunc) to be under some constrains (which can be crucial for the later basis set optimization), this is when you need a deeper level of control over the parameters, through its direct container: ParamBox. In fact, in the above example we have already had an glimpse on it through the printed info in the REPL:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf1","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"the 2 fields of a GaussFunc, .xpn and .con are in fact ParamBox, and the actual value of them can be accessed through syntax []:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf1.xpn\n\ngf1.con\n\ngf1.xpn[]\n\ngf1.con[]","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Since the data are not directly stored as primitive types but rather inside struct ParamBox, this allows the direct assignment or shallow copy of them to not create new data with same values, but bindings to the original objects:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf3 = GaussFunc(1.1, 1)\n\n# Direct assignment\ngf3_2 = gf3\n\ngf3.xpn[] *= 2\n\ngf3\n\ngf3_2\n\n# Shallow copy: `fill`\nbf6 = genBasisFunc([1,0,0], fill(gf3, 2))\n\nbf6.gauss\n\nbf6.gauss[1].xpn[] = 1.1\n\ngf3_2.xpn[] == gf3.xpn[] == bf6.gauss[2].xpn[] == 1.1\n","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Based on such trait in Julia, you can, for instance, create a basis set that enforces all the GaussFuncs have the identical parameters:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"gf4 = GaussFunc(2.5, 0.5)\n\nbs7 = genBasisFunc.([rand(3) for _=1:2], Ref(gf4))\n\nuniqueParams!(bs7)","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"uniqueParams! marks all the parameters of the given basis set and return the unique parameters. As you can see, even though bs7 has 2 GaussFuncs as basis functions, but over all it only has 1 unique coefficient exponent alpha_1 and 1 unique contraction coefficient d_1.","category":"page"},{"location":"basis/#Dependent-Variable-as-a-parameter","page":"Basis Sets","title":"Dependent Variable as a parameter","text":"","category":"section"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Another control the user can have on the parameters in Quiqbox is to not only directly store each parameter in a ParamBox, but also make it output a dependent variable that is defined by the mapping function of the parameter.","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"Such a mapping function is stored in the map field of a ParamBox ( which normally is an R to R mapping). The mapped value can be access through  syntax (). In default the variable is mapped to itself:","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"pb1 = gf4.xpn\n\npb1.map\n\npb1[] == pb1()","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"You can get a clearer view of the mapping relations in a ParamBox using getVarDict","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"getVarDict(pb1)","category":"page"},{"location":"basis/","page":"Basis Sets","title":"Basis Sets","text":"info: Parameter represented by `ParamBox`\nThe mapped variable (value) of a ParamBox is always used as the parameter (parameter value) it represents in the construction of any basis function component. If instead, you want to optimize the variable before the mapping, the ParamBox needs to be marked as \"differentiable\". For more information parameter optimization, please see the docstring of ParamBox and section Parameter Optimization.","category":"page"},{"location":"SCF/#Self-Consistent-Field-Methods","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"","category":"section"},{"location":"SCF/#Hartree-Fock-Methods","page":"Self-Consistent Field Methods","title":"Hartree-Fock Methods","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox supports basic Hartree-Fock methods with various configurations: ","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Items Options\nHF Types Restricted Closed-Shell (RHF), Unrestricted Open-Shell (UHF)\nInitial Guesses Core Hamiltonian, Generalized Wolfsberg-Helmholtz, User-defined Coefficient Matrix\nConverging Methods Direct Diagonalization, DIIS, EDIIS, ADIIS, Combinations of Multi-methods\nDIIS-type Method Solvers Lagrange Multiplier Solver, ADMM Solver","category":"page"},{"location":"SCF/#Basic-Hartree-Fock","page":"Self-Consistent Field Methods","title":"Basic Hartree-Fock","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"To run a Hartree-Fock method, the lines of code required in Quiqbox is as simple as below:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nnuc = [\"H\", \"H\"];\n\nnucCoords = [[-0.7, 0.0, 0.0], [0.7, 0.0, 0.0]];\n\nbs = genBasisFunc.(nucCoords, (\"STO-3G\", \"H\") |> Ref) |> flatten\n\nresRHF = runHF(bs, nuc, nucCoords)\n\n@show resRHF.E0HF resRHF.C resRHF.Emo resRHF.occu","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"After the SCF procedure, one can also easily store the result in a Molecule for further data processing such as generating Molden files.","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"mol = Molecule(bs, nuc, nucCoords, resRHF);","category":"page"},{"location":"SCF/#Flexible-core-functions","page":"Self-Consistent Field Methods","title":"Flexible core functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"If the user want to fine-tune part of the SCF iteration steps to achieve better performance, Quiqbox also has provided various more flexible core functions that  allows user to customize the HF methods:","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"SCFconfig","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"runHFcore","category":"page"},{"location":"SCF/#Standalone-Integral-Functions","page":"Self-Consistent Field Methods","title":"Standalone Integral Functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"Quiqbox also provides several integral functions that can be used independently of any SCF functions if intended.","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlap","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"overlaps","category":"page"},{"location":"SCF/#One-electron-functions","page":"Self-Consistent Field Methods","title":"One-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"nucAttractions","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetic","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"elecKinetics","category":"page"},{"location":"SCF/#Two-electron-functions","page":"Self-Consistent Field Methods","title":"Two-electron functions","text":"","category":"section"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteraction","category":"page"},{"location":"SCF/","page":"Self-Consistent Field Methods","title":"Self-Consistent Field Methods","text":"eeInteractions","category":"page"},{"location":"coreType/#Core-Types","page":"Core Types","title":"Core Types","text":"","category":"section"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"ParamBox{V, VI, T}","category":"page"},{"location":"coreType/#Quiqbox.ParamBox","page":"Core Types","title":"Quiqbox.ParamBox","text":"ParamBox{T, V, F} <: DifferentiableParameter{ParamBox, T}\n\nParameter container that can enable parameter differentiations.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\ndata::Array{T<:Number, 0}: The data (parameter) stored in a 0-D Array that can be  accessed by syntax [].\n\ndataName::Symbol: The name assigned to the stored data.\n\nmap::Function: The mathematical mapping of the data. The mapped result can be accessed by  syntax ().\n\ncanDiff::Array{Bool, 0}: Indicator that whether this container (mapped variable) is  marked as \"differentiable\".\n\nindex::Array{<:Union{Int, Nothing}, 0}: Additional index assigned to the parameter.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nParamBox(data::Array{T, 0}, dataName::Symbol=:undef; \n         index::Union{Int, Nothing}=nothing) where {T<:Number} -> \nParamBox{T, dataName, :itself}\n\nParamBox(data::Array{T, 0}, name::Symbol, mapFunction::Function, \n         dataName::Symbol=:undef; canDiff::Bool=true, \n         index::Union{Int, Nothing}=nothing) where {T<:Number} ->\nParamBox{T, name, nameOf(mapFunction)}\n\nParamBox(data::Number, dataName::Symbol=:undef; index::Union{Int, Nothing}=nothing, \n         paramType::Type{<:Number}=Float64) where {T<:Number} -> \nParamBox{paramType, dataName, :itself}\n\nParamBox(data::Number, name::Symbol, mapFunction::Function, dataName::Symbol=:undef; \n         canDiff::Bool=true, index::Union{Int, Nothing}=nothing, \n         paramType::Type{<:Number}=Float64) where {T<:Number} ->\nParamBox{paramType, name, nameOf(mapFunction)}\n\nname specifies the name of the (mapped) variable the ParamBox represents, which helps  with symbolic representation and automatic differentiation.\n\nmapFunction: The (mathematical) mapping of the data, which will be stored in the field  map. It is for the case where the variable represented by the ParamBox is dependent on  another independent variable of which the value is the stored data in the container. After  initializing a ParamBox, e.g pb1 = ParamBox(x, mapFunction=f), pb[] returns x, and  pb() returns f(x). mapFunction is set to itself in default, which is a dummy  function that maps the data to itself.\n\ncanDiff determines whether the mapped math variable is \"marked\" as differentiable (i.e.,  the mapping is a differentiable function) with respect to the stored data. In other  words, it determines whether the mapped variable ParamBox generated during the automatic  differentiation procedure is treated as a dependent variable or an independent variable  regardless of the mapping relation.\n\nparamType specifies the type of the stored parameter to avoid data type mutation.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> ParamBox(1.0)\nParamBox{Float64, :undef, :itself}(1.0)[‚àÇ][undef]\n\njulia> ParamBox(1.0, :a)\nParamBox{Float64, :a, :itself}(1.0)[‚àÇ][a]\n\njulia> ParamBox(1.0, :a, abs)\nParamBox{Float64, :a, :abs}(1.0)[‚àÇ][x_a]\n\nNOTE 1: The rightmost \"[‚àÇ][IV]\" in the printing info indicates the differentiability  and the name of the represented independent variable :IV. When the ParamBox is marked  as a \"differentiable function\", \"[‚àÇ]\" is in color green (otherwise it's in grey).\n\nNOTE 2: It's always the (mapped) variable V generated by a ParamBox{<:Any, V} that  is used to construct a basis, whereas the underlying independent variable is used to  differentiate the basis (in other words, only when mapFunction = itself or  canDiff = false is the independent variable same as the mapped variable/represented  parameter).\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GaussFunc","category":"page"},{"location":"coreType/#Quiqbox.GaussFunc","page":"Core Types","title":"Quiqbox.GaussFunc","text":"GaussFunc <: AbstractGaussFunc\n\nA single contracted gaussian function struct from package Quiqbox.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nxpn::ParamBox{Float64, :Œ±}ÔºöExponent of the gaussian function.\n\ncon::ParamBox{Float64, :d}: Contraction coefficient of the gaussian  function.\n\nparam::NTuple{2, ParamBox}: A Tuple that stores the ParamBoxs of xpn and con.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nGaussFunc(xpn::ParamBox, con::ParamBox) -> GaussFunc\n\nGaussFunc(xpn::Real, con::Real) -> GaussFunc\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"BasisFunc{ùëô, GN}","category":"page"},{"location":"coreType/#Quiqbox.BasisFunc","page":"Core Types","title":"Quiqbox.BasisFunc","text":"BasisFunc{ùëô, GN} <: FloatingGTBasisFuncs{ùëô, GN, 1}\n\nA (floating) basis function with the center attached to it instead of any nucleus.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\ncenter::NTuple{3, ParamBox}: The center coordinate in form of a 3-element ParamBox-type  Tuple.\n\ngauss::NTuple{N, GaussFunc}: Gaussian functions within the basis function.\n\nijk::Tuple{XYZTuple{ùëô}}: Cartesian representation (pseudo-quantum number) of the  angular momentum orientation. E.g., s (X‚Å∞Y‚Å∞Z‚Å∞) would be XYZTuple{0}((0, 0, 0)). For  convenient syntax, .ijk[] converts it to a NTuple{3, Int}.\n\nnormalizeGTO::Bool: Whether the GTO::GaussFunc will be normalized in calculations.\n\nparam::Tuple{Vararg{<:ParamBox}}Ôºö All the tunable parameters::ParamBox stored in the  BasisFunc.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nBasisFunc(center::Tuple{Vararg{<:ParamBox}}, gauss::NTuple{GN, GaussFunc}, \n          ijk::NTuple{3, Int}, normalizeGTO::Bool) where {GN} -> \nBasisFunc{ùëô, GN} where {ùëô}\n\nBasisFunc(cen::Tuple{Vararg{<:ParamBox}}, gauss::GaussFunc, ijk::NTuple{3, Int}, \n          normalizeGTO::Bool) ->\nBasisFunc{ùëô, 1} where {ùëô}\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"BasisFuncs{ùëô, GN, ON}","category":"page"},{"location":"coreType/#Quiqbox.BasisFuncs","page":"Core Types","title":"Quiqbox.BasisFuncs","text":"BasisFuncs{ùëô, GN, ON} <: FloatingGTBasisFuncs{ùëô, GN, ON}\n\nA group of basis functions with identical parameters except they have different  orientations in the specified subshell. It has the same fields as BasisFunc and  specifically, for ijk, the size of the it (ON) can be no less than 1 (and no larger  than the size of the corresponding subshell).\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Quiqbox.BasisFuncMix{BN, GN}","category":"page"},{"location":"coreType/#Quiqbox.BasisFuncMix","page":"Core Types","title":"Quiqbox.BasisFuncMix","text":"BasisFuncMix{BN, GN} <: CompositeGTBasisFuncs{BN, 1}\n\nSum of multiple FloatingGTBasisFuncs without any reformulation, treated as one basis  Function in the integral calculation.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nBasisFunc::NTuple{BN, FloatingGTBasisFuncs{<:Any, <:Any, 1}}: Inside basis functions\n\nparam::Tuple{Vararg{<:ParamBox}}: Inside parameters.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nBasisFuncMix(bfs::Array{<:FloatingGTBasisFuncs{ùëô, GN, 1} where {ùëô, GN}, 1}) ->\nBasisFuncMix{BN, GN}\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GTBasis{BT, T}","category":"page"},{"location":"coreType/#Quiqbox.GTBasis","page":"Core Types","title":"Quiqbox.GTBasis","text":"GTBasis{BT, T} <: BasisSetData{BT}\n\nThe container to store basis set information.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nbasis::Vector{<:CompositeGTBasisFuncs{<:Any, 1}}: Basis set.\n\nS::Array{<:Number, 2}: Overlap matrix.\n\nTe::Array{<:Number, 2}: Kinetic energy part of the electronic core Hamiltonian.\n\neeI::Array{<:Number, 4}: Electron-electron interaction.\n\ngetVne::Function: A Function that returns the nuclear attraction Hamiltonian when  nuclei::Array{String, 1} and their coordinates::Array{<:AbstractArray, 1} are input.\n\ngetHcore::Function: Similar as getVne, a Function that returns the core Hamiltonian  when nuclei and their coordinates of same DataType are input.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nGTBasis(basis::Array{<:AbstractGTBasisFuncs, 1}, S::Matrix{<:Number}, \n        Te::Matrix{<:Number}, eeI::Array{<:Number, 4}) -> \nGTBasis\n\nGTBasis(basis::Array{<:AbstractGTBasisFuncs, 1}) -> GTBasis\n\nDirectly construct a GTBasis given a basis set.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"GridBox{NX, NY, NZ}","category":"page"},{"location":"coreType/#Quiqbox.GridBox","page":"Core Types","title":"Quiqbox.GridBox","text":"GridBox{NX, NY, NZ} <: SemiMutableParameter{GridBox, Float64}\n\nA struct that stores coordinates of grid points in terms of both Vectors and  ParamBoxs.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nnum::Int: Total number of the grid points.\n\nspacing::Float64: The length between adjacent grid points.\n\nbox::Vector{NTuple{3, ParamBox}}: The coordinates of grid points in terms of ParamBoxs.\n\ncoord::Array{Array{Float64, 1}, 1}: The coordinates of grid points in terms of Vectors.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nGridBox(nGrids::NTuple{3, Int}, spacing::Real=10, \n        centerCoord::Array{<:Real, 1}=[0.0,0.0,0.0];\n        canDiff::Bool=true, index::Int=0) -> GridBox\n\nConstruct a general GridBox that doesn't have to shape as a cube. nGrid is a 3-element  Tuple that specifies the number of grids (number of grid points - 1) along 3 dimensions.  spacing specifies the length between adjacent grid points. centerCoord specifies the  geometry center coordinate of the box. canDiff determines whether the ParamBox should  be marked as differentiable. index defines the index number for the actual parameter:  spacing L, with the default value 0 it would be L‚ÇÄ.\n\nGridBox(nGridPerEdge::Int, spacing::Real=10, \n        centerCoord::Array{<:Real, 1}=[0.0,0.0,0.0]; \n        canDiff::Bool=true, index::Int=0) -> GridBox\n\nMethod of generating a cubic GridBox. nGridPerEdge specifies the number of grids  (number of grid points - 1) along each dimension.spacing specifies the length between  adjacent grid points. centerCoord specifies the geometry center coordinate of the box.  canDiff determines whether the ParamBox should be marked as differentiable. index  defines the index number for the actual parameter: spacing L, with the default value 0  it would be L‚ÇÄ.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"HFconfig{HFT, CT}","category":"page"},{"location":"coreType/#Quiqbox.HFconfig","page":"Core Types","title":"Quiqbox.HFconfig","text":"HFconfig{HFT, CT} <: ConfigBox{HFconfig, HFT}\n\nThe mutable container of Hartree-Fock method configuration.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nHF::Val{HFT}: Hartree-Fock method type. Available values of HFT are  :RHF, :UHF.\n\nC0::Union{Matrix{Float64}, NTuple{2, Matrix{Float64}}, Val}: Initial guess of the  coefficient matrix(s) C of the molecular orbitals. When C0 is a Val{T}, the available  values of T are :GWH, :Hcore, :SAD.\n\nSCF::SCFconfig: SCF iteration configuration. For more information please refer to  SCFconfig.\n\nearlyTermination::Bool: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.\n\nmaxStep::Int: Maximum allowed iteration steps regardless of whether the SCF converges.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nHFconfig() -> HFconfig\n\nHFconfig(t::NamedTuple) -> HFconfig\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> HFconfig()\nHFconfig{:RHF, :SAD, 3}(Val{:RHF}(), Val{:SAD}(), SCFconfig{3}(interval=(0.0001, 1.0e-6, 1.0e-15), oscillateThreshold=1.0e-5, method, methodConfig)[:ADIIS, :DIIS, :ADIIS], 1000, true)\n\njulia> HFconfig((HF=:UHF,))\nHFconfig{:UHF, :SAD, 3}(Val{:UHF}(), Val{:SAD}(), SCFconfig{3}(interval=(0.0001, 1.0e-6, 1.0e-15), oscillateThreshold=1.0e-5, method, methodConfig)[:ADIIS, :DIIS, :ADIIS], 1000, true)\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"SCFconfig{N}","category":"page"},{"location":"coreType/#Quiqbox.SCFconfig","page":"Core Types","title":"Quiqbox.SCFconfig","text":"SCFconfig{N} <: ImmutableParameter{SCFconfig, Any}\n\nThe struct for SCF iteration configurations.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nmethod::NTuple{N, Quiqbox.FunctionType}: The applied methods. The available methods and their  configurations (in terms of keyword arguments):\n\nMethods Configuration(s) keyword argument(s) Default value(s)\n:DS Damping strength: [0,1] dampingStrength::Float64 0.0\n:DIIS, :EDIIS, :ADIIS Subspace size (>1); Coefficient solver(:ADMM-> ADMM solver, :LCM -> Lagrange solver) DIISsize::Int; solver::Symbol 15; :ADMM\n\ninterval::NTuple{N, Float64}: The stopping (skipping) thresholds for required methods.\n\nmethodConfig::NTuple{N, Vector{<:Pair}}: The additional keywords arguments for each  method stored as Tuples of Pairs.\n\noscillateThreshold::Float64: The threshold for oscillating convergence.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nSCFconfig(methods::NTuple{N, Symbol}, intervals::NTuple{N, Float64}, \n          configs::Dict{Int, <:Vector{<:Pair}}=Dict(1=>Pair[]);\n          oscillateThreshold::Float64=1e-5) where {N} -> \nSCFconfig{N}\n\nmethods and intervals are the methods to be applied and their stopping (skipping)  thresholds respectively; the length of those two Vectors should be the same. configs  specifies the additional keyword arguments for each methods by a Pair of which the Int  key i is for ith method and the pointed Vector{<:Pair} is the pairs of keyword  arguments and their values respectively.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> SCFconfig((:SD, :ADIIS, :DIIS), (1e-4, 1e-12, 1e-13), Dict(2=>[:solver=>:LCM]))\nSCFconfig{3}(interval=(0.0001, 1.0e-12, 1.0e-13), oscillateThreshold=1.0e-5, method, methodConfig)[:SD, :ADIIS, :DIIS]\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Quiqbox.HFtempVars{HFtype}","category":"page"},{"location":"coreType/#Quiqbox.HFtempVars","page":"Core Types","title":"Quiqbox.HFtempVars","text":"HFtempVars{HFT} <: HartreeFockintermediateData\n\nThe container to store the intermediate values (only of the same spin configuration) for  each iteration during the Hartree-Fock SCF procedure. \n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nN::Int: The number of electrons with the same spin function.\n\nCs::Array{Array{Float64, 2}, 1}: Coefficient matrices.\n\nFs::Array{Array{Float64, 2}, 1}: Fock matrices\n\nDs::Array{Array{Float64, 2}, 1}: Density matrices corresponding  to only spin configuration. For RHF each elements means (unconverged) 0.5*D·µÄ.\n\nEs::Array{Float64, 1}: Part of Hartree-Fock energy corresponding to only spin  configuration. For RHF each element means (unconverged) 0.5*E0HF.\n\nshared.Dtots::Array{Array{Float64, 2}, 1}: The total density  matrices.\n\nshared.Etots::Array{Float64, 1}: The total Hartree-Fock energy.\n\nNOTE: For UHF, there are 2 HFtempVars being updated during the SCF iterations, and  change the field shared.Dtots or shared.Etots of one container will affect the other  one's.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Quiqbox.HFfinalVars{HFtype}","category":"page"},{"location":"coreType/#Quiqbox.HFfinalVars","page":"Core Types","title":"Quiqbox.HFfinalVars","text":"HFfinalVars{HFT} <: HartreeFockFinalValue{HFT}\n\nThe container of the final values after a Hartree-Fock SCF procedure.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nE0HF::Float64: Hartree-Fock energy of the electronic Hamiltonian. \n\nN::Int: The total number of electrons.\n\nC::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}:  Coefficient matrix(s) for one spin configuration.\n\nF::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}: Fock  matrix(s) for one spin configuration.\n\nD::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}: Density  matrix(s) for one spin configuration.\n\nEmo::Union{Array{Float64, 1}, NTuple{2, Array{Float64, 1}}}: Energies of molecular  orbitals.\n\noccu::Union{Array{Int, 1}, NTuple{2, Array{Int, 1}}}: occupation numbers of molecular  orbitals.\n\ntemp::Union{HFtempVars{HFT}, NTuple{2, HFtempVars{HFT}}} the intermediate values.\n\nisConverged::Bool: Whether the SCF procedure is converged in the end.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"Molecule{Nc, Ne, Nb}","category":"page"},{"location":"coreType/#Quiqbox.Molecule","page":"Core Types","title":"Quiqbox.Molecule","text":"Molecule{Nc, Ne, Nb} <:MolecularHartreeFockCoefficient{Nc, Ne}\n\nContainer for the information of a molecule.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nnuc::Tuple{Vararg{String}}: Nuclei of the molecule.\n\nnucCoords::Tuple{Vararg{NTuple{3, Real}}}: The coordinates of the nuclei.\n\nNe::Int: The number of electrons.\n\norbital::Tuple{Vararg{MolOrbital}}: Molecular orbitals.\n\nbasis::Tuple{Vararg{FloatingGTBasisFuncs}}: The basis set for the molecular orbitals.\n\nE0HF::Float64: Hartree-Fock energy of the electronic Hamiltonian from the basis set.\n\nEnnR::Float64: The nuclear-nuclear repulsion energy.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nMolecule(basis::Array{FloatingGTBasisFuncs, 1}, nuc::Array{String, 1}, \n         nucCoords::Array{<:AbstractArray, 1}, Ne::Int, E0HF::Float64, \n         Emos::Array{Float64, 1}, occus::Array{<:Real, 1}, C::Array{Float64, 2}, \n         spins::Array{String, 1}, \n         symms::Array{String, 1}=repeat([\"A\"], length(occus))) -> \nMolecule{<:Any, Ne, <:Any}\n\nEmos are the energies of corresponding molecular energies. occus are the occupation  numbers of the orbitals. C is the coefficient matrix, which does not need to be a square  matrix since the number of rows is the size of the (spatial) basis set whereas the number  of the columns represents the number of molecular orbitals. spin specifies the spin  functions of the orbitals, entries of which can be set to \"Alpha\" or \"Beta\". symms are  symmetries of the orbitals where the default entry value is \"A\" for being antisymmetric.\n\nMolecule(basis::Array{<:FloatingGTBasisFuncs, 1}, nuc::Array{String, 1}, \n         nucCoords::Array{<:AbstractArray, 1}, HFfVars::HFfinalVars) -> \nMolecule\n\nConstruct a Molecule from a basis set, nuclei information, and the result from the  corresponding Hartree-Fock SCF procedure, specifically a HFfinalVars struct.\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"MolOrbital{N}","category":"page"},{"location":"coreType/#Quiqbox.MolOrbital","page":"Core Types","title":"Quiqbox.MolOrbital","text":"MolOrbital{N} <: AbstractMolOrbital\n\nStruct of molecular orbitals.\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nsymmetry::String: The symmetry of the orbital. The default value is \"A\" for being  antisymmetric.\n\nenergy::Float64: Molecular energy.\n\nspin::String: Spin function of the orbital. Available values: \"Alpha\", \"Beta\".\n\noccupancy::Real: Occupation number.\n\norbitalCoeffs::NTuple{N, Float64}: coefficients of the basis functions to form the  molecular orbital.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nMolOrbital(energy::Float64, occupancy::Real, orbitalCoeffs::Array{Float64, 1}, \n           spin::String=\"Alpha\", symmetry::String=\"A\") -> MolOrbital{N}\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Core Types","title":"Core Types","text":"POconfig{M, T, F}","category":"page"},{"location":"coreType/#Quiqbox.POconfig","page":"Core Types","title":"Quiqbox.POconfig","text":"POconfig{M, T, F} <: ConfigBox{POconfig, M}\n\n‚â°‚â°‚â° Field(s) ‚â°‚â°‚â°\n\nThe mutable container of parameter optimization configuration.\n\nmethod::Val{M}: The method to calculate objective function (e.g., HF energy) for  optimization. Available values of M from Quiqbox are :HF,.\n\nconfig::ConfigBox{<:Any, T}: The configuration struct for the selected method. E.g.,  for :HF it's HFconfig.\n\ntarget::Float64: The value of target function aimed to achieve.\n\nerror::Float64: The error for the convergence when evaluating difference between  the latest few energies. When set to NaN, there will be no convergence detection.\n\nmaxStep::Int: Maximum allowed iteration steps regardless of whether the optimization  iteration converges.\n\nGD::F1: Applied gradient descent Function. Default method is gradDescent!.\n\n‚â°‚â°‚â° Initialization Method(s) ‚â°‚â°‚â°\n\nPOconfig() -> POconfig\n\nPOconfig(t::NamedTuple) -> POconfig\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> POconfig()\nPOconfig{:HF, HFconfig{:RHF, :SAD, 3}, typeof(gradDescent!)}(Val{:HF}(), HFconfig{:RHF, :SAD, 3}(Val{:RHF}(), Val{:SAD}(), SCFconfig{3}(interval=(0.0001, 1.0e-6, 1.0e-15), oscillateThreshold=1.0e-5, method, methodConfig)[:ADIIS, :DIIS, :ADIIS], 1000, true), NaN, 0.0001, 500, Quiqbox.gradDescent!)\n\njulia> POconfig((maxStep=100,))\nPOconfig{:HF, HFconfig{:RHF, :SAD, 3}, typeof(gradDescent!)}(Val{:HF}(), HFconfig{:RHF, :SAD, 3}(Val{:RHF}(), Val{:SAD}(), SCFconfig{3}(interval=(0.0001, 1.0e-6, 1.0e-15), oscillateThreshold=1.0e-5, method, methodConfig)[:ADIIS, :DIIS, :ADIIS], 1000, true), NaN, 0.0001, 100, Quiqbox.gradDescent!)\n\n\n\n\n\n","category":"type"},{"location":"optimization/#Parameter-Optimization","page":"Parameter Optimization","title":"Parameter Optimization","text":"","category":"section"},{"location":"optimization/#Selectively-Optimizing-Parameters","page":"Parameter Optimization","title":"Selectively Optimizing Parameters","text":"","category":"section"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"In the Basis Sets section, we have briefly introduced the parameters in terms of ParamBox that are embedded in containers such as BasisFunc and BasisFuncs that are directly used to form a basis set. This means how we construct the basis set using the parameters will determine the parameter space to optimize the basis set. For more information please refer to Constructing basis sets based on ParamBox.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"Here is an example of using GaussFunc and GridBox to quickly generate a grid-based basis set with only 3 actual parameters. One is the spacing L of the grid points that indirectly determines all the center coordinates of basis function through a series of mapping functions; the other two are one exponent coefficient alpha and one contraction coefficient d.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"push!(LOAD_PATH,\"../../src/\") # hide\nusing Quiqbox # hide\n\nnuc = [\"H\", \"H\"]\n\nnucCoords = [[-0.7,0.0,0.0], [0.7,0.0,0.0]]\n\ngrid = GridBox(1, 3.0)\n\ngf1 = GaussFunc(0.7,1)\n\nbs = genBasisFunc.(grid.box, Ref([gf1]))","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After constructing the basis set, we need to use uniqueParams! to mark all the  unique parameters that can also be optimized later:","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"pars = uniqueParams!(bs, filterMapping=true)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"As expected, there are indeed only 3 unique tunable independent parameters despite the basis set has 8 basis functions. However, if we take a step further, we can remove d since each basis function here is just one same Gaussian function. Thus, input the intent parameters (along with other necessary arguments) into the optimizeParams! and we can sit and wait for the optimization iterations to complete.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"parsPartial = [pars[1], pars[4]]\n\nEs, pars, grads = optimizeParams!(parsPartial, bs, nuc, nucCoords, POconfig((maxStep=20,)));","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"After the optimization, you can check the basis set and we can see the parameters inside of it is also changed. This is because the ! in the function names indicates that optimizeParams! is a function that modifies its arguments.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"getParams(bs)","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"It you want to go through the above example by yourself, you can also find the script here.","category":"page"},{"location":"optimization/#Store-Customized-Basis-Set","page":"Parameter Optimization","title":"Store Customized Basis Set","text":"","category":"section"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"Now, if you want, you can also store the information of the basis set in an container called GTBasis that not only includes the basis set, but also the related 1-electron and 2-electron integral values (nuclear attraction is not stored). GTBasis can also be accepted as an argument for runHF to save the time of recalculating the integrals of the basis set.","category":"page"},{"location":"optimization/","page":"Parameter Optimization","title":"Parameter Optimization","text":"GTBasis(bs)","category":"page"},{"location":"coreFunction/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genExponent","category":"page"},{"location":"coreFunction/#Quiqbox.genExponent","page":"Core Functions","title":"Quiqbox.genExponent","text":"genExponent(e::Real, mapFunction::Function; canDiff::Bool=true, \n            roundDigits::Int=15, dataName::Symbol=:undef) -> \nParamBox{Float64, :Œ±}\n\ngenExponent(e::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, \n            dataName::Symbol=:undef) where {T<:Real} -> \nParamBox{Float64, :Œ±}\n\nConstruct a ParamBox for an exponent coefficient given a value. Keywords mapFunction  and canDiff work the same way as in a general constructor of a ParamBox. If  roundDigits < 0, there won't be rounding for input data.\n\n\n\n\n\ngenExponent(e::Real; roundDigits::Int=15) -> ParamBox{Float64, :Œ±}\n\ngenExponent(e::Array{T, 0}) where {T<:Real} -> ParamBox{Float64, :Œ±}\n\n\n\n\n\ngenExponent(pb::ParamBox{Float64}) -> ParamBox{Float64, :Œ±}\n\nConvert a ParamBox to an exponent coefficient parameter.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genContraction","category":"page"},{"location":"coreFunction/#Quiqbox.genContraction","page":"Core Functions","title":"Quiqbox.genContraction","text":"genContraction(c::Real, mapFunction::Function; canDiff::Bool=true, \n            roundDigits::Int=15, dataName::Symbol=:undef) -> \nParamBox{Float64, :d}\n\ngenContraction(c::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, \n            dataName::Symbol=:undef) where {T<:Real} -> \nParamBox{Float64, :d}\n\nConstruct a ParamBox for an contraction coefficient given a value. Keywords mapFunction  and canDiff work the same way as in a general constructor of a ParamBox. If  roundDigits < 0, there won't be rounding for input data.\n\n\n\n\n\ngenContraction(c::Real; roundDigits::Int=15) -> ParamBox{Float64, :d}\n\ngenContraction(c::Array{T, 0}) where {T<:Real} -> ParamBox{Float64, :d}\n\n\n\n\n\ngenContraction(pb::ParamBox{Float64}) -> ParamBox{Float64, :d}\n\nConvert a ParamBox to an exponent coefficient parameter.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genSpatialPoint","category":"page"},{"location":"coreFunction/#Quiqbox.genSpatialPoint","page":"Core Functions","title":"Quiqbox.genSpatialPoint","text":"genSpatialPoint(point::Union{Tuple, Vector}, mapFunction::F=itself; canDiff::Bool=true, \n                roundDigits::Int=15, dataName::Symbol=:undef)\n\nReturn the parameter(s) of a spatial coordinate in terms of ParamBox. Keywords  mapFunction and canDiff work the same way as in a general constructor of a ParamBox.  If roundDigits < 0 or the input c is a 0-d Array, there won't be rounding for input  data.\n\n‚â°‚â°‚â° Method 1 ‚â°‚â°‚â°\n\ngenSpatialPoint(point::Vector, mapFunction::F=itself; canDiff::Bool=true, \n                roundDigits::Int=15, dataName::Symbol=:undef) -> \nTuple{ParamBox{Float64, :X}, \n      ParamBox{Float64, :Y}, \n      ParamBox{Float64, :Z}}\n\nReturn the parameters that represent a spatial point. The entry of input Vector can  be either a Real number or a Array{Float64, 0}.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> v1 = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> genSpatialPoint(v1)\n(ParamBox{Float64, :X, :itself}(1.0)[‚àÇ][X], ParamBox{Float64, :Y, :itself}(2.0)[‚àÇ][Y], ParamBox{Float64, :Z, :itself}(3.0)[‚àÇ][Z])\n\njulia> v2 = [fill(1.0), 2, 3]\n3-element Vector{Any}:\n  fill(1.0)\n 2\n 3\n\njulia> p2 = genSpatialPoint(v2); p2[1]\nParamBox{Float64, :X, :itself}(1.0)[‚àÇ][X]\n\njulia> v2[1][] = 1.2\n1.2\n\njulia> p2[1]\nParamBox{Float64, :X, :itself}(1.2)[‚àÇ][X]\n\n‚â°‚â°‚â° Method 2 ‚â°‚â°‚â°\n\ngenSpatialPoint(point::Tuple{Union{Real, Array{Float64, 0}}, Int}, \n                mapFunction::F=itself; canDiff::Bool=true, roundDigits::Int=15, \n                dataName::Symbol=:undef) -> \nParamBox{Float64}\n\nReturn the component of a spatial point given its value (or 0-D container) and index.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> genSpatialPoint((1.2, 1))\nParamBox{Float64, :X, :itself}(1.2)[‚àÇ][X]\n\njulia> pointY1 = fill(2.0)\n0-dimensional Array{Float64, 0}:\n2.0\n\njulia> Y1 = genSpatialPoint((pointY1, 2))\nParamBox{Float64, :Y, :itself}(2.0)[‚àÇ][Y]\n\njulia> pointY1[] = 1.5\n1.5\n\njulia> Y1\nParamBox{Float64, :Y, :itself}(1.5)[‚àÇ][Y]\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"inValOf","category":"page"},{"location":"coreFunction/#Quiqbox.inValOf","page":"Core Functions","title":"Quiqbox.inValOf","text":"inValOf(pb::ParamBox) -> Number\n\nReturn the value of stored data (independent variable) of the input ParamBox. Equivalent  to pb[].\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"inSymOf","category":"page"},{"location":"coreFunction/#Quiqbox.inSymOf","page":"Core Functions","title":"Quiqbox.inSymOf","text":"inSymOf(pb::ParamBox) -> Symbolics.Num\n\nReturn the variable::Symbolics.Num of stored data (independent variable) of the input  ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"inSymValOf","category":"page"},{"location":"coreFunction/#Quiqbox.inSymValOf","page":"Core Functions","title":"Quiqbox.inSymValOf","text":"inSymValOf(pb::ParamBox{T}) where {T} -> ::Pair{Symbolics.Num, T}\n\nReturn a Pair of the stored independent variable of the input ParamBox and its  corresponding value.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"outValOf","category":"page"},{"location":"coreFunction/#Quiqbox.outValOf","page":"Core Functions","title":"Quiqbox.outValOf","text":"outValOf(pb::ParamBox) -> Number\n\nReturn the value of mapped data (dependent variable) of the input ParamBox. Equivalent to  pb().\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"outSymOf","category":"page"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"dataOf","category":"page"},{"location":"coreFunction/#Quiqbox.dataOf","page":"Core Functions","title":"Quiqbox.dataOf","text":"dataOf(pb::ParamBox{T}) where {T<:Number} -> Array{T, 0}\n\nReturn the 0-D Array of the data stored in the input ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"mapOf","category":"page"},{"location":"coreFunction/#Quiqbox.mapOf","page":"Core Functions","title":"Quiqbox.mapOf","text":"mapOf(pb::ParamBox{<:Number, F}) where {F<:Function} -> F\n\nReturn the mapping function of the input ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"outValCopy","category":"page"},{"location":"coreFunction/#Quiqbox.outValCopy","page":"Core Functions","title":"Quiqbox.outValCopy","text":"outValCopy(pb::ParamBox{<:Number, V}) -> ParamBox{<:Number, V, :itself}\n\nReturn a new ParamBox of which the stored data is a deep copy of the mapped data from  the input ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"inVarCopy","category":"page"},{"location":"coreFunction/#Quiqbox.inVarCopy","page":"Core Functions","title":"Quiqbox.inVarCopy","text":"inVarCopy(pb::ParamBox) -> ParamBox{<:Number, <:Any, :itself}\n\nReturn a new ParamBox of which the stored data is a shallow copy of the stored data  from the input ParamBox.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> pb1 = ParamBox(-2.0, :a, abs)\nParamBox{Float64, :a, :abs}(-2.0)[‚àÇ][x_a]\n\njulia> pb2 = inVarCopy(pb1)\nParamBox{Float64, :x_a, :itself}(-2.0)[‚àÇ][x_a]\n\njulia> pb1[] == pb2[] == -2.0\ntrue\n\njulia> pb1[] = 1.1\n1.1\n\njulia> pb2[]\n1.1\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"enableDiff!","category":"page"},{"location":"coreFunction/#Quiqbox.enableDiff!","page":"Core Functions","title":"Quiqbox.enableDiff!","text":"enableDiff!(pb::ParamBox) -> ParamBox\n\nMark the input ParamBox as \"differentiable\" and return the marked ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"disableDiff!","category":"page"},{"location":"coreFunction/#Quiqbox.disableDiff!","page":"Core Functions","title":"Quiqbox.disableDiff!","text":"disableDiff!(pb::ParamBox) -> ParamBox\n\nMark the input ParamBox as \"non-differentiable\" and return the marked ParamBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"isDiffParam","category":"page"},{"location":"coreFunction/#Quiqbox.isDiffParam","page":"Core Functions","title":"Quiqbox.isDiffParam","text":"isDiffParam(pb::ParamBox) -> Bool\n\nReturn the Boolean value of if the input ParamBox is \"differentiable\".\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"toggleDiff!","category":"page"},{"location":"coreFunction/#Quiqbox.toggleDiff!","page":"Core Functions","title":"Quiqbox.toggleDiff!","text":"toggleDiff!(pb::ParamBox) -> Bool\n\nToggle the differentiability (pb.canDiff[]) of the input ParamBox and return the  altered result.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBasisFunc","category":"page"},{"location":"coreFunction/#Quiqbox.genBasisFunc","page":"Core Functions","title":"Quiqbox.genBasisFunc","text":"genBasisFunc(center::Union{AbstractArray, NTuple{3, ParamBox}, Missing}, \n             args..., kws...) -> \nB where {B<:Union{FloatingGTBasisFuncs, Array{<:FloatingGTBasisFuncs}}}\n\nConstructor of BasisFunc and BasisFuncs, but it also returns different kinds of  collections of them based on the applied methods. The first argument center can be a 3-D  coordinate (e.g. Array{Float64, 1}), a NTuple{3} of spatial points (e.g. generated by  genSpatialPoint), or simply set to missing for later assignment.\n\n‚â°‚â°‚â° Method 1 ‚â°‚â°‚â°\n\ngenBasisFunc(center, gs::Array{GaussFunc, 1}, \n             ijkOrijks::Union{T, Array{T, 1}, NTuple{<:Any, T}}; \n             normalizeGTO::Bool=false) where {T <: NTuple{3, Int}}\n\nijkOrijks is the Array of the pseudo-quantum number(s) to specify the angular  momentum(s). E.g., s is (0,0,0) and p is ((1,0,0), (0,1,0), (0,0,1)).\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), (0,1,0))\nBasisFunc{1, 1}(center, gauss)[X‚Å∞Y¬πZ‚Å∞][0.0, 0.0, 0.0]\n\n‚â°‚â°‚â° Method 2 ‚â°‚â°‚â°\n\ngenBasisFunc(center, gExpsANDgCons::NTuple{2, Array{<:Real, 1}}, subshell=\"S\"; kw...)\n\nInstead of directly inputting GaussFunc, one can also input a 2-element Tuple of the  exponent(s) and contraction coefficient(s) corresponding to the same GaussFunc(s).\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> genBasisFunc([0,0,0], (2, 1), \"P\")\nBasisFuncs{1, 1, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], ([2, 1.5], [1, 0.5]), \"P\")\nBasisFuncs{1, 2, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]\n\n‚â°‚â°‚â° Method 3 ‚â°‚â°‚â°\n\ngenBasisFunc(center, gs::Union{GaussFunc, Array{GaussFunc, 1}}, subshell::String=\"S\", \n             ijkFilter::NTuple{N, Bool}=fill(true, SubshellSizeList[subshell])|>Tuple; \n             normalizeGTO::Bool=false) where {N}\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), \"S\")\nBasisFunc{0, 1}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], GaussFunc(2,1), \"P\")\nBasisFuncs{1, 1, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]\n\n‚â°‚â°‚â° Method 4 ‚â°‚â°‚â°\n\ngenBasisFunc(center, BSKeyANDnuc::Array{Tuple{String, String}, 1})\n\nIf the user wants to construct existed atomic basis set(s), they can use the (Array of)  (BS_name, Atom_name) as the second input. If the atom is omitted, then basis set for H  is used.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> genBasisFunc([0,0,0], (\"STO-3G\", \"Li\"))\n3-element Vector{Quiqbox.FloatingGTBasisFuncs}:\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFuncs{1, 3, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], \"STO-3G\")\n1-element Vector{Quiqbox.FloatingGTBasisFuncs}:\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], [\"STO-2G\", \"STO-3G\"])\n2-element Vector{Quiqbox.FloatingGTBasisFuncs}:\n BasisFunc{0, 2}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n\njulia> genBasisFunc([0,0,0], [(\"STO-2G\", \"He\"), (\"STO-3G\", \"O\")])\n4-element Vector{Quiqbox.FloatingGTBasisFuncs}:\n BasisFunc{0, 2}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][0.0, 0.0, 0.0]\n BasisFuncs{1, 3, 3}(center, gauss)[3/3][0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"sortBasisFuncs","category":"page"},{"location":"coreFunction/#Quiqbox.sortBasisFuncs","page":"Core Functions","title":"Quiqbox.sortBasisFuncs","text":"sortBasisFuncs(bs::Array{<:FloatingGTBasisFuncs}; groupCenters::Bool=false) -> Array\n\nSort basis functions. If groupCenters = true, Then the function will return an  Array{<:Array{<:FloatingGTBasisFuncs, 1}, 1} in which the arrays are grouped basis  functions with same center coordinates.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"centerOf","category":"page"},{"location":"coreFunction/#Quiqbox.centerOf","page":"Core Functions","title":"Quiqbox.centerOf","text":"centerOf(bf::FloatingGTBasisFuncs) -> \nTuple{ParamBox{Float64, X}, \n      ParamBox{Float64, Y}, \n      ParamBox{Float64, Z}}\n\nReturn the center of the input FloatingGTBasisFuncs.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"centerCoordOf","category":"page"},{"location":"coreFunction/#Quiqbox.centerCoordOf","page":"Core Functions","title":"Quiqbox.centerCoordOf","text":"centerCoordOf(bf::FloatingGTBasisFuncs) -> Vector{Float64}\n\nReturn the center coordinate of the input FloatingGTBasisFuncs.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nFilter = t -> nameof(t) == :add","category":"page"},{"location":"coreFunction/#Quiqbox.add-Union{Tuple{BasisFuncs{ùëô, GN, 1}}, Tuple{GN}, Tuple{ùëô}} where {ùëô, GN}","page":"Core Functions","title":"Quiqbox.add","text":"add(b::CompositeGTBasisFuncs{<:Any, 1}) -> CompositeGTBasisFuncs{<:Any, 1}\n\nadd(b1::CompositeGTBasisFuncs{<:Any, 1}, b2::CompositeGTBasisFuncs{<:Any, 1}) ->\nCompositeGTBasisFuncs{<:Any, 1}\n\nAddition between CompositeGTBasisFuncs{<:Any, 1} such as BasisFunc and  Quiqbox.BasisFuncMix. It can be called using + syntax.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> bf1 = genBasisFunc([1,1,1], (2,1))\nBasisFunc{0, 1}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\njulia> bf2 = genBasisFunc([1,1,1], (2,2))\nBasisFunc{0, 1}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\njulia> bf3 = bf1 + bf2\nBasisFunc{0, 1}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\njulia> bf3.gauss[1].con[]\n3.0\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nFilter = t -> nameof(t) == :mul","category":"page"},{"location":"coreFunction/#Quiqbox.mul-Tuple{GaussFunc, Real}","page":"Core Functions","title":"Quiqbox.mul","text":"mul(gf::GaussFunc, coeff::Real) -> GaussFunc\n\nmul(coeff::Real, gf::GaussFunc) -> GaussFunc\n\nmul(gf1::GaussFunc, gf2::GaussFunc) -> GaussFunc\n\nMultiplication between GaussFuncs or contraction coefficient multiplication between a  Real number and a GaussFunc. It can be called using * syntax.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> gf1 = GaussFunc(3,1)\nGaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(3.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(1.0)[‚àÇ][d])\n\njulia> gf1 * 2\nGaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(3.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])\n\njulia> gf1 * gf1\nGaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(6.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(1.0)[‚àÇ][d])\n\njulia> gf1 * 2 * gf1\nGaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(6.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/#Quiqbox.mul-Union{Tuple{ùëô2}, Tuple{ùëô1}, Tuple{BasisFunc{ùëô1, 1}, BasisFunc{ùëô2, 1}}} where {ùëô1, ùëô2}","page":"Core Functions","title":"Quiqbox.mul","text":"mul(sgf1::BasisFunc{ùëô1, 1}, sgf2::BasisFunc{ùëô2, 1}; \n         normalizeGTO::Union{Bool, Missing}=missing)::BasisFunc{ùëô1+ùëô2, 1} where {ùëô1, ùëô2}\n\nmul(a1::Real, a2::CompositeGTBasisFuncs{<:Any, 1}; \n    normalizeGTO::Union{Bool, Missing}=missing) -> \nCompositeGTBasisFuncs{<:Any, 1}\n\nmul(a1::CompositeGTBasisFuncs{<:Any, 1}, a2::CompositeGTBasisFuncs{<:Any, 1}; \n    normalizeGTO::Union{Bool, Missing}=missing) -> \nCompositeGTBasisFuncs{<:Any, 1}\n\nMultiplication between CompositeGTBasisFuncs{<:Any, 1}s such as BasisFunc and  Quiqbox.BasisFuncMix, or contraction coefficient multiplication between a Real number  and a CompositeGTBasisFuncs{<:Any, 1}. If normalizeGTO is set to missing (in  default), The GaussFunc in the output result will be normalized only if all the input  bases have normalizeGTO = true. The function can be called using * syntax.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> bf1 = genBasisFunc([1,1,1], ([2,1], [0.1, 0.2]))\nBasisFunc{0, 2}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\njulia> bf2 = bf1 * 2\nBasisFunc{0, 2}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\njulia> getindex.(getfield.(bf2.gauss, :con))\n(0.2, 0.4)\n\njulia> bf3 = bf1 * bf2\nBasisFunc{0, 3}(center, gauss)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nFilter = t -> nameof(t) == :shift","category":"page"},{"location":"coreFunction/#Quiqbox.shift-Union{Tuple{GN}, Tuple{ùëô}, Tuple{Quiqbox.FloatingGTBasisFuncs{ùëô, GN, 1}, AbstractArray{var\"#s46\", N} where {var\"#s46\"<:Real, N}}} where {ùëô, GN}","page":"Core Functions","title":"Quiqbox.shift","text":"shift(bf::FloatingGTBasisFuncs{ùëô, GN, 1}, \n      didjdk::Union{Vector{<:Real}, NTuple{3, Int}}) where {ùëô, GN} -> \nBasisFunc\n\nShift (add) the angular momentum (Cartesian representation) given the a vector that  specifies the change of each pseudo-quantum number ùëëi, ùëëj, ùëëk.\n\n\n\n\n\n","category":"method"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"decompose","category":"page"},{"location":"coreFunction/#Quiqbox.decompose","page":"Core Functions","title":"Quiqbox.decompose","text":"decompose(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -> Matrix{<:BasisFunc}\n\nDecompose a FloatingGTBasisFuncs into an Array of BasisFuncs. Each column represents  one orbital of the input basis function(s). If splitGaussFunc is true, then each column  consists of the BasisFuncs each with only 1 GaussFunc.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"basisSize","category":"page"},{"location":"coreFunction/#Quiqbox.basisSize","page":"Core Functions","title":"Quiqbox.basisSize","text":"basisSize(subshell::String) -> Int\n\nReturn the size (number of orbitals) of each subshell.\n\n\n\n\n\nbasisSize(b::CompositeGTBasisFuncs) -> Int\n\nReturn the numbers of orbitals of the input basis function(s).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBasisFuncText","category":"page"},{"location":"coreFunction/#Quiqbox.genBasisFuncText","page":"Core Functions","title":"Quiqbox.genBasisFuncText","text":"genBasisFuncText(bf::FloatingGTBasisFuncs; norm=1.0, printCenter=true) -> String\n\nGenerate a String of the text of the input FloatingGTBasisFuncs. norm is the  additional normalization factor. If printCenter is true, the center coordinate  will be added on the first line of the String.\n\n\n\n\n\ngenBasisFuncText(bs::Array{<:FloatingGTBasisFuncs, 1}; \n                 norm=1.0, printCenter=true, groupCenters::Bool=true) -> \nString\n\nGenerate a String of the text of the input basis set. norm is the additional  normalization factor. If printCenter is true, the center coordinate will be added  on the first line of the String. groupCenters determines whether the function will  group the basis functions with same center together.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genBFuncsFromText","category":"page"},{"location":"coreFunction/#Quiqbox.genBFuncsFromText","page":"Core Functions","title":"Quiqbox.genBFuncsFromText","text":"genBFuncsFromText(content::String; adjustContent::Bool=false, \n                  adjustFunction::F=sciNotReplace, \n                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, \n                  center::Union{AbstractArray, \n                                Tuple{N, ParamBox}, \n                                Missing}=missing, \n                  unlinkCenter::Bool=false) where {N, F<:Function} -> \nArray{<:FloatingGTBasisFuncs, 1}\n\nGenerate the basis set from a String of basis set in Gaussian format or the String output  from genBasisFuncText. For the former, adjustContent needs to be set to true.  adjustFunction is only applied when adjustContent=true, which in default is a  function used to detect and convert the format of the scientific notation in the String.\n\nexcludeFirstNlines and excludeLastNlines are used to exclude first or last few lines of  the String if intent. center is used to assign a coordinate for all the basis functions  from the String; it can be a Vector, a Tuple of the positional ParamBoxs; when it's  set to missing, it will try to read the center information from the input string, and  leave the center as [NaN, NaN, Nan] if it can't find one for the corresponding  BasisFunc. If unlinkCenter = true, the center of each basis function is a deepcopy of  the input center. The coordinate information, if included, should be right above the  subshell information for the BasisFunc. E.g.:\n\n    \"\"\"\n    X        1.0                           0.0                           0.0                    \n    S    1   1.0\n             2.0                           1.0\n    \"\"\"\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"assignCenter!","category":"page"},{"location":"coreFunction/#Quiqbox.assignCenter!","page":"Core Functions","title":"Quiqbox.assignCenter!","text":"assignCenter!(center::AbstractArray, b::FloatingGTBasisFuncs) -> NTuple{3, ParamBox}\n\nAssign a new coordinate to the center of the input FloatingGTBasisFuncs. Also return the  altered center.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getParams","category":"page"},{"location":"coreFunction/#Quiqbox.getParams","page":"Core Functions","title":"Quiqbox.getParams","text":"getParams(pbc::ParamBox, symbol::Union{Symbol, Nothing}=nothing; \n          onlyDifferentiable::Bool=false) -> \nUnion{ParamBox, Nothing}\n\ngetParams(pbc::StructSpatialBasis, symbol::Union{Symbol, Nothing}=nothing; \n          onlyDifferentiable::Bool=false) -> \nArray{<:ParamBox, 1}\n\ngetParams(pbc::Array, symbol::Union{Symbol, Nothing}=nothing; \n          onlyDifferentiable::Bool=false) -> \nArray{<:ParamBox, 1}\n\nReturn the parameter(s) stored in the input container. If keyword argument symbol is set  to nothing, then return all the different parameters; if it's set to the Symbol of a  parameter (e.g. the symbol of ParamBox{T, V} would be V), return only that type of  parameters (which might still have different indices). onlyDifferentiable determines  whether ignore non-differentiable parameters. If the 1st argument is an Array, the  entries must be ParamBox containers.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"Modules = [Quiqbox]\nFilter = t -> nameof(t) == :copyBasis","category":"page"},{"location":"coreFunction/#Quiqbox.copyBasis","page":"Core Functions","title":"Quiqbox.copyBasis","text":"copyBasis(b::GaussFunc, copyOutVal::Bool=true) -> GaussFunc\n\ncopyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -> CompositeGTBasisFuncs\n\nReturn a copy of the input basis. If copyOutVal is set to true, then only the value(s)  of mapped data will be copied, i.e., outValCopy is used to copy the ParamBoxs,  otherwise inVarCopy is used.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> e = genExponent(3.0, x->x^2)\nParamBox{Float64, :Œ±, :f_Œ±‚ÇÅ}(3.0)[‚àÇ][x_Œ±]\n\njulia> c = genContraction(2.0)\nParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d]\n\njulia> gf1 = GaussFunc(e, c);\n\njulia> gf2 = copyBasis(gf1)\nGaussFunc(xpn=ParamBox{Float64, :Œ±, :itself}(9.0)[‚àÇ][Œ±], con=ParamBox{Float64, :d, :itself}(2.0)[‚àÇ][d])\n\njulia> gf1.xpn() == gf2.xpn()\ntrue\n\njulia> (gf1.xpn[] |> gf1.xpn.map) == gf2.xpn[]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"uniqueParams!","category":"page"},{"location":"coreFunction/#Quiqbox.uniqueParams!","page":"Core Functions","title":"Quiqbox.uniqueParams!","text":"uniqueParams!(bs; filterMapping::Bool=false) -> Array{<:ParamBox, 1}\n\nMark the parameters (ParamBox) in input bs which can a Vector of GaussFunc or  FloatingGTBasisFuncs. The identical parameters will be marked with same index.  filterMappingdetermines weather filter out (i.e. not return) ParamBoxs that have same  independent variables despite they may have same mapping functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getVar","category":"page"},{"location":"coreFunction/#Quiqbox.getVar","page":"Core Functions","title":"Quiqbox.getVar","text":"getVar(pb::ParamBox) -> Symbolics.Num\n\ngetVar(container::StructSpatialBasis) -> Array{Symbolics.Num, 1}\n\nReturn the independent variable(s) of the input parameter container.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getVarDict","category":"page"},{"location":"coreFunction/#Quiqbox.getVarDict","page":"Core Functions","title":"Quiqbox.getVarDict","text":"getVarDict(obj::Union{ParamBox, StructSpatialBasis, Array}; \n           includeMapping::Bool=false) -> \nDict{Symbolics.Num, <:Number}\n\nReturn a Dict that stores the independent variable(s) of the parameter container(s) and  its(their) corresponding value(s). If includeMapping = true, then the dictionary will  also include the mapping relations between the mapped variables and the independent  variables.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"expressionOf","category":"page"},{"location":"coreFunction/#Quiqbox.expressionOf","page":"Core Functions","title":"Quiqbox.expressionOf","text":"expressionOf(bf::CompositeGTBasisFuncs; splitGaussFunc::Bool=false) -> \nArray{<:Symbolics.Num, 2}\n\nReturn the expression(s) of a given CompositeGTBasisFuncs (e.g. BasisFuncMix or  FloatingGTBasisFuncs) as a Matrix{<:Symbolics.Num}of which the column(s) corresponds to  different orbitals. If splitGaussFunc is true, the column(s) will be expanded  vertically such that the entries are GaussFunc inside the corresponding orbital.\n\n\n\n\n\nexpressionOf(gf::GaussFunc) -> Symbolics.Num\n\nReturn the expression of a given GaussFunc.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"makeCenter","category":"page"},{"location":"coreFunction/#Quiqbox.makeCenter","page":"Core Functions","title":"Quiqbox.makeCenter","text":"makeCenter(coord::Array{<:Real, 1}; roundDigits::Int=-1) -> NTuple{3, ParamBox}\n\nGenerate a Tuple of coordinate ParamBoxs for a basis function center coordinate given a  Vector. If roundDigits < 0 then there won't be rounding for input data.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"gridCoords","category":"page"},{"location":"coreFunction/#Quiqbox.gridCoords","page":"Core Functions","title":"Quiqbox.gridCoords","text":"gridCoords(gb::GridBox) -> Array{Array{Float64, 1}, 1}\n\nReturn the grid-point coordinates in Vectors given the GriBox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"runHF","category":"page"},{"location":"coreFunction/#Quiqbox.runHF","page":"Core Functions","title":"Quiqbox.runHF","text":"runHF(gtb::Union{BasisSetData, Vector{<:AbstractGTBasisFuncs}}, \n      nuc::Vector{String}, \n      nucCoords::Vector{<:AbstractArray{<:Real}}, \n      N::Int=getCharge(nuc), \n      config::HFconfig{HFT}=HFconfig();\n      printInfo::Bool=true) where {HFT} -> \nHFfinalVars{HFT}\n\nMain function to run Hartree-Fock in Quiqbox.\n\n=== Positional argument(s) ===\n\nbs::Union{BasisSetData, Array{<:AbstractGTBasisFuncs, 1}}: Basis set.\n\nnuc::Array{String, 1}: The element symbols of the nuclei for the Molecule.\n\nnucCoords::Array{<:AbstractArray, 1}: Nuclei coordinates.\n\nN::Int: Total number of electrons.\n\nconfig::HFconfig: The Configuration of selected Hartree-Fock method. For more information  please refer to HFconfig.\n\n=== Keyword argument(s) ===\n\nprintInfo::Bool: Whether print out the information of iteration steps.\n\n\n\n\n\nrunHF(gtb::Union{BasisSetData, Vector{<:AbstractGTBasisFuncs}}, \n      nuc::Vector{String}, \n      nucCoords::Vector{<:AbstractArray{<:Real}}, \n      config::HFconfig{HFT}=HFconfig(), \n      N::Int=getCharge(nuc);\n      printInfo::Bool=true) where {HFT} -> \nHFfinalVars{HFT}\n\nAnother method of runHF.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"runHFcore","category":"page"},{"location":"coreFunction/#Quiqbox.runHFcore","page":"Core Functions","title":"Quiqbox.runHFcore","text":"runHFcore(scfConfig::SCFconfig, \n          N::Union{NTuple{2, Int}, Int}, \n          Hcore::Array{Float64, 2}, \n          HeeI::Array{Float64, 4}, \n          S::Array{Float64, 2}, \n          X::Array{Float64, 2}, \n          C0::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}, \n          printInfo::Bool=false, \n          maxStep::Int=1000, \n          earlyTermination::Bool=true) -> \nHFfinalVars\n\nThe core function of runHF.\n\n=== Positional argument(s) ===\n\nscfConfig::SCFconfig: SCF iteration configuration.\n\nN::Union{NTuple{2, Int}, Int}: The total number of electrons or the numbers of electrons  with different spins respectively. When the latter is input, an UHF is performed.\n\nHcore::Array{Float64, 2}: Core Hamiltonian of electronic Hamiltonian.\n\nHeeI::Array{Float64, 4}: The electron-electron interaction Hamiltonian which includes both the  Coulomb interactions and the Exchange Correlations.\n\nS::Array{Float64, 2}: Overlap matrix of the corresponding basis set.\n\nX::Array{Float64, 2}: Orthogonal transformation matrix of S. Default value is S^(-0.5).\n\nC0::Union{Array{Float64, 2}, NTuple{2, Array{Float64, 2}}}: Initial guess of the  coefficient matrix(s) C of the molecular orbitals.\n\nprintInfo::Bool: Whether print out the information of iteration steps.\n\nmaxStep::Int: Maximum allowed iteration steps regardless of whether the SCF converges.\n\nearlyTermination::Bool: Whether automatically early terminate (skip) a convergence method  when its performance becomes unstable or poor.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"getMolOrbitals","category":"page"},{"location":"coreFunction/#Quiqbox.getMolOrbitals","page":"Core Functions","title":"Quiqbox.getMolOrbitals","text":"getMolOrbitals(ens::Array{Float64, 1}, occus::Array{<:Real, 1}, C::Matrix{Float64}, \n               spins::Array{String, 1}, \n               symms::Array{String, 1}=repeat([\"A\"], length(occus))) -> \nTuple{Vararg{getMolOrbitals}}\n\nA function that returns the molecular orbitals.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nnRepulsions","category":"page"},{"location":"coreFunction/#Quiqbox.nnRepulsions","page":"Core Functions","title":"Quiqbox.nnRepulsions","text":"nnRepulsions(nuc::Array{String, 1}, nucCoords::Array{<:AbstractArray, 1}) -> Float64\n\nCalculate the nuclear-nuclear repulsion energy given the nuclei and their coordinates of a  molecule.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"optimizeParams!","category":"page"},{"location":"coreFunction/#Quiqbox.optimizeParams!","page":"Core Functions","title":"Quiqbox.optimizeParams!","text":"optimizeParams!(pbs::Array{<:ParamBox, 1}, \n                bs::Array{<:AbstractGTBasisFuncs, 1}, \n                nuc::Array{String, 1}, \n                nucCoords::Array{<:AbstractArray, 1}, \n                N::Int=getCharge(nuc), \n                config::POconfig{M, T, F}=POconfig(); \n                printInfo::Bool=true\nEs::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}\n\nThe main function to optimize the parameters of a given basis set.\n\n=== Positional argument(s) ===\n\npbs::Array{<:ParamBox, 1}: The parameters to be optimized that are extracted from the  basis set.\n\nbs::Array{<:AbstractGTBasisFuncs, 1}: Basis set.\n\nnuc::Array{String, 1}: The element symbols of the nuclei for the Molecule.\n\nnucCoords::Array{<:AbstractArray, 1}: Nuclei coordinates.\n\nN::Int: Total number of electrons.\n\nconfig::POconfig: The Configuration of selected parameter optimization method. For more  information please refer to POconfig.\n\n=== Keyword argument(s) ===\n\nprintInfo::Bool: Whether print out the information of iteration steps.\n\n\n\n\n\noptimizeParams!(pbs::Array{<:ParamBox, 1}, \n                bs::Array{<:AbstractGTBasisFuncs, 1}, \n                nuc::Array{String, 1}, \n                nucCoords::Array{<:AbstractArray, 1}, \n                config::POconfig{M, T, F}=POconfig(), \n                N::Int=getCharge(nuc); \n                printInfo::Bool=true\nEs::Array{Float64, 1}, pars::Array{Float64, 2}, grads::Array{Float64, 2}\n\nAnother method of optimizeParams!.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"updateParams!","category":"page"},{"location":"coreFunction/#Quiqbox.updateParams!","page":"Core Functions","title":"Quiqbox.updateParams!","text":"updateParams!(pbs::Array{<:ParamBox, 1}, grads::Array{<:Real, 1}, \n              method::F=gradDescent!) where {F<:Function} -> Array{<:ParamBox, 1}\n\nGiven a Vector of parameters::ParamBox and its gradients with respect to each  parameter, update the ParamBoxs and return the updated values.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"gradDescent!","category":"page"},{"location":"coreFunction/#Quiqbox.gradDescent!","page":"Core Functions","title":"Quiqbox.gradDescent!","text":"gradDescent!(pars::Vector{<:Real}, grads::Vector{<:Real}, \n             Œ∑=0.001, clipThreshold=0.08*sqrt(length(grad))/norm(Œ∑)) -> \npars::Vector{<:Real}\n\nDefault gradient descent method in used in Quiqbox.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"overlap","category":"page"},{"location":"coreFunction/#Quiqbox.overlap","page":"Core Functions","title":"Quiqbox.overlap","text":"overlap(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -> \nArray{Float64, 2}\n\nReturn the orbital overlap matrix (an N√óN Matrix where N is the number of spatial  orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"overlaps","category":"page"},{"location":"coreFunction/#Quiqbox.overlaps","page":"Core Functions","title":"Quiqbox.overlaps","text":"overlaps(BSet::Array{<:AbstractGTBasisFuncs, 1}) -> Array{Float64, 2}\n\nReturn the orbital overlap matrix (an N√óN Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nucAttraction","category":"page"},{"location":"coreFunction/#Quiqbox.nucAttraction","page":"Core Functions","title":"Quiqbox.nucAttraction","text":"nucAttraction(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, \n              nuc::Array{String, 1}, nucCoords::Array{<:AbstractArray, 1}) -> \nArray{Float64, 2}\n\nReturn the nuclear attraction matrix (an N√óN Matrix where N is the number of spatial  orbitals) given 2 basis functions, and the nuclei with their coordinates (in atomic unit).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"nucAttractions","category":"page"},{"location":"coreFunction/#Quiqbox.nucAttractions","page":"Core Functions","title":"Quiqbox.nucAttractions","text":"nucAttractions(BSet::Array{<:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, \n               nucCoords::Array{<:AbstractArray, 1}) -> \nArray{Float64, 2}\n\nReturn the nuclear attraction matrix (an N√óN Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array, and the nuclei with their  coordinates (in atomic unit).\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"elecKinetic","category":"page"},{"location":"coreFunction/#Quiqbox.elecKinetic","page":"Core Functions","title":"Quiqbox.elecKinetic","text":"elecKinetic(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs) -> \nArray{Float64, 2}\n\nReturn the electron kinetic energy matrix (an N√óN Matrix where N is the number of spatial  orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"elecKinetics","category":"page"},{"location":"coreFunction/#Quiqbox.elecKinetics","page":"Core Functions","title":"Quiqbox.elecKinetics","text":"elecKinetics(BSet::Array{<:AbstractGTBasisFuncs, 1}) -> Array{Float64, 2}\n\nReturn the electron kinetic energy matrix (an N√óN Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"coreHij","category":"page"},{"location":"coreFunction/#Quiqbox.coreHij","page":"Core Functions","title":"Quiqbox.coreHij","text":"coreHij(fb1::AbstractGTBasisFuncs, fb2::AbstractGTBasisFuncs, nuc::Array{String, 1}, \n        nucCoords::Array{<:AbstractArray, 1}) -> \nArray{Float64, 2}\n\nReturn a matrix element or block of the core Hamiltonian (an N√óN Matrix where N is the  number of spatial orbitals) given 2 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"coreH","category":"page"},{"location":"coreFunction/#Quiqbox.coreH","page":"Core Functions","title":"Quiqbox.coreH","text":"coreH(BSet::Array{<:AbstractGTBasisFuncs, 1}, nuc::Array{String, 1}, \n      nucCoords::Array{<:AbstractArray, 1}) -> Array{Float64, 2}\n\nReturn the core Hamiltonian matrix (an N√óN Matrix where N is the number of spatial  orbitals) given a basis set in the form of an Array.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"eeInteraction","category":"page"},{"location":"coreFunction/#Quiqbox.eeInteraction","page":"Core Functions","title":"Quiqbox.eeInteraction","text":"eeInteraction(bf1::AbstractGTBasisFuncs, \n              bf2::AbstractGTBasisFuncs, \n              bf3::AbstractGTBasisFuncs, \n              bf4::AbstractGTBasisFuncs) -> \nArray{Float64, 4}\n\nReturn the electron-electron interaction tensor (an N√óN√óN√óN Tensor where N is the number of  spatial orbitals) given 4 basis functions.\n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"eeInteractions","category":"page"},{"location":"coreFunction/#Quiqbox.eeInteractions","page":"Core Functions","title":"Quiqbox.eeInteractions","text":"eeInteractions(BSet::Array{<:AbstractGTBasisFuncs, 1}) -> Array{Float64, 4}\n\nReturn the electron-electron interaction tensor (an N√óN√óN√óN Tensor where N is the number  of spatial orbitals) given a basis set in the form of an Array. \n\n\n\n\n\n","category":"function"},{"location":"coreFunction/","page":"Core Functions","title":"Core Functions","text":"genOFmethod","category":"page"},{"location":"list/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"Below are the types and functions included in the documentation.","category":"page"},{"location":"list/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"order = [:type]","category":"page"},{"location":"list/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"list/","page":"Index","title":"Index","text":"order = [:function]","category":"page"},{"location":"toolFunction/#Tool-Functions","page":"Tool Functions","title":"Tool Functions","text":"","category":"section"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Quiqbox.checkFname","category":"page"},{"location":"toolFunction/#Quiqbox.checkFname","page":"Tool Functions","title":"Quiqbox.checkFname","text":"checkFname(Fname::String; showWarning::Bool=true) -> String\n\nCheck if there is a file with the same name in the current directory. If so, will add an  \"_N\" at the end of the file name String. showWarning determines whether prints out  the WARNING info when there is a file with the same name.\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"hasEqual","category":"page"},{"location":"toolFunction/#Quiqbox.hasEqual","page":"Tool Functions","title":"Quiqbox.hasEqual","text":"hasEqual(obj1, obj2, obj3...; \n         ignoreFunction::Bool=false, \n         ignoreContainer::Bool=false,\n         decomposeNumberCollection::Bool=false) -> \nBool\n\nCompare if two objects are the equal.\n\nIf ignoreFunction = true, the function will ignore comparisons between Function-type  fields.\n\nIf ignoreContainer = true, the function will ignore the difference of the container(s)  and only compare the field(s)/entry(s) from two objects respectively.\n\nIf decomposeNumberCollection = true, then Tuple{Vararg{Number}} and Array{<:Number}  will be treated as decomposable containers.\n\nThis is an instantiation of Quiqbox.hasBoolRelation.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n    a = S(1, 1.0)\n    b = S(1, 1.0)\n    c = S(1, 1.0)\n    d = S(1, 1.1)\n\n    hasEqual(a, b, c) |> println\n    hasEqual(a, b, c, d) |> println\nend\n\n# output\ntrue\nfalse\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"hasIdentical","category":"page"},{"location":"toolFunction/#Quiqbox.hasIdentical","page":"Tool Functions","title":"Quiqbox.hasIdentical","text":"hasIdentical(obj1, obj2, obj3...; \n             ignoreFunction::Bool=false, \n             ignoreContainer::Bool=false,\n             decomposeNumberCollection::Bool=false) -> \nBool\n\nCompare if two objects are the Identical. An instantiation of hasBoolRelation.\n\nIf ignoreFunction = true, the function will ignore comparisons between Function-type  fields.\n\nIf ignoreContainer = true, the function will ignore the difference of the container(s)  and only compare the field(s)/entry(s) from two objects respectively.\n\nIf decomposeNumberCollection = true, then Tuple{Vararg{Number}} and Array{<:Number}  will be treated as decomposable containers.\n\nThis is an instantiation of Quiqbox.hasBoolRelation.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\nbegin\n    struct S\n        a::Int\n        b::Array{Float64, 1}\n    end\n\n    a = S(1, [1.0, 1.1])\n    b = a\n    c = b\n    d = S(1, [1.0, 1.1])\n\n    hasIdentical(a, b, c) |> println\n    hasIdentical(a, b, c, d) |> println\nend\n\n# output\ntrue\nfalse\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"flatten","category":"page"},{"location":"toolFunction/#Quiqbox.flatten","page":"Tool Functions","title":"Quiqbox.flatten","text":"flatten(a::Tuple) -> Tuple\n\nflatten(a::Array) -> Array\n\nFlatten a::Union{Array, Tuple} that contains Arrays and/or Tuples. Only operate on  the outermost layer.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> flatten((:one, 2, [3, 4.0], ([5], \"six\"), \"7\"))\n(:one, 2, 3.0, 4.0, [5], \"six\", \"7\")\n\njulia> flatten([:one, 2, [3, 4.0], ([5], \"six\"), \"7\"])\n7-element Vector{Any}:\n  :one\n 2\n 3.0\n 4.0\n  [5]\n  \"six\"\n  \"7\"\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"markUnique","category":"page"},{"location":"toolFunction/#Quiqbox.markUnique","page":"Tool Functions","title":"Quiqbox.markUnique","text":"markUnique(arr::AbstractArray, args...; \n           compareFunction::Function = hasEqual, kws...) -> \nmarkingList:: Array{Int, 1}, uniqueList::Array\n\nReturn a markingList using Int number to mark each different elements from (and inside)  the input argument(s) and a uniqueList to contain all the unique elements when  compareFunction is set to hasEqual (in default).\n\nargs and kws are positional arguments and keywords arguments respectively as  parameters of the specified compareFunction.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\nmarkUnique([1, [1, 2],\"s\", [1, 2]])\n\n# output\n([1, 2, 3, 2], Any[1, [1, 2], \"s\"])\n\nbegin\n    struct S\n        a::Int\n        b::Float64\n    end\n\n    a = S(1, 2.0)\n    b = S(1, 2.0)\n    c = S(1, 2.1)\n    d = a\n\n    markUnique([a,b,c,d])\nend\n\n# output\n([1, 1, 2, 1], S[S(1, 2.0), S(1, 2.1)])\n\n\n\n\n\n","category":"function"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"getUnique!(arr::Array, args...; compareFunction::F = hasEqual, kws...) where\n          {F<:Function} ","category":"page"},{"location":"toolFunction/#Quiqbox.getUnique!-Union{Tuple{F}, Tuple{Array, Vararg{Any, N} where N}} where F<:Function","page":"Tool Functions","title":"Quiqbox.getUnique!","text":"getUnique!(arr::Array, args...; compareFunction::F = hasEqual, kws...) where \n          {F<:Function} -> \narr::Array\n\nSimilar to markUnique but instead, just directly return the input Array with  repeated entries deleted.\n\n‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°\n\njulia> arr = [1, [1, 2],\"s\", [1, 2]]\n4-element Vector{Any}:\n 1\n  [1, 2]\n  \"s\"\n  [1, 2]\n\njulia> getUnique!(arr);\n\njulia> arr\n3-element Vector{Any}:\n 1\n  [1, 2]\n  \"s\"\n\n\n\n\n\n","category":"method"},{"location":"toolFunction/","page":"Tool Functions","title":"Tool Functions","text":"Quiqbox.itself","category":"page"},{"location":"toolFunction/#Quiqbox.itself","page":"Tool Functions","title":"Quiqbox.itself","text":"A dummy function that only returns its argument.\n\n\n\n\n\n","category":"function"},{"location":"#Quiqbox.jl","page":"Home","title":"Quiqbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quiqbox is a quantum chemistry and quantum physics software package that starts off around Gaussian basis set optimization for electronic structure problems. Quiqbox is written in pure Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Floating and fixed-basis Gaussian-type orbital (GTO) configurations.\nSymbolic representation and analysis of basis function parameters.\nStandalone 1-electron and 2-electron integral functions.\nRestricted (closed-shell) and unrestricted (open-shell) Hartree‚ÄìFock methods (RHF & UHF).\nMolecular orbital data output in Molden file format.\nVariational optimization of orbital geometry based on automatic differentiation (AD).","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"#Supported-system-platforms-(64-bit)","page":"Home","title":"Supported system platforms (64-bit)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linux\nMac OS\nWindows Subsystem for Linux","category":"page"},{"location":"#Julia-Environment","page":"Home","title":"Julia Environment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"1.6+","category":"page"},{"location":"#Installation-in-Julia-[REPL](https://docs.julialang.org/en/v1/manual/getting-started/)","page":"Home","title":"Installation in Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type ] to enter the Pkg mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type add Quiqbox and hit Enter key to install Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.x) pkg> add Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the installation completes, hit Backspace key to go back to Julia REPL and use using to load Quiqbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Quiqbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more basic usage of the programming language behind Quiqbox, Julia, please refer to the official documentation or this official tutorial.","category":"page"},{"location":"molden/#Molden","page":"Molden","title":"Molden","text":"","category":"section"},{"location":"molden/","page":"Molden","title":"Molden","text":"Quiqbox supports outputting molecular (in Molecule) information to Molden file format.","category":"page"},{"location":"molden/","page":"Molden","title":"Molden","text":"Quiqbox.Molden.makeMoldenFile","category":"page"},{"location":"molden/#Quiqbox.Molden.makeMoldenFile","page":"Molden","title":"Quiqbox.Molden.makeMoldenFile","text":"makeMoldenFile(mol::Molecule; roundDigits::Int=15, \n               recordUMO::Bool=false, fileName::String = \"MO\") -> String\n\nWrite the information of input Molecule into a Molden file. recordUMO determines  whether to include the unoccupied molecular orbitals. fileName specifies the name of the  file, which is also the returned value. If roundDigits < 0, there won't be rounding for  recorded data.\n\n\n\n\n\n","category":"function"},{"location":"molden/","page":"Molden","title":"Molden","text":"A concrete example of the above function can be found here.","category":"page"}]
}
