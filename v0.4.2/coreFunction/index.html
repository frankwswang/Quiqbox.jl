<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Functions ¬∑ Quiqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Quiqbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Quiqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../basis/">Basis Sets</a></li><li><a class="tocitem" href="../SCF/">Self-Consistent Field Methods</a></li><li><a class="tocitem" href="../optimization/">Parameter Optimization</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>Core Functions</a></li><li><a class="tocitem" href="../coreType/">Core Types</a></li><li><a class="tocitem" href="../toolFunction/">Tool Functions</a></li></ul></li><li><span class="tocitem">Submodule</span><ul><li><a class="tocitem" href="../molden/">Molden</a></li></ul></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>Core Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/frankwswang/Quiqbox.jl/blob/main/docs/src/coreFunction.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getCharge-Tuple{Union{Tuple, Vector}}" href="#Quiqbox.getCharge-Tuple{Union{Tuple, Vector}}"><code>Quiqbox.getCharge</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCharge(nucs::Union{Vector{String}, Tuple{Vararg{String}}}) -&gt; Int</code></pre><p>Return the total electric charge (in ùëí) of the input nuclei.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Library.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalLin" href="#Quiqbox.orbitalLin"><code>Quiqbox.orbitalLin</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbitalLin(subshell::String, D::Int=3) -&gt; Tuple{Vararg{NTuple{3, Int}}}</code></pre><p>Return all the possible angular momentum configuration(s) within the input <code>subshell</code> of  <code>D</code> dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Library.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeMapping-Union{Tuple{F}, Tuple{FL}, Tuple{V}, Tuple{T}, Tuple{ParamBox{T, V, FL}, F}, Tuple{ParamBox{T, V, FL}, F, Symbol}} where {T, V, FL, F&lt;:Function}" href="#Quiqbox.changeMapping-Union{Tuple{F}, Tuple{FL}, Tuple{V}, Tuple{T}, Tuple{ParamBox{T, V, FL}, F}, Tuple{ParamBox{T, V, FL}, F, Symbol}} where {T, V, FL, F&lt;:Function}"><code>Quiqbox.changeMapping</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeMapping(pb::ParamBox, mapFunction::Function, outputName::Symbol=V; 
              canDiff::Bool=true) -&gt; 
ParamBox{T, outputName}</code></pre><p>Change the mapping function of <code>pb</code>. The name of the output variable of the returned  <code>ParamBox</code> can be specified by <code>outputName</code>, and its differentiability is determined by  <code>canDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L388-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dataOf-Tuple{ParamBox}" href="#Quiqbox.dataOf-Tuple{ParamBox}"><code>Quiqbox.dataOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dataOf(pb::ParamBox{T}) where {T} -&gt; Array{T, 0}</code></pre><p>Return the 0-D <code>Array</code> containing data stored in <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.disableDiff!-Tuple{ParamBox}" href="#Quiqbox.disableDiff!-Tuple{ParamBox}"><code>Quiqbox.disableDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the <code>pb</code> as &quot;non-differentiable&quot; and then return it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.enableDiff!-Tuple{ParamBox}" href="#Quiqbox.enableDiff!-Tuple{ParamBox}"><code>Quiqbox.enableDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enableDiff!(pb::ParamBox) -&gt; ParamBox</code></pre><p>Mark the input <code>pb</code> as &quot;differentiable&quot; and then return it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L346-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVar" href="#Quiqbox.getVar"><code>Quiqbox.getVar</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVar(pb::ParamBox{T}, forDifferentiation::Bool=false) -&gt; Symbol</code></pre><p>Return the name of (the output variable of) <code>pb</code>. If <code>forDifferentiation</code> is set to <code>true</code>,  the name of the independent variable held by <code>pb</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getVarDict-Tuple{AbstractArray{&lt;:ParamBox}}" href="#Quiqbox.getVarDict-Tuple{AbstractArray{&lt;:ParamBox}}"><code>Quiqbox.getVarDict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getVarDict(obj::Union{ParamBox, Tuple{Vararg{ParamBox}}, AbstractArray{&lt;:ParamBox}}) -&gt; 
Dict{Symbol}</code></pre><p>Return a <code>Dict</code> that stores the independent variable(s) of the parameter container(s) and  its(their) corresponding value(s). </p><p><strong>NOTE: Once <code>obj</code> is mutated, the generated <code>Dict</code> may no longer be up to date.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L287-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymOf-Tuple{ParamBox}" href="#Quiqbox.inSymOf-Tuple{ParamBox}"><code>Quiqbox.inSymOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the name (with the index if available) of the input variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymOfCore-Tuple{ParamBox}" href="#Quiqbox.inSymOfCore-Tuple{ParamBox}"><code>Quiqbox.inSymOfCore</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inSymOfCore(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the <code>Symbol</code> of the input variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inSymValOf-Union{Tuple{ParamBox{T}}, Tuple{T}} where T" href="#Quiqbox.inSymValOf-Union{Tuple{ParamBox{T}}, Tuple{T}} where T"><code>Quiqbox.inSymValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inSymValOf(pb::ParamBox{T}) where {T} -&gt; ::Pair{Symbol, T}</code></pre><p>Return a <code>Pair</code> of the name (with the index if available) and the value of the input  variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L178-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inValOf-Tuple{ParamBox}" href="#Quiqbox.inValOf-Tuple{ParamBox}"><code>Quiqbox.inValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inValOf(pb::ParamBox{T}) where {T} -&gt; T</code></pre><p>Return the value of the input variable of <code>pb</code>. Equivalent to <code>pb[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.inVarCopy-Union{Tuple{ParamBox{T}}, Tuple{T}} where T" href="#Quiqbox.inVarCopy-Union{Tuple{ParamBox{T}}, Tuple{T}} where T"><code>Quiqbox.inVarCopy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inVarCopy(pb::ParamBox) -&gt; ParamBox{&lt;:Number, &lt;:Any, FLevel{0}}</code></pre><p>Return a new <code>ParamBox</code> of which the input variable is a <strong>shallow copy</strong> of the input  variable of <code>pb</code>.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; pb1 = ParamBox(-2.0, :a, abs)
ParamBox{Float64, :a, FLevel{1}}(-2.0)[‚àÇ][x_a]

julia&gt; pb2 = inVarCopy(pb1)
ParamBox{Float64, :x_a, FLevel{0}}(-2.0)[‚àÇ][x_a]

julia&gt; pb1[] == pb2[] == -2.0
true

julia&gt; pb1[] = 1.1
1.1

julia&gt; pb2[]
1.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L313-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.isDiffParam-Tuple{ParamBox}" href="#Quiqbox.isDiffParam-Tuple{ParamBox}"><code>Quiqbox.isDiffParam</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isDiffParam(pb::ParamBox) -&gt; Bool</code></pre><p>Return the Boolean value of if <code>pb</code> is differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mapOf-Tuple{ParamBox}" href="#Quiqbox.mapOf-Tuple{ParamBox}"><code>Quiqbox.mapOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapOf(pb::ParamBox) -&gt; Function</code></pre><p>Return the mapping function of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outSymOf-Tuple{ParamBox}" href="#Quiqbox.outSymOf-Tuple{ParamBox}"><code>Quiqbox.outSymOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outSymOf(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the name (with the index if available) of the output variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L202-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outSymOfCore-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V" href="#Quiqbox.outSymOfCore-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>Quiqbox.outSymOfCore</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outSymOfCore(pb::ParamBox) -&gt; Symbol</code></pre><p>Return the <code>Symbol</code> of the output variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outSymValOf-Union{Tuple{ParamBox{T}}, Tuple{T}} where T" href="#Quiqbox.outSymValOf-Union{Tuple{ParamBox{T}}, Tuple{T}} where T"><code>Quiqbox.outSymValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outSymValOf(pb::ParamBox) -&gt; ::Pair{Symbol, T}</code></pre><p>Return a <code>Pair</code> of the name (with the index if available) and the value of the output  variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V" href="#Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>Quiqbox.outValCopy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outValCopy(pb::ParamBox{T, V}) where {T} -&gt; ParamBox{T, V, FLevel{0}}</code></pre><p>Return a new <code>ParamBox</code> of which the input variable is a <strong>deep copy</strong> of the output  variable of <code>pb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L302-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.outValOf-Tuple{ParamBox}" href="#Quiqbox.outValOf-Tuple{ParamBox}"><code>Quiqbox.outValOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outValOf(pb::ParamBox) -&gt; Number</code></pre><p>Return the value of the output variable of <code>pb</code>. Equivalent to <code>pb()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.toggleDiff!-Tuple{ParamBox}" href="#Quiqbox.toggleDiff!-Tuple{ParamBox}"><code>Quiqbox.toggleDiff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">toggleDiff!(pb::ParamBox) -&gt; Bool</code></pre><p>Toggle the differentiability of the input <code>pb</code> and then return it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Parameters.jl#L379-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.add-Tuple{BasisFuncs{T, D, ùëô, GN, PT, 1} where {T, D, ùëô, GN, PT}}" href="#Quiqbox.add-Tuple{BasisFuncs{T, D, ùëô, GN, PT, 1} where {T, D, ùëô, GN, PT}}"><code>Quiqbox.add</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add(b1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, 
    b2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; roundDigits::Int=getAtolDigits(T)) where 
   {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code></pre><p>Addition between two <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code>s such as <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a>  and <a href="../coreType/#Quiqbox.BasisFuncMix"><code>BasisFuncMix</code></a>. <code>roundDigits</code> specifies the maximal number of digits after the  radix point of the calculated values. The function can be called using <code>+</code> syntax with the  keyword argument set to it default value.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1.,1.,1.], (2.,1.));

julia&gt; bf2 = genBasisFunc([1.,1.,1.], (2.,2.));

julia&gt; bf3 = bf1 + bf2;

julia&gt; bf3.gauss[1].con() == bf1.gauss[1].con() + bf2.gauss[1].con()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L951-L975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.assignCenInVal!-Tuple{AbstractVector{&lt;:Real}, FloatingGTBasisFuncs}" href="#Quiqbox.assignCenInVal!-Tuple{AbstractVector{&lt;:Real}, FloatingGTBasisFuncs}"><code>Quiqbox.assignCenInVal!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assignCenInVal!(center::AbstractVector{&lt;:Real}, b::FloatingGTBasisFuncs{T, D}) -&gt; 
SpatialPoint{T, D}</code></pre><p>Change the input value of data stored in <code>b.center</code> (meaning the output value will also  change according to the mapping function). Then, return the altered center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1653-L1660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerCoordOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.centerCoordOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.centerCoordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centerCoordOf(bf::FloatingGTBasisFuncs{T}) where {T} -&gt; Vector{T}</code></pre><p>Return the center coordinate of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L695-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.centerOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.centerOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.centerOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centerOf(bf::FloatingGTBasisFuncs{T, D}) where {T, D} -&gt; SpatialPoint{T, D}</code></pre><p>Return the center of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L686-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coordOf-Union{Tuple{SpatialPoint{T}}, Tuple{T}} where T" href="#Quiqbox.coordOf-Union{Tuple{SpatialPoint{T}}, Tuple{T}} where T"><code>Quiqbox.coordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordOf(sp::SpatialPoint{T}) where {T} -&gt; Vector{T}</code></pre><p>Get the coordinate represented by the input <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.copyBasis" href="#Quiqbox.copyBasis"><code>Quiqbox.copyBasis</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyBasis(b::GaussFunc, copyOutVal::Bool=true) -&gt; GaussFunc

copyBasis(b::CompositeGTBasisFuncs, copyOutVal::Bool=true) -&gt; CompositeGTBasisFuncs</code></pre><p>Return a copy of the input basis. If <code>copyOutVal</code> is set to <code>true</code>, then only the output  value(s) of the stored data will be copied, i.e., <a href="#Quiqbox.outValCopy-Union{Tuple{ParamBox{&lt;:Any, V}}, Tuple{V}} where V"><code>outValCopy</code></a> is used to copy the  <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>s, otherwise <a href="#Quiqbox.inVarCopy-Union{Tuple{ParamBox{T}}, Tuple{T}} where T"><code>inVarCopy</code></a> is used.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; e = genExponent(3.0, x-&gt;x^2)
ParamBox{Float64, :Œ±, FLevel{1}}(3.0)[‚àÇ][x_Œ±]

julia&gt; c = genContraction(2.0)
ParamBox{Float64, :d, FLevel{0}}(2.0)[‚àÇ][d]

julia&gt; gf1 = GaussFunc(e, c);

julia&gt; gf2 = copyBasis(gf1)
GaussFunc{Float64, FLevel{0}, FLevel{0}}(xpn()=9.0, con()=2.0, param)

julia&gt; gf1.xpn() == gf2.xpn()
true

julia&gt; (gf1.xpn[] |&gt; gf1.xpn.map) == gf2.xpn[]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1722-L1752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.decompose" href="#Quiqbox.decompose"><code>Quiqbox.decompose</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decompose(bf::CompositeGTBasisFuncs{T, D}, splitGaussFunc::Bool=false) -&gt; 
Matrix{&lt;:BasisFunc{T, D}}</code></pre><p>Decompose a <code>CompositeGTBasisFuncs</code> into a <code>Matrix</code> of <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a>s. The sum of  each column represents one orbital of the input basis function(s). If <code>splitGaussFunc</code> is  <code>true</code>, then each column consists of the <code>BasisFunc</code>s with only 1 <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1435-L1443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.dimOf-Union{Tuple{Quiqbox.DimensionalParamContainer{&lt;:Any, D}}, Tuple{D}} where D" href="#Quiqbox.dimOf-Union{Tuple{Quiqbox.DimensionalParamContainer{&lt;:Any, D}}, Tuple{D}} where D"><code>Quiqbox.dimOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimOf(::DimensionalParamContainer) -&gt; Int</code></pre><p>Return the spatial dimension of the input parameterized container such as  <code>AbstractSpatialPoint</code> and <code>QuiqboxBasis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L753-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T&lt;:AbstractFloat}" href="#Quiqbox.genBFuncsFromText-Union{Tuple{String}, Tuple{T}, Tuple{D}} where {D, T&lt;:AbstractFloat}"><code>Quiqbox.genBFuncsFromText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBFuncsFromText(content::String; adjustContent::Bool=false, 
                  adjustFunction::F=sciNotReplace, 
                  excludeFirstNlines::Int=0, excludeLastNlines::Int=0, 
                  center::Union{AbstractArray, 
                                NTuple{N, ParamBox}, 
                                Missing}=missing, 
                  unlinkCenter::Bool=false) where {N, F&lt;:Function} -&gt; 
Array{&lt;:FloatingGTBasisFuncs, 1}</code></pre><p>Generate a basis set from <code>content</code> which is either a basis set <code>String</code> in Gaussian format  or the output from <code>genBasisFuncText</code>. For the former, <code>adjustContent</code> needs to be set to  <code>true</code>. <code>adjustFunction</code> is only applied when <code>adjustContent=true</code>, which in default is a  <code>function</code> used to detect and convert the format of the scientific notation in <code>content</code>.</p><p><code>excludeFirstNlines</code> and <code>excludeLastNlines</code> are used to exclude first or last few lines of  <code>content</code> if intended. <code>center</code> is used to assign a center coordinate for all the basis  functions from <code>content</code>; when it&#39;s set to <code>missing</code>, it will try to read the center  information in <code>content</code>, and leave the center as <code>[NaN, NaN, Nan]</code> if one cannot be found  for each corresponding <code>FloatingGTBasisFuncs</code>. If <code>unlinkCenter = true</code>, the center of each  <code>FloatingGTBasisFuncs</code> is a <code>Base.deepcopy</code> of the input <code>center</code>. Otherwise, they share  the same underlying data so changing the value of one will affect others. If the center  coordinate is included in <code>content</code>, it should be right above the subshell information for  the <code>FloatingGTBasisFuncs</code>. E.g.:</p><pre><code class="nohighlight hljs">&quot;&quot;&quot;
X        1.0                       0.0                       0.0                
S    1   1.0
         2.0                       1.0
&quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1566-L1595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFunc-Union{Tuple{ùëô}, Tuple{GN}, Tuple{T}, Tuple{D}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}, LTuple{D, ùëô}}} where {D, T, GN, ùëô}" href="#Quiqbox.genBasisFunc-Union{Tuple{ùëô}, Tuple{GN}, Tuple{T}, Tuple{D}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}}, Tuple{SpatialPoint{T, D}, Tuple{Vararg{AbstractGaussFunc{T}, GN}}, LTuple{D, ùëô}}} where {D, T, GN, ùëô}"><code>Quiqbox.genBasisFunc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFunc(center::Union{AbstractVector{T}, Tuple{Vararg{T}}, SpatialPoint, Missing}, 
             args..., kws...) where {T&lt;:Union{AbstractFloat, ParamBox}} -&gt; 
Union{FloatingGTBasisFuncs{T}, Vector{&lt;:FloatingGTBasisFuncs{T}}}</code></pre><p>The constructor of <code>FloatingGTBasisFuncs</code>, but it also returns different kinds of  collections (<code>Vector</code>) of them based on the input arguments. The first argument <code>center</code>  specifies the center coordinate of the generated <code>FloatingGTBasisFuncs</code>, and can be left as  <code>missing</code> for later assignment.</p><p>‚â°‚â°‚â° Method 1 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, GsOrCoeffs, Ls; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs</code></pre><p>=== Positional argument(s) ===</p><p><code>GsOrCoeffs::Union{     AbstractGaussFunc{T1},      AbstractVector{&lt;:AbstractGaussFunc{T1}},      Tuple{Vararg{AbstractGaussFunc{T1}}},      NTuple{2, T1},      NTuple{2, AbstractVector{T1}} } where {T1&lt;:AbstractFloat}</code>: A collection of concentric <code>GaussFunc</code> that will be used to  construct the basis function. To simplify the procedure, it can also be in the form of a  <code>NTuple{2}</code> of the exponent coefficient(s)<code>::Union{AbstractFloat,  AbstractVector{&lt;:AbstractFloat}}</code> and contraction coefficients<code>::Union{AbstractFloat,  AbstractVector{&lt;:AbstractFloat}}</code> of the <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a>(s) to be input.</p><p><code>Ls::Union{     T2,      AbstractVector{T2},      NTuple{&lt;:Any, T2} } where {T2&lt;:Union{Tuple{Vararg{Int}}, LTuple}}</code>: A collection of angular momentum(s)  within the same subshell, in the Cartesian coordinate representation. E.g., for p shell it  can be set to <code>((1,0,0), (0,1,0))</code>. This will determine the number of spatial orbitals and  their angular momentum respectively to be stored in the output <code>FloatingGTBasisFuncs</code>.</p><p>=== Keyword argument(s) ===</p><p><code>normalizeGTO::Bool</code>: Determine whether the inside <code>GaussFunc</code>(s) will be normalized in the  during the calculation. </p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], GaussFunc(2.,1.), (0,1,0))
BasisFunc{Float64, 3, 1, 1, P3D{Float64, 0, 0, 0}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y¬πZ‚Å∞][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 2 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, GsOrCoeffs, subshell=&quot;S&quot;; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs

genBasisFunc(center, GsOrCoeffs, subshell, lFilter; normalizeGTO=false) -&gt; 
FloatingGTBasisFuncs</code></pre><p>=== Positional argument(s) ===</p><p><code>subshell::String</code>: The third argument of the constructor can also be the name of a  subshell, which will make sure the output is a <code>BasisFuncs</code> that contains the spatial  orbitals that fully occupy the subshell. </p><p><code>lFilter::Tuple{Vararg{Bool}}</code>: When this 4th argument is provided, it can determine the  orbital(s) to be included based on the given <code>subshell</code>. The order of the corresponding  orbital angular momentum(s) can be inspected using function <code>orbitalLin</code>.</p><p>=== Keyword argument(s) ===</p><p><code>normalizeGTO::Bool</code>: Same as the one defined in method 1.</p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], (2., 1.), &quot;P&quot;)
BasisFuncs{Float64, 3, 1, 1, P3D{Float64, 0, 0, 0}, 3}(center, gauss, l, normalizeGTO, param)[3/3][0.0, 0.0, 0.0]

julia&gt; genBasisFunc([0.,0.,0.], (2., 1.5), &quot;P&quot;, (true, false, true))
BasisFuncs{Float64, 3, 1, 1, P3D{Float64, 0, 0, 0}, 2}(center, gauss, l, normalizeGTO, param)[2/3][0.0, 0.0, 0.0]</code></pre><p>‚â°‚â°‚â° Method 3 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(center, BSkey, atm=&quot;H&quot;; unlinkCenter=false) -&gt; 
Vector{&lt;:FloatingGTBasisFuncs}</code></pre><p>=== Positional argument(s) ===</p><p><code>BSkey::String</code>: The name of an existed atomic basis set. The supported options are in  <code>[&quot;STO-2G&quot;, &quot;STO-3G&quot;, &quot;STO-6G&quot;, &quot;3-21G&quot;, &quot;6-31G&quot;, &quot;cc-pVDZ&quot;, &quot;cc-pVTZ&quot;, &quot;cc-pVQZ&quot;]</code>.</p><p><code>atm::String</code>: The name of the atom corresponding to the chosen basis set. The supported  options are in <code>[&quot;H&quot;, &quot;He&quot;, &quot;Li&quot;, &quot;Be&quot;, &quot;B&quot;, &quot;C&quot;, &quot;N&quot;, &quot;O&quot;, &quot;F&quot;, &quot;Ne&quot;, &quot;Na&quot;, &quot;Mg&quot;, &quot;Al&quot;, &quot;Si&quot;, &quot;P&quot;, &quot;S&quot;, &quot;Cl&quot;, &quot;Ar&quot;, &quot;K&quot;, &quot;Ca&quot;]</code>.</p><p>=== Keyword argument(s) ===</p><p><code>unlinkCenter::Bool</code>: Determine whether the centers of constructed <code>FloatingGTBasisFuncs</code>  are linked to each other. If set to <code>true</code>, the center of each <code>FloatingGTBasisFuncs</code> is a  <code>Base.deepcopy</code> of each other. Otherwise, they share the same underlying data so changing  the value of one will affect others.</p><p>=== Example(s) ===</p><pre><code class="language-julia-repl hljs">julia&gt; genBasisFunc([0.,0.,0.], &quot;6-31G&quot;);

julia&gt; genBasisFunc([0.,0.,0.], &quot;STO-3G&quot;, &quot;Li&quot;);</code></pre><p>‚â°‚â°‚â° Method 4 ‚â°‚â°‚â°</p><pre><code class="nohighlight hljs">genBasisFunc(b::FloatingGTBasisFuncs{T, D}, newFieldVal) where {T, D} -&gt; 
FloatingGTBasisFuncs{T, D}</code></pre><p>=== Positional argument(s) ===</p><p><code>field::Union{     SpatialPoint{T, D},      Tuple{Vararg{AbstractGaussFunc{T}}},      Tuple{Vararg{LTuple{D, ùëô}}} where ùëô,      Bool } where {T&lt;:AbstractFloat, D}</code>: Any one of the fields inside a <code>FloatingGTBasisFuncs</code>  except <code>param</code>.</p><p>This method outputs a <code>FloatingGTBasisFuncs</code> that has identical fields as the input one  except the field that can be replaced by <code>newFieldVal</code> (and <code>param</code> if the replaced field  contains <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L386-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText-Union{Tuple{FloatingGTBasisFuncs{T, D}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.genBasisFuncText-Union{Tuple{FloatingGTBasisFuncs{T, D}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.genBasisFuncText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bf::FloatingGTBasisFuncs; 
                 norm::Real=1.0, printCenter::Bool=true, roundDigits::Int=-1) -&gt; String</code></pre><p>Generate the text of input <code>FloatingGTBasisFuncs</code>. <code>norm</code> is the additional normalization  factor. If <code>printCenter</code> is <code>true</code>, the center coordinate will be added to the first line  of the output <code>String</code>. <code>roundDigits</code> specifies the rounding digits for the parameters  inside <code>bf</code>. When set to negative, no rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1505-L1514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genBasisFuncText-Union{Tuple{Union{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.genBasisFuncText-Union{Tuple{Union{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.genBasisFuncText</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genBasisFuncText(bs::Union{AbstractVector{&lt;:FloatingGTBasisFuncs{T, D}}, 
                           Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}; 
                 norm::Real=1.0, printCenter::Bool=true, 
                 groupCenters::Bool=true, roundDigits::Int=-1) where {T, D} -&gt; 
String</code></pre><p>Generate the text of input basis set (consisting of <code>FloatingGTBasisFuncs</code>). <code>norm</code> is the  additional normalization factor. <code>groupCenters</code> determines whether the function will group  the basis functions with same center together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1526-L1537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction-Tuple{AbstractFloat, Function}" href="#Quiqbox.genContraction-Tuple{AbstractFloat, Function}"><code>Quiqbox.genContraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genContraction(c::T, mapFunction::Function; canDiff::Bool=true, 
               dataName::Symbol=:undef) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :d}

genContraction(c::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, 
               dataName::Symbol=:undef) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :d}</code></pre><p>Construct a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> for an contraction coefficient given a value. Keywords  <code>mapFunction</code> and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction-Tuple{AbstractFloat}" href="#Quiqbox.genContraction-Tuple{AbstractFloat}"><code>Quiqbox.genContraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genContraction(c::T) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :d}

genContraction(c::Array{T, 0}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :d}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genContraction-Tuple{Any}" href="#Quiqbox.genContraction-Tuple{Any}"><code>Quiqbox.genContraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genContraction(pb::ParamBox{T}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :d}</code></pre><p>Convert a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> to an exponent coefficient parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent-Tuple{AbstractFloat, Function}" href="#Quiqbox.genExponent-Tuple{AbstractFloat, Function}"><code>Quiqbox.genExponent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genExponent(e::T, mapFunction::Function; canDiff::Bool=true, 
            dataName::Symbol=:undef) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :Œ±}

genExponent(e::Array{T, 0}, mapFunction::Function; canDiff::Bool=true, 
            dataName::Symbol=:undef) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T, :Œ±}</code></pre><p>Construct a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> for an exponent coefficient given a value. Keywords  <code>mapFunction</code> and <code>canDiff</code> work the same way as in a general constructor of a <code>ParamBox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L48-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent-Tuple{AbstractFloat}" href="#Quiqbox.genExponent-Tuple{AbstractFloat}"><code>Quiqbox.genExponent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genExponent(e::T) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :Œ±}

genExponent(e::Array{T, 0}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :Œ±}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genExponent-Tuple{ParamBox}" href="#Quiqbox.genExponent-Tuple{ParamBox}"><code>Quiqbox.genExponent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genExponent(pb::ParamBox{T}) where {T&lt;:AbstractFloat} -&gt; ParamBox{T, :Œ±}</code></pre><p>Convert a <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> to the container of an exponent coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Tuple{AbstractFloat, Int64, Function}" href="#Quiqbox.genSpatialPoint-Tuple{AbstractFloat, Int64, Function}"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(comp::T, index::Int) where {T&lt;:AbstractFloat} -&gt; ParamBox{T}

genSpatialPoint(comp::Array{T, 0}, index::Int) where {T&lt;:AbstractFloat} -&gt; ParamBox{T}

genSpatialPoint(comp::T, index::Int, mapFunction::Function; canDiff::Bool=true, 
                dataName::Symbol=:undef) where {T&lt;:AbstractFloat} -&gt; 
ParamBox{T}

genSpatialPoint(comp::Array{T, 0}, index::Int, mapFunction::Function; 
                canDiff::Bool=true, dataName::Symbol=:undef) where 
               {T&lt;:AbstractFloat} -&gt; 
ParamBox{T}

genSpatialPoint(comp::ParamBox{T}, index::Int) where {T&lt;:AbstractFloat} -&gt; ParamBox{T}</code></pre><p>Return the component of a <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a> given its value (or 0-D container) and  index.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; genSpatialPoint(1.2, 1)
ParamBox{Float64, :X, FLevel{0}}(1.2)[‚àÇ][X]

julia&gt; pointY1 = fill(2.0);

julia&gt; Y1 = genSpatialPoint(pointY1, 2)
ParamBox{Float64, :Y, FLevel{0}}(2.0)[‚àÇ][Y]

julia&gt; pointY1[] = 1.5;

julia&gt; Y1
ParamBox{Float64, :Y, FLevel{0}}(1.5)[‚àÇ][Y]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L200-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Tuple{AbstractVector, Vararg{Any}}" href="#Quiqbox.genSpatialPoint-Tuple{AbstractVector, Vararg{Any}}"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(point::Union{Tuple{Vararg{AbstractFloat}}, 
                                   AbstractVector{&lt;:AbstractFloat}}, 
                mapFunction::F=itself; canDiff::Bool=true, dataName::Symbol=:undef) -&gt; 
SpatialPoint

genSpatialPoint(point::Union{Tuple{Vararg{Array{&lt;:AbstractFloat, 0}}}, 
                             AbstractVector{&lt;:Array{&lt;:AbstractFloat, 0}}}, 
                mapFunction::F=itself; canDiff::Bool=true, dataName::Symbol=:undef) -&gt; 
SpatialPoint</code></pre><p>The constructor of <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>. Keywords <code>mapFunction</code> and <code>canDiff</code> work the  same way as in a general constructor of a <code>ParamBox</code>. If <code>roundDigits &lt; 0</code> or <code>point</code> is a  0-dimensional <code>Array</code>, there won&#39;t be rounding for input data.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; v1 = [1.0, 2.0, 3.0];

julia&gt; genSpatialPoint(v1)
SpatialPoint{Float64, 3, P3D{Float64, 0, 0, 0}}(param)[1.0, 2.0, 3.0][‚àÇ][‚àÇ][‚àÇ]

julia&gt; v2 = [fill(1.0), 2.0, 3.0];

julia&gt; p2 = genSpatialPoint(v2); p2[1]
ParamBox{Float64, :X, FLevel{0}}(1.0)[‚àÇ][X]

julia&gt; v2[1][] = 1.2
1.2

julia&gt; p2[1]
ParamBox{Float64, :X, FLevel{0}}(1.2)[‚àÇ][X]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L160-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.genSpatialPoint-Union{Tuple{Tuple{Vararg{ParamBox, N}}}, Tuple{N}} where N" href="#Quiqbox.genSpatialPoint-Union{Tuple{Tuple{Vararg{ParamBox, N}}}, Tuple{N}} where N"><code>Quiqbox.genSpatialPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genSpatialPoint(point::Union{Tuple{Vararg{ParamBox}}, AbstractVector{&lt;:ParamBox}}) -&gt; 
SpatialPoint</code></pre><p>Convert a collection of <a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>s to a <a href="../coreType/#Quiqbox.SpatialPoint"><code>SpatialPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getParams" href="#Quiqbox.getParams"><code>Quiqbox.getParams</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParams(pbc::ParamBox, symbol::Union{Symbol, Missing}=missing; 
          forDifferentiation::Bool=false) -&gt; 
Union{ParamBox, Nothing}

getParams(pbc::ParameterizedContainer, symbol::Union{Symbol, Missing}=missing; 
          forDifferentiation::Bool=false) -&gt; 
AbstractVector{&lt;:ParamBox}

getParams(pbc::Union{AbstractArray, Tuple}, symbol::Union{Symbol, Missing}=missing; 
          forDifferentiation::Bool=false) -&gt; 
AbstractVector{&lt;:ParamBox}</code></pre><p>Return the parameter(s) stored in the input container. If <code>symbol</code> is set to <code>missing</code>,  then return all parameter(s); if it&#39;s set to the <code>Symbol</code> of a parameter (e.g., <code>:Œ±‚ÇÅ</code> will  match any <code>pb::</code><a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a> such that <code>getVar(pb) == :Œ±‚ÇÅ</code>; <code>:Œ±</code> will match all the  <code>pb</code>s that are <code>ParamBox{&lt;:Any, Œ±}</code>. <code>forDifferentiation</code> determines whether searching  through the <code>Symbol</code>(s) of the independent variable(s) represented by <code>pbc</code> during the  differentiation process. If the first argument is a collection, its entries must be  <code>ParamBox</code> containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1669-L1690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.lOf-Union{Tuple{FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, ùëô}}, Tuple{ùëô}} where ùëô" href="#Quiqbox.lOf-Union{Tuple{FloatingGTBasisFuncs{&lt;:Any, &lt;:Any, ùëô}}, Tuple{ùëô}} where ùëô"><code>Quiqbox.lOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lOf(::FloatingGTBasisFuncs) -&gt; Int</code></pre><p>Return the total orbital angular momentum quantum number (in Cartesian coordinate  representation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L610-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.markParams!-Union{Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}}, Tuple{T}, Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}, Bool}} where T&lt;:Quiqbox.ParameterizedContainer" href="#Quiqbox.markParams!-Union{Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}}, Tuple{T}, Tuple{Union{Tuple{Vararg{T}}, AbstractVector{T}, T}, Bool}} where T&lt;:Quiqbox.ParameterizedContainer"><code>Quiqbox.markParams!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">markParams!(b::Union{AbstractVector{T}, T, Tuple{Vararg{T}}}, 
            filterMapping::Bool=false) where {T&lt;:ParameterizedContainer} -&gt; 
Vector{&lt;:ParamBox}</code></pre><p>Mark the parameters (<a href="../coreType/#Quiqbox.ParamBox"><code>ParamBox</code></a>) in <code>b</code>. The parameters that will be considered  identical in the differentiation procedure will be marked with same index. <code>filterMapping</code>  determines whether filtering out (i.e. not return) the extra <code>ParamBox</code>s that have the same  indices despite may having different mapping functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1770-L1780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{ùëô2}, Tuple{ùëô1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, ùëô1, 1, PT1}, BasisFunc{T, D, ùëô2, 1, PT2}}} where {T, D, ùëô1, ùëô2, PT1, PT2}" href="#Quiqbox.mul-Union{Tuple{PT2}, Tuple{PT1}, Tuple{ùëô2}, Tuple{ùëô1}, Tuple{D}, Tuple{T}, Tuple{BasisFunc{T, D, ùëô1, 1, PT1}, BasisFunc{T, D, ùëô2, 1, PT2}}} where {T, D, ùëô1, ùëô2, PT1, PT2}"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(a1::Real, a2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, a2::Real; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}

mul(a1::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}, 
    a2::CompositeGTBasisFuncs{T, D, &lt;:Any, 1}; 
    normalizeGTO::Union{Bool, Missing}=missing, 
    roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code></pre><p>Multiplication between two <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code>s (e.g.,   <a href="../coreType/#Quiqbox.BasisFunc"><code>BasisFunc</code></a> and <a href="../coreType/#Quiqbox.BasisFuncMix"><code>BasisFuncMix</code></a>), or a <code>Real</code> number and a  <code>CompositeGTBasisFuncs{T, D, &lt;:Any, 1}</code>. If <code>normalizeGTO</code> is set to <code>missing</code> (in  default), The <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a> inside the output containers will be normalized only if  all the input bases hold <code>.normalizeGTO == true</code>. <code>roundDigits</code> specifies the maximal  number of digits after the radix point of the calculated values. When set to negative, no  rounding will be performed. The function can be called using <code>*</code> syntax with the keyword  arguments set to their default values.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; bf1 = genBasisFunc([1.0, 1.0, 1.0], ([2.0, 1.0], [0.1, 0.2]))
BasisFunc{Float64, 3, 0, 2, P3D{Float64, 0, 0, 0}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; bf2 = bf1 * 2
BasisFunc{Float64, 3, 0, 2, P3D{Float64, 0, 0, 0}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]

julia&gt; getindex.(getproperty.(bf2.gauss, :con))
(0.2, 0.4)

julia&gt; bf3 = bf1 * bf2
BasisFunc{Float64, 3, 0, 3, P3D{Float64, 0, 0, 0}}(center, gauss, l, normalizeGTO, param)[X‚Å∞Y‚Å∞Z‚Å∞][1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1163-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.mul-Union{Tuple{T}, Tuple{GaussFunc{T}, Real}} where T" href="#Quiqbox.mul-Union{Tuple{T}, Tuple{GaussFunc{T}, Real}} where T"><code>Quiqbox.mul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul(gf::GaussFunc{T}, coeff::Real; roundDigits::Int=getAtolDigits(T)) where {T} -&gt; 
GaussFunc

mul(coeff::Real, gf::GaussFunc{T}; roundDigits::Int=getAtolDigits(T)) where {T} -&gt; 
GaussFunc

mul(gf1::GaussFunc{T}, gf2::GaussFunc{T}; 
    roundDigits::Int=getAtolDigits(T)) where {T} -&gt; 
GaussFunc</code></pre><p>Multiplication between a <code>Real</code> number and a <a href="../coreType/#Quiqbox.GaussFunc"><code>GaussFunc</code></a> or two <code>GaussFunc</code>s.  <code>roundDigits</code> specifies the maximal number of digits after the radix point of the  calculated values. When set to negative, no rounding will be performed. The function can be  called using <code>*</code> syntax with the keyword argument set to it default value.</p><p>‚â°‚â°‚â° Example(s) ‚â°‚â°‚â°</p><pre><code class="language-julia-repl hljs">julia&gt; gf1 = GaussFunc(3.0, 1.0)
GaussFunc{Float64, FLevel{0}, FLevel{0}}(xpn()=3.0, con()=1.0, param)

julia&gt; gf1 * 2
GaussFunc{Float64, FLevel{0}, FLevel{0}}(xpn()=3.0, con()=2.0, param)

julia&gt; gf1 * gf1
GaussFunc{Float64, FLevel{0}, FLevel{0}}(xpn()=6.0, con()=1.0, param)

julia&gt; gf1 * 2 * gf1
GaussFunc{Float64, FLevel{0}, FLevel{0}}(xpn()=6.0, con()=2.0, param)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1102-L1134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalNumOf" href="#Quiqbox.orbitalNumOf"><code>Quiqbox.orbitalNumOf</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbitalNumOf(subshell::String, D::Integer=3) -&gt; Int</code></pre><p>Return the size (number of orbitals) of each subshell in <code>D</code> dimensional real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1479-L1484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.orbitalNumOf-Union{Tuple{Quiqbox.QuiqboxBasis{&lt;:Any, &lt;:Any, ON}}, Tuple{ON}} where ON" href="#Quiqbox.orbitalNumOf-Union{Tuple{Quiqbox.QuiqboxBasis{&lt;:Any, &lt;:Any, ON}}, Tuple{ON}} where ON"><code>Quiqbox.orbitalNumOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orbitalNumOf(b::QuiqboxBasis) -&gt; Int</code></pre><p>Return the numbers of orbitals of the input basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1487-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.shift-Union{Tuple{F}, Tuple{GN}, Tuple{ùëô}, Tuple{D}, Tuple{FloatingGTBasisFuncs{var&quot;#s47&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s47&quot;, PT}, AbstractArray{Int64}}, Tuple{FloatingGTBasisFuncs{var&quot;#s46&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s46&quot;, PT}, AbstractArray{Int64}, F}} where {D, ùëô, GN, F&lt;:Function}" href="#Quiqbox.shift-Union{Tuple{F}, Tuple{GN}, Tuple{ùëô}, Tuple{D}, Tuple{FloatingGTBasisFuncs{var&quot;#s47&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s47&quot;, PT}, AbstractArray{Int64}}, Tuple{FloatingGTBasisFuncs{var&quot;#s46&quot;, D, ùëô, GN, PT, 1} where {var&quot;#s46&quot;, PT}, AbstractArray{Int64}, F}} where {D, ùëô, GN, F&lt;:Function}"><code>Quiqbox.shift</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(bf::FloatingGTBasisFuncs{T, D, ùëô, GN, PT, 1}, 
      dl::Union{Vector{Int}, NTuple{D, Int}, LTuple{D}}, op::Function=+) where 
     {T, D, ùëô, GN, PT} -&gt; 
BasisFunc{T, D, &lt;:Any, GN, PT}</code></pre><p>Shift (<code>+</code> as the default binary operator <code>op</code>) the angular momentum (in Cartesian  representation) of the input <code>FloatingGTBasisFuncs</code> given <code>dl</code> that specifies the change of  each component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L1393-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Tuple{GTBasis}" href="#Quiqbox.sortBasis-Tuple{GTBasis}"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(b::GTBasis{T, D}; roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
GTBasis{T, D}</code></pre><p>Reconstruct a <a href="../coreType/#Quiqbox.GTBasis"><code>GTBasis</code></a> by sorting the <code>GTBasisFuncs</code> stored in the input one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L848-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(bs::Union{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}, 
                    Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}; 
          roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
Vector{&lt;:CompositeGTBasisFuncs{T, D}}</code></pre><p>Sort basis functions. <code>roundDigits</code> specifies the rounding digits for the parameters stored in each <code>CompositeGTBasisFuncs</code> when comparing them. When set to negative, no rounding will  be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L808-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasis-Union{Tuple{Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortBasis-Union{Tuple{Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasis(bs::Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}; 
          roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
Tuple{Vararg{CompositeGTBasisFuncs{T, D}}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L837-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}" href="#Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}"><code>Quiqbox.sortBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, 
               groupCenters::Bool=false; roundDigits::Int=getAtolDigits(T)) where 
              {T, D} -&gt; 
Vector</code></pre><p>Sort <code>FloatingGTBasisFuncs</code>. If <code>groupCenters = true</code>, Then the function will return an  <code>Vector{&lt;:Vector{&lt;:FloatingGTBasisFuncs}}</code> in which the elements are grouped basis  functions with same center coordinates. <code>roundDigits</code> specifies the rounding digits for  center coordinates when comparing them. When set to negative, no rounding will be performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L629-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortBasisFuncs-Union{Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}, Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, Bool}} where {T, D}" href="#Quiqbox.sortBasisFuncs-Union{Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}, Tuple{Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, Bool}} where {T, D}"><code>Quiqbox.sortBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortBasisFuncs(bs::Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}, groupCenters::Bool=false; 
               roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
Tuple</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L653-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortPermBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortPermBasis-Union{Tuple{AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortPermBasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortPermBasis(bs::AbstractArray{&lt;:CompositeGTBasisFuncs{T, D}}; 
              roundDigits::Int=getAtolDigits(T)) where {T, D} -&gt; 
Vector{Int}</code></pre><p>Return a <code>Vector</code> of indices <code>I</code> such that <code>bs[I] ==</code><a href="#Quiqbox.sortBasis-Tuple{GTBasis}"><code>sortBasis</code></a> <code>(bs; roundDigits)[I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L859-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.sortPermBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.sortPermBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.sortPermBasisFuncs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortPermBasisFuncs(bs::Union{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, 
                             Tuple{Vararg{FloatingGTBasisFuncs{T, D}}}}) where 
                  {T, D} -&gt; 
Vector{Int}</code></pre><p>Return a <code>Vector</code> of indices <code>I</code> such that <code>bs[I] ==</code><a href="#Quiqbox.sortBasisFuncs-Union{Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}}, Tuple{D}, Tuple{T}, Tuple{AbstractArray{&lt;:FloatingGTBasisFuncs{T, D}}, Bool}} where {T, D}"><code>sortBasisFuncs</code></a> <code>(bs; roundDigits)[I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L665-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.subshellOf-Tuple{FloatingGTBasisFuncs}" href="#Quiqbox.subshellOf-Tuple{FloatingGTBasisFuncs}"><code>Quiqbox.subshellOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subshellOf(::FloatingGTBasisFuncs) -&gt; String</code></pre><p>Return the corresponding subshell of the input <code>FloatingGTBasisFuncs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Basis.jl#L620-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHF-Union{Tuple{T2}, Tuple{HFT}, Tuple{NN}, Tuple{BFT}, Tuple{BN}, Tuple{D}, Tuple{T1}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}, HFconfig{T2, HFT}}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}, HFconfig{T2, HFT}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T1, D, BN, BFT, NN, HFT, T2}" href="#Quiqbox.runHF-Union{Tuple{T2}, Tuple{HFT}, Tuple{NN}, Tuple{BFT}, Tuple{BN}, Tuple{D}, Tuple{T1}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}, HFconfig{T2, HFT}}, Tuple{GTBasis{T1, D, BN, BFT}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T1, D}}, 1}, Tuple{Vararg{AbstractVector{T1}}}, Tuple{Vararg{Tuple{Vararg{T1, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T1}}, HFconfig{T2, HFT}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T1, D, BN, BFT, NN, HFT, T2}"><code>Quiqbox.runHF</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runHF(bs, nuc, nucCoords, config=HFconfig(), N=getCharge(nuc); printInfo=true) -&gt; 
HFfinalVars

runHF(bs, nuc, nucCoords, N=getCharge(nuc), config=HFconfig(); printInfo=true) -&gt; 
HFfinalVars</code></pre><p>Main function to run Hartree-Fock in Quiqbox.</p><p>‚â°‚â°‚â° Positional argument(s) ‚â°‚â°‚â°</p><p><code>bs::Union{     BasisSetData{T, D},      AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}},      Tuple{Vararg{AbstractGTBasisFuncs{T, D}}} } where {T, D}</code>: The basis set used for the Hartree-Fock approximation.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}} where {T, D, NN}</code>: The coordinates of corresponding nuclei.</p><p><code>config::HFconfig</code>: The Configuration of selected Hartree-Fock method. For more information  please refer to <a href="../coreType/#Quiqbox.HFconfig"><code>HFconfig</code></a>.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p>‚â°‚â°‚â° Keyword argument(s) ‚â°‚â°‚â°</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps and result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/HartreeFock.jl#L581-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.runHFcore-Union{Tuple{T2}, Tuple{HFTS}, Tuple{L}, Tuple{T1}, Tuple{HFT}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64, Bool}} where {HFT, T1, L, HFTS, T2}" href="#Quiqbox.runHFcore-Union{Tuple{T2}, Tuple{HFTS}, Tuple{L}, Tuple{T1}, Tuple{HFT}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64}, Tuple{Val{HFT}, SCFconfig{T1, L}, Tuple{Vararg{Int64, HFTS}}, AbstractMatrix{T2}, AbstractArray{T2, 4}, AbstractMatrix{T2}, AbstractMatrix{T2}, Tuple{Vararg{AbstractMatrix{T2}, HFTS}}, Bool, Int64, Bool}} where {HFT, T1, L, HFTS, T2}"><code>Quiqbox.runHFcore</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runHFcore(HTtype, scfConfig, N, Hcore, HeeI, S, X, C0, 
          printInfo=false, maxStep=1000, earlyStop=true) -&gt; 
Tuple{Tuple{Vararg{HFtempVars}}, Bool}</code></pre><p>The core function of <code>runHF</code> which returns the data collected during the iteration and the  result of whether the SCF procedure is converged.</p><p>=== Positional argument(s) ===</p><p><code>HTtype::Val{HFT} where HFT</code>: Hartree-Fock method type. Available values of <code>HFT</code> are  :RHF, :UHF.</p><p><code>scfConfig::SCFconfig</code>: The SCF iteration configuration.</p><p><code>N::NTuple{HFTS, Int} where HFTS</code>: The numbers of electrons with same spin configurations. </p><p><code>Hcore::AbstractMatrix{T} where T</code>: The core Hamiltonian of the electronic Hamiltonian.</p><p><code>HeeI::AbstractArray{T, 4} where T</code>: The electron-electron interaction tensor (in the  chemists&#39; notation) which includes both the Coulomb interactions and the Exchange  Correlations.</p><p><code>S::AbstractMatrix{T} where T</code>: The overlap matrix of the used basis set.</p><p><code>X::AbstractMatrix{T} where T</code>: The transformation matrix of <code>S</code>.</p><p><code>C0::NTuple{HFTS, AbstractMatrix{T}} where {HFTS, T}</code>: Initial guess of the coefficient  matrix(s) of the canonical spin-orbitals.</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps and result.</p><p><code>maxStep::Int</code>: Maximum iteration steps allowed regardless if the iteration converges.</p><p><code>earlyStop::Bool</code>: Whether automatically terminate (or skip) a convergence method early  when its performance becomes unstable or poor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/HartreeFock.jl#L655-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradOfHFenergy-Union{Tuple{NN}, Tuple{HFTS}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, HFTS, NN}" href="#Quiqbox.gradOfHFenergy-Union{Tuple{NN}, Tuple{HFTS}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}, Tuple{AbstractVector{&lt;:ParamBox}, GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{AbstractMatrix{T}, HFTS}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, HFTS, NN}"><code>Quiqbox.gradOfHFenergy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradOfHFenergy(par, basis, C, nuc, nucCoords, N=getCharge(nuc)) -&gt;
AbstractVector

gradOfHFenergy(par, bs, S, C, nuc, nucCoords, N=getCharge(nuc)) -&gt;
AbstractVector</code></pre><p>Two methods of <code>gradOfHFenergy</code>.</p><p>‚â°‚â°‚â° Positional argument(s) ‚â°‚â°‚â°</p><p><code>par::AbstractVector{&lt;:ParamBox}</code>: The parameters for differentiation.</p><p><code>basis::</code><a href="../coreType/#Quiqbox.GTBasis"><code>GTBasis</code></a><code>{T, D} where {T, D}</code>: Basis set information.</p><p><code>C::NTuple{&lt;:Any, AbstractMatrix{T}} where T</code>: The coefficient matrix(s) of the canonical  orbitals with respect to the selected basis set.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}} where {T, D, NN}</code>: The coordinates of corresponding nuclei.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p><code>bs::Union{     NTuple{BN, GTBasisFuncs{T, D, 1}},      AbstractVector{&lt;:GTBasisFuncs{T, D, 1}} } where {T, D}</code>: A collection of basis functions.</p><p><code>S::AbstractMatrix{T} where T</code>: The overlap lap of the basis set when <code>bs</code> is provided as  the second argument.</p><p><strong>NOTE 1:</strong> If any of these two methods is applied, the user needs to make sure the row  orders as well as the colum orders of <code>C</code> and (or) <code>S</code> are consistent with the element  order of <code>bs</code> (<code>basis.basis</code>). ``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Differentiation.jl#L144-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gridCoordOf-Tuple{GridBox}" href="#Quiqbox.gridCoordOf-Tuple{GridBox}"><code>Quiqbox.gridCoordOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridCoordOf(gb::GridBox{T}) where {T} -&gt; Tuple{Vararg{Vector{T}}}</code></pre><p>Return the coordinates of the grid points stored in <code>gb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Box.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.gradDescent!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, T}} where T" href="#Quiqbox.gradDescent!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractVector{T}, AbstractVector{T}, T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, T}} where T"><code>Quiqbox.gradDescent!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradDescent!(vars::AbstractVector{T}, grad::AbstractVector{T}, Œ∑::T=T(0.001), 
             threshold::T=2sqrt(length(grad))/(25norm(Œ∑))) where {T} -&gt; 
vars::AbstractVector{T}</code></pre><p>Default gradient descent (GD) method used in <a href="#Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NN, M, CBT, F}"><code>optimizeParams!</code></a>. <code>vars</code> are the  input variables of a function with corresponding gradient <code>grad</code>. <code>Œ∑</code> is the learning rate  (step size) of the gradient descent. <code>threshold</code> is the clipping threshold of <code>grad</code> which  will be renormalized if it&#39;s larger then <code>threshold</code> to prevent gradient exploding.  <code>gradDescent!</code> modifies the <code>vars</code> and returns the updated value. It can be replaced by a  more advanced GD function through customizing <a href="../coreType/#Quiqbox.POconfig"><code>POconfig</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Optimization.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NN, M, CBT, F}" href="#Quiqbox.optimizeParams!-Union{Tuple{F}, Tuple{CBT}, Tuple{M}, Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}}, Tuple{AbstractVector{&lt;:ParamBox{T}}, Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}, POconfig{&lt;:Any, M, CBT, F}, Union{Int64, Tuple{Int64}, Tuple{Int64, Int64}}}} where {T, D, NN, M, CBT, F}"><code>Quiqbox.optimizeParams!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeParams!(pbs, bs, nuc, nucCoords, 
                config=POconfig(), N=getCharge(nuc); printInfo=true) -&gt; 
Tuple{Vector{T}, Matrix{T}, Matrix{T}} where {T}

optimizeParams!(pbs, bs, nuc, nucCoords, 
                N=getCharge(nuc), config=POconfig(); printInfo=true) -&gt; 
Tuple{Vector{T}, Matrix{T}, Matrix{T}} where {T}</code></pre><p>The main function to optimize the parameters of a given basis set. It returns a <code>Tuple</code> of  the energies, the parameter values and the gradients of all the steps. For latter two, each  column is the result of each step.</p><p>=== Positional argument(s) ===</p><p><code>pbs::AbstractVector{&lt;:ParamBox{T}}</code>: The parameters to be optimized that are extracted  from the basis set. If the parameter is marked as &quot;differentiable&quot;, the value of its input  variable will be optimized.</p><p><code>bs::Union{     Tuple{Vararg{AbstractGTBasisFuncs{T, D}}},      AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}} }</code>: The basis set to be optimized.</p><p><code>nuc::Union{     NTuple{NN, String} where NN,      AbstractVector{String} }</code>: The nuclei in the studied system.</p><p><code>nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}} where {T, D, NN}</code>: The coordinates of corresponding nuclei.</p><p><code>config::POconfig</code>: The Configuration of selected parameter optimization method. For more  information please refer to <a href="../coreType/#Quiqbox.POconfig"><code>POconfig</code></a>.</p><p><code>N::Union{Int, Tuple{Int}, NTuple{2, Int}}</code>: Total number of electrons, or the number(s) of  electrons with same spin configurations(s).</p><p>=== Keyword argument(s) ===</p><p><code>printInfo::Bool</code>: Whether print out the information of iteration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Optimization.jl#L110-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Tuple{Quiqbox.HFfinalVars}" href="#Quiqbox.changeHbasis-Tuple{Quiqbox.HFfinalVars}"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(HFres::HFfinalVars) -&gt; NTuple{2, Any}</code></pre><p>Return the one-body and two-body integrals on the basis of the canonical orbitals  using the result of a Hartree-Fock method <code>HFres</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{String, NN}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractMatrix{T}}} where {T, D, NN}" href="#Quiqbox.changeHbasis-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{GTBasis{T, D, BN, BFT} where {BN, BFT&lt;:GTBasisFuncs{T, D, 1}}, Tuple{Vararg{String, NN}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractMatrix{T}}} where {T, D, NN}"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(b::GTBasis{T, D}, 
             nuc::NTuple{NN, String}, nucCoords::NTuple{NN, NTuple{D, T}}, 
             C::Union{AbstractMatrix{T}, NTuple{2, AbstractMatrix{T}}}) where 
            {T, D, NN} -&gt; 
NTuple{2, Any}</code></pre><p>Return the one-body and two-body integrals after a change of basis based on the input <code>C</code>,  given the basis set information <code>b</code>. The type of each element in the returned <code>Tuple</code> is  consistent with the cases where the first argument of <code>changeHbasis</code> is an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Vararg{AbstractMatrix{T}, 2}}} where T" href="#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Vararg{AbstractMatrix{T}, 2}}} where T"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(twoBodyInt::AbstractArray{T, 4}, 
             C1::AbstractMatrix{T}, C2::AbstractMatrix{T}) where {T} -&gt; 
AbstractArray{T, 4}</code></pre><p>Change the basis of the input two-body integrals <code>twoBodyInt</code> based on two orbital  coefficient matrices <code>C1</code> and <code>C2</code> for different spin configurations (e.g., the  unrestricted case). The output is a 3-element <code>Tuple</code> of which the first 2 elements are the  spatial integrals of each spin configurations respectively, while the last element is the  Coulomb interactions between orbitals with different spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#Quiqbox.changeHbasis-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>Quiqbox.changeHbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeHbasis(DbodyInt::AbstractArray{T, D}, C::AbstractMatrix{T}) where {T} -&gt; 
AbstractArray{T, D}</code></pre><p>Change the basis of the input one-body / two-body integrals <code>DbodyInt</code> based on the orbital  coefficient matrix <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.getCanOrbitals-Tuple{Quiqbox.HFfinalVars}" href="#Quiqbox.getCanOrbitals-Tuple{Quiqbox.HFfinalVars}"><code>Quiqbox.getCanOrbitals</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getCanOrbitals(fVars::HFfinalVars{T, D, &lt;:Any, NN}) where {T, D, NN} -&gt; 
CanOrbital{T, D, NN}</code></pre><p>Generate a set of canonical orbitals from the result of a Hartree-Fock approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.nnRepulsions-Union{Tuple{T}, Tuple{D}, Tuple{NN}, Tuple{Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {NN, D, T}" href="#Quiqbox.nnRepulsions-Union{Tuple{T}, Tuple{D}, Tuple{NN}, Tuple{Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {NN, D, T}"><code>Quiqbox.nnRepulsions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nnRepulsions(nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}) where {NN, D, T} -&gt; 
T</code></pre><p>Return the nuclear repulsion energy given nuclei <code>nuc</code> and their coordinates <code>nucCoords</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Matter.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreH-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}" href="#Quiqbox.coreH-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}"><code>Quiqbox.coreH</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coreH(bs::Union{GTBasis, Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, 
      nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
      nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}) where {T, D, NN} -&gt; 
Matrix{T}</code></pre><p>Return the core Hamiltonian given a basis set and the corresponding nuclei with their  coordinates (in atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.coreHij-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}" href="#Quiqbox.coreHij-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}"><code>Quiqbox.coreHij</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coreHij(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, 
        nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
        nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}) where {T, D, NN} -&gt; 
T</code></pre><p>Return a matrix element of the core Hamiltonian given two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eKinetic-Union{Tuple{T}, Tuple{D}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {D, T}" href="#Quiqbox.eKinetic-Union{Tuple{T}, Tuple{D}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {D, T}"><code>Quiqbox.eKinetic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eKinetic(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where 
        {T, D} -&gt; 
T</code></pre><p>Return the electron kinetic energy between two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eKinetics-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.eKinetics-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.eKinetics</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eKinetics(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                    AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) where {T, D} -&gt; 
Matrix{T}</code></pre><p>Return the electron kinetic energy matrix given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.neAttraction-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}" href="#Quiqbox.neAttraction-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}"><code>Quiqbox.neAttraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neAttraction(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}, 
             nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
             nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}) where {T, D, NN} -&gt; 
T</code></pre><p>Return the nuclear attraction between two basis functions, provided with the nuclei and  their coordinates (in the atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.neAttractions-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}" href="#Quiqbox.neAttractions-Union{Tuple{NN}, Tuple{D}, Tuple{T}, Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, Union{Tuple{Vararg{String, NN}}, AbstractVector{String}}, Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}}} where {T, D, NN}"><code>Quiqbox.neAttractions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neAttractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                        AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}, 
              nuc::Union{NTuple{NN, String}, AbstractVector{String}}, 
              nucCoords::Union{AbstractArray{Tuple{Vararg{T, D}}, 1}, Tuple{Vararg{AbstractVector{T}}}, Tuple{Vararg{Tuple{Vararg{T, D}}, NN}}, AbstractVector{VT} where VT&lt;:AbstractVector{T}}) where {T, D, NN} -&gt; 
Matrix{T}</code></pre><p>Return the nuclear attraction matrix given a basis set and the corresponding nuclei with  their coordinates (in atomic units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L73-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlap-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}" href="#Quiqbox.overlap-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGTBasisFuncs{T, D, 1}, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}"><code>Quiqbox.overlap</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap(bf1::AbstractGTBasisFuncs{T, D, 1}, bf2::AbstractGTBasisFuncs{T, D, 1}) where 
       {T, D, 1} -&gt; 
T</code></pre><p>Return the orbital overlap between two basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.overlaps-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.overlaps-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.overlaps</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                   AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) where {T, D} -&gt; 
Matrix{T}</code></pre><p>Return the orbital overlap matrix given a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/OneBody.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteraction-Union{Tuple{D}, Tuple{T}, NTuple{4, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}" href="#Quiqbox.eeInteraction-Union{Tuple{D}, Tuple{T}, NTuple{4, AbstractGTBasisFuncs{T, D, 1}}} where {T, D}"><code>Quiqbox.eeInteraction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeInteraction(bf1::AbstractGTBasisFuncs{T, D, 1}, 
              bf2::AbstractGTBasisFuncs{T, D, 1}, 
              bf3::AbstractGTBasisFuncs{T, D, 1}, 
              bf4::AbstractGTBasisFuncs{T, D, 1}) where {T, D} -&gt; 
T</code></pre><p>Return an electron-electron interaction tensor element given four basis functions (ordered  in the chemists&#39; notation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/TwoBody.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeInteractions-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}" href="#Quiqbox.eeInteractions-Union{Tuple{Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}}, Tuple{D}, Tuple{T}} where {T, D}"><code>Quiqbox.eeInteractions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeInteractions(bs::Union{Tuple{Vararg{AbstractGTBasisFuncs{T, D}}}, 
                         AbstractVector{&lt;:AbstractGTBasisFuncs{T, D}}}) -&gt; 
Array{T, 4}</code></pre><p>Return the tensor of electron-electron interactions (in the chemists&#39; notation) given a  basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/TwoBody.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quiqbox.eeIuniqueIndicesOf-Tuple{Int64}" href="#Quiqbox.eeIuniqueIndicesOf-Tuple{Int64}"><code>Quiqbox.eeIuniqueIndicesOf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eeIuniqueIndicesOf(basisSetSize::Int) -&gt; Vector{Vector{Int}}</code></pre><p>Return the unique matrix element indices (in the chemists&#39; notation) of electron-electron  interactions given the size of a basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/frankwswang/Quiqbox.jl/blob/13c6b1ce9deb259a7570e0387f8f988e3a8d6666/src/Integrals/Core.jl#L1136-L1142">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">¬´ Parameter Optimization</a><a class="docs-footer-nextpage" href="../coreType/">Core Types ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 7 August 2022 07:42">Sunday 7 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
